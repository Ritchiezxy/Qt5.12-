<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qqmlengine.cpp -->
  <title>QQmlEngine Class | Qt QML 5.12.3</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
  <div class="main">
    <div class="main-rounded">
      <div class="navigationbar">
        <table><tr>
<td ><a href="../qtdoc/index.html">Qt 5.12</a></td><td ><a href="qtqml-index.html">Qt QML</a></td><td ><a href="qtqml-module.html">C++ Classes</a></td><td >QQmlEngine</td></tr></table><table class="buildversion"><tr>
<td id="buildversion" width="100%" align="right"><a href="qtqml-index.html">Qt 
5.12.3 <span lang="zh-cn">参考指南</span></a></td>
        </tr></table>
      </div>
    </div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3><a name="toc">Contents</a></h3>
<ul>
<li class="level1"><a href="#public-types"><span lang="zh-cn">公用类型</span></a></li>
<li class="level1"><a href="#properties"><span lang="zh-cn">属性</span></a></li>
<li class="level1"><a href="#public-functions"><span lang="zh-cn">公用函数</span></a></li>
<li class="level1"><a href="#public-slots"><span lang="zh-cn">共用槽函数</span></a></li>
<li class="level1"><a href="#signals"><span lang="zh-cn">信号</span></a></li>
<li class="level1"><a href="#static-public-members"><span lang="zh-cn">静态公用成员</span></a></li>
<li class="level1"><a href="#reimplemented-protected-functions">
<span lang="zh-cn">重新实现的保护函数</span></a></li>
<li class="level1"><a href="#related-non-members"><span lang="zh-cn">相关的非成员</span></a></li>
<li class="level1"><a href="#macros"><span lang="zh-cn">宏</span></a></li>
<li class="level1"><a href="#details"><span lang="zh-cn">详细信息</span></a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">QQmlEngine <span lang="zh-cn">类</span></h1>
<!-- $$$QQmlEngine-brief -->
<p><a href="qqmlengine.html">QmlEngine</a>类提供了一个实例化QML组件的环境。 <a href="#details">
<span lang="zh-cn">更多</span>...</a></p>
<!-- @@@QQmlEngine -->
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> <span lang="zh-cn">头文件：</span></td><td class="memItemRight bottomAlign">   <span class="preprocessor">#include &lt;QQmlEngine&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += qml</td></tr><tr><td class="memItemLeft rightAlign topAlign"> 
	<span lang="zh-cn">何时引入</span>:</td><td class="memItemRight bottomAlign">  Qt 5.0</td></tr><tr><td class="memItemLeft rightAlign topAlign"> 
		<span lang="zh-cn">继承自</span>:</td><td class="memItemRight bottomAlign"> <a href="qjsengine.html">QJSEngine</a></td></tr><tr><td class="memItemLeft rightAlign topAlign"> 
		<span lang="zh-cn">被继承</span>:</td><td class="memItemRight bottomAlign"> <p><a href="qqmlapplicationengine.html">QQmlApplicationEngine</a></p>
</td></tr></table></div><ul>
<li><a href="qqmlengine-members.html"><span lang="zh-cn">所有成员的列表，包括继承成员</span></a></li>
<li><a href="qqmlengine-obsolete.html"><span lang="zh-cn">废弃的成员</span></a></li>
</ul>
<a name="public-types"></a>
<h2 id="public-types">Public Types</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#ObjectOwnership-enum">ObjectOwnership</a></b> { CppOwnership, JavaScriptOwnership }</td></tr>
</table></div>
<a name="properties"></a>
<h2 id="properties"><span lang="zh-cn">属性</span></h2>
<ul>
<li class="fn"><b><a href="qqmlengine.html#offlineStoragePath-prop">offlineStoragePath</a></b> : QString</li>
</ul>
<ul>
<li class="fn"><span lang="zh-cn">从</span><a href="../qtcore/qobject.html#properties">QObject</a><span lang="zh-cn"> 
继承了一个属性</span></li>
</ul>
<a name="public-functions"></a>
<h2 id="public-functions"><span lang="zh-cn">公用函数</span></h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#QQmlEngine">QQmlEngine</a></b>(QObject *<i>parent</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#dtor.QQmlEngine">~QQmlEngine</a></b>() override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#addImageProvider">addImageProvider</a></b>(const QString &amp;<i>providerId</i>, QQmlImageProviderBase *<i>provider</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#addImportPath">addImportPath</a></b>(const QString &amp;<i>path</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#addPluginPath">addPluginPath</a></b>(const QString &amp;<i>path</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QUrl </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#baseUrl">baseUrl</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#clearComponentCache">clearComponentCache</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQmlImageProviderBase *</td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#imageProvider">imageProvider</a></b>(const QString &amp;<i>providerId</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QStringList </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#importPathList">importPathList</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#importPlugin">importPlugin</a></b>(const QString &amp;<i>filePath</i>, const QString &amp;<i>uri</i>, QList&lt;QQmlError&gt; *<i>errors</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQmlIncubationController *</td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#incubationController">incubationController</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QNetworkAccessManager *</td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#networkAccessManager">networkAccessManager</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQmlNetworkAccessManagerFactory *</td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#networkAccessManagerFactory">networkAccessManagerFactory</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#offlineStorageDatabaseFilePath">offlineStorageDatabaseFilePath</a></b>(const QString &amp;<i>databaseName</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#offlineStoragePath-prop">offlineStoragePath</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#outputWarningsToStandardError">outputWarningsToStandardError</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QStringList </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#pluginPathList">pluginPathList</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#removeImageProvider">removeImageProvider</a></b>(const QString &amp;<i>providerId</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQmlContext *</td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#rootContext">rootContext</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#setBaseUrl">setBaseUrl</a></b>(const QUrl &amp;<i>url</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#setImportPathList">setImportPathList</a></b>(const QStringList &amp;<i>paths</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#setIncubationController">setIncubationController</a></b>(QQmlIncubationController *<i>controller</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#setNetworkAccessManagerFactory">setNetworkAccessManagerFactory</a></b>(QQmlNetworkAccessManagerFactory *<i>factory</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#offlineStoragePath-prop">setOfflineStoragePath</a></b>(const QString &amp;<i>dir</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#setOutputWarningsToStandardError">setOutputWarningsToStandardError</a></b>(bool <i>enabled</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#setPluginPathList">setPluginPathList</a></b>(const QStringList &amp;<i>paths</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> T </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#singletonInstance">singletonInstance</a></b>(int <i>qmlTypeId</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#trimComponentCache">trimComponentCache</a></b>()</td></tr>
</table></div>
<ul>
<li class="fn"><span lang="zh-cn">&nbsp;从<a href="qjsengine.html#public-functions">QJSEngine</a>继承了15个公共函数</span></li>
<li class="fn"><span lang="zh-cn">从<a href="../qtcore/qobject.html#public-functions">QObject</a>继承了31个公共函数</span></li>
</ul>
<a name="public-slots"></a>
<h2 id="public-slots"><span lang="zh-cn">公用槽函数</span></h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#retranslate">retranslate</a></b>()</td></tr>
</table></div>
<ul>
<li class="fn"><span lang="zh-cn">从<a href="../qtcore/qobject.html#public-slots">QObject</a>继承1个公用槽函数</span></li>
</ul>
<a name="signals"></a>
<h2 id="signals"><span lang="zh-cn">信号</span></h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#exit">exit</a></b>(int <i>retCode</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#quit">quit</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#warnings">warnings</a></b>(const QList&lt;QQmlError&gt; &amp;<i>warnings</i>)</td></tr>
</table></div>
<ul>
<li class="fn"><span lang="zh-cn">从<a href="../qtcore/qobject.html#signals">QObject</a>继承2个信号</span></li>
</ul>
<a name="static-public-members"></a>
	<h2 id="static-public-members">静态公<span lang="zh-cn">用</span>成员</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> QQmlContext *</td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#contextForObject">contextForObject</a></b>(const QObject *<i>object</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQmlEngine::ObjectOwnership </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#objectOwnership">objectOwnership</a></b>(QObject *<i>object</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#setContextForObject">setContextForObject</a></b>(QObject *<i>object</i>, QQmlContext *<i>context</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#setObjectOwnership">setObjectOwnership</a></b>(QObject *<i>object</i>, QQmlEngine::ObjectOwnership <i>ownership</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QMetaObject </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#staticMetaObject-var">staticMetaObject</a></b></td></tr>
</table></div>
<ul>
<li class="fn"><span lang="zh-cn">从<a href="../qtcore/qobject.html#static-public-members">QObject</a>继承的9个静态公用成员</span></li>
</ul>
<a name="reimplemented-protected-functions"></a>
<h2 id="reimplemented-protected-functions">重新实现<span lang="zh-cn">的</span>保护<span lang="zh-cn">函数</span></h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#event">event</a></b>(QEvent *<i>e</i>) override</td></tr>
</table></div>
<ul>
<li class="fn"><span lang="zh-cn">&nbsp;9个受保护的函数继承自<a href="../qtcore/qobject.html#protected-functions">QObject</a></span></li>
</ul>
<a name="related-non-members"></a>
<h2 id="related-non-members">Related Non-Members</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> QObject *</td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#qmlAttachedPropertiesObject">qmlAttachedPropertiesObject</a></b>(const QObject *<i>attachee</i>, bool <i>create</i> = ...)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#qmlClearTypeRegistrations">qmlClearTypeRegistrations</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQmlContext *</td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#qmlContext">qmlContext</a></b>(const QObject *<i>object</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQmlInfo </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#qmlDebug">qmlDebug</a></b>(const QObject *<i>object</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQmlEngine *</td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#qmlEngine">qmlEngine</a></b>(const QObject *<i>object</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQmlInfo </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#qmlInfo">qmlInfo</a></b>(const QObject *<i>object</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#qmlProtectModule">qmlProtectModule</a></b>(const char *<i>uri</i>, int <i>majVersion</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#qmlRegisterExtendedType">qmlRegisterExtendedType</a></b>(const char *<i>uri</i>, int <i>versionMajor</i>, int <i>versionMinor</i>, const char *<i>qmlName</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#qmlRegisterExtendedUncreatableType">qmlRegisterExtendedUncreatableType</a></b>(const char *<i>uri</i>, int <i>versionMajor</i>, int <i>versionMinor</i>, const char *<i>qmlName</i>, const QString &amp;<i>reason</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#qmlRegisterInterface">qmlRegisterInterface</a></b>(const char *<i>typeName</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#qmlRegisterModule">qmlRegisterModule</a></b>(const char *<i>uri</i>, int <i>versionMajor</i>, int <i>versionMinor</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#qmlRegisterRevision">qmlRegisterRevision</a></b>(const char *<i>uri</i>, int <i>versionMajor</i>, int <i>versionMinor</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#qmlRegisterSingletonType">qmlRegisterSingletonType</a></b>(const char *<i>uri</i>, int <i>versionMajor</i>, int <i>versionMinor</i>, const char *<i>typeName</i>, QJSValue (*)(QQmlEngine *, QJSEngine *) <i>callback</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#qmlRegisterSingletonType-1">qmlRegisterSingletonType</a></b>(const char *<i>uri</i>, int <i>versionMajor</i>, int <i>versionMinor</i>, const char *<i>typeName</i>, QObject *(*)(QQmlEngine *, QJSEngine *) <i>callback</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#qmlRegisterSingletonType-2">qmlRegisterSingletonType</a></b>(const QUrl &amp;<i>url</i>, const char *<i>uri</i>, int <i>versionMajor</i>, int <i>versionMinor</i>, const char *<i>qmlName</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#qmlRegisterType">qmlRegisterType</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#qmlRegisterType">qmlRegisterType</a></b>(const char *<i>uri</i>, int <i>versionMajor</i>, int <i>versionMinor</i>, const char *<i>qmlName</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#qmlRegisterType-2">qmlRegisterType</a></b>(const QUrl &amp;<i>url</i>, const char *<i>uri</i>, int <i>versionMajor</i>, int <i>versionMinor</i>, const char *<i>qmlName</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#qmlRegisterTypeNotAvailable">qmlRegisterTypeNotAvailable</a></b>(const char *<i>uri</i>, int <i>versionMajor</i>, int <i>versionMinor</i>, const char *<i>qmlName</i>, const QString &amp;<i>message</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#qmlRegisterUncreatableMetaObject">qmlRegisterUncreatableMetaObject</a></b>(const QMetaObject &amp;<i>staticMetaObject</i>, const char *<i>uri</i>, int <i>versionMajor</i>, int <i>versionMinor</i>, const char *<i>qmlName</i>, const QString &amp;<i>reason</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#qmlRegisterUncreatableType">qmlRegisterUncreatableType</a></b>(const char *<i>uri</i>, int <i>versionMajor</i>, int <i>versionMinor</i>, const char *<i>qmlName</i>, const QString &amp;<i>message</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#qmlTypeId">qmlTypeId</a></b>(const char *<i>uri</i>, int <i>versionMajor</i>, int <i>versionMinor</i>, const char *<i>qmlName</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQmlInfo </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#qmlWarning">qmlWarning</a></b>(const QObject *<i>object</i>)</td></tr>
</table></div>
<a name="macros"></a>
<h2 id="macros"><span lang="zh-cn">宏</span></h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#QML_DECLARE_TYPE">QML_DECLARE_TYPE</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qqmlengine.html#QML_DECLARE_TYPEINFO">QML_DECLARE_TYPEINFO</a></b>(<i>Type</i>, <i>Flags</i>)</td></tr>
</table></div>
<a name="details"></a>
<!-- $$$QQmlEngine-description -->
<div class="descr">
<h2 id="details"><span lang="zh-cn">详细信息</span></h2>
<p>&nbsp;<a href="qqmlengine.html">QQmlEngine</a>类提供了一个实例化QML组件的环境。</p>
<p><span lang="zh-cn">每个QML组件都在<a href="qqmlcontext.html">QQmlContext</a>中实例化。<a href="qqmlcontext.html">QQmlContext</a>对于将数据传递给QML组件非常重要。在QML中，上下文是分层排列的，这个层次由<a href="qqmlengine.html">QQmlEngine</a>管理。</span></p>
<p>在创建任何QML组件之前，应用程序必须创建一个<a href="qqmlengine.html">QQmlEngine</a>以获得对QML上下文的访问权。<br>
下面的示例演示如何创建一个简单的Text项。</p>
<pre class="cpp">

  <span class="type"><a href="qqmlengine.html#QQmlEngine">QQmlEngine</a></span> engine;
  <span class="type"><a href="qqmlcomponent.html">QQmlComponent</a></span> component(<span class="operator">&amp;</span>engine);
  component<span class="operator">.</span>setData(<span class="string">&quot;import QtQuick 2.0\nText { text: \&quot;Hello world!\&quot; }&quot;</span><span class="operator">,</span> <span class="type"><a href="../qtcore/qurl.html">QUrl</a></span>());
  <span class="type"><a href="../qtquick/qquickitem.html">QQuickItem</a></span> <span class="operator">*</span>item <span class="operator">=</span> qobject_cast<span class="operator">&lt;</span><span class="type"><a href="../qtquick/qquickitem.html">QQuickItem</a></span> <span class="operator">*</span><span class="operator">&gt;</span>(component<span class="operator">.</span>create());

  <span class="comment">//添加项目到视图等</span>
  <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>

</pre>
<p>In this case, the Text item will be created in the engine's .在本例中，Text项将在引擎的<a href="qqmlengine.html#rootContext">根上下文</a>中创建。</p>
</div>
<p><b><span lang="zh-cn">参考</span> </b><a href="qqmlcomponent.html">QQmlComponent</a>, <a href="qqmlcontext.html">QQmlContext</a>,
<span lang="zh-cn">以及</span> <a href="qtqml-javascript-qmlglobalobject.html">QML Global Object</a><span lang="zh-cn">。</span></p>
<!-- @@@QQmlEngine -->
<div class="types">
<h2><span lang="zh-cn">成员类型文档</span></h2>
<!-- $$$ObjectOwnership$$$CppOwnership$$$JavaScriptOwnership -->
<h3 class="fn" id="ObjectOwnership-enum"><a name="ObjectOwnership-enum"></a>enum QQmlEngine::<span class="name">ObjectOwnership</span></h3>
<p>objectowownership控制当相应的JavaScript对象被引擎垃圾回收时QML是否自动销毁QObject。<br>两种所有权选择是:</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">
	常数</th><th class="tblval"><span lang="zh-cn">值</span></th><th class="tbldscr">
	<span lang="zh-cn">描述</span></th></tr>
<tr><td class="topAlign"><code>QQmlEngine::CppOwnership</code></td><td class="topAlign tblval"><code>0</code></td><td class="topAlign">
	该对象属于C++代码，QML永远不会删除它。JavaScript destroy()方法不能用于这些对象。这个选项类似于<a href="../qtscript/qscriptengine.html#ValueOwnership-enum">QScriptEngine::QtOwnership</a>。</td></tr>
<tr><td class="topAlign"><code>QQmlEngine::JavaScriptOwnership</code></td><td class="topAlign tblval"><code>1</code></td><td class="topAlign">
	该对象属于JavaScript。当对象作为方法调用的返回值返回给QML时，如果没有剩下的JavaScript引用，并且没有<a href="../qtcore/qobject.html#parent">QObject::parent</a>()， 
	QML将跟踪它并删除它。一个<a href="qqmlengine.html">QQmlEngine</a>跟踪的对象将在该<a href="qqmlengine.html">QQmlEngine</a>的析构函数期间被删除。因此，如果删除其中一个引擎，那么来自两个不同引擎的JavaScriptOwnership 
	对象之间的JavaScript引用将无效。该选项类似于<a href="../qtscript/qscriptengine.html#ValueOwnership-enum">QScriptEngine::ScriptOwnership</a>。</td></tr>
</table></div>
<p>
通常，应用程序不需要显式地设置对象的所有权。QML使用启发式设置默认所有权。默认情况下，由QML创建的对象具有JavaScriptOwnership。例外的是通过调用<a href="qqmlcomponent.html#create">QQmlComponent::create</a>()或<a href="qqmlcomponent.html#beginCreate">QQmlComponent::beginCreate</a>()创建的根对象，它们默认具有CppOwnership 
。这些根级对象的所有权被认为已经转移给了C++调用者。</p>
<p>没有由QML创建的对象默认具有CppOwnership 
。例外C++方法调用返回的对象;他们的所有权将被设置为JavaScriptOwnership。这只适用于<a href="../qtcore/qobject.html#Q_INVOKABLE">Q_INVOKABLE</a>方法或槽的显式调用，而不适用于属性getter调用。</p>
<p>调用<a href="qqmlengine.html#setObjectOwnership">setObjectOwnership</a>()将覆盖QML使用的默认所有权启发式。</p>
<!-- @@@ObjectOwnership -->
</div>
<div class="prop">
<h2>属性文档</h2>
<!-- $$$offlineStoragePath-prop$$$offlineStoragePath$$$setOfflineStoragePathconstQString& -->
<h3 class="fn" id="offlineStoragePath-prop"><a name="offlineStoragePath-prop"></a><span class="name">offlineStoragePath</span> : <span class="type"><a href="../qtcore/qstring.html">QString</a></span></h3>
<p>此属性保存用于存储脱机用户数据的目录</p>
<p>返回存放SQL和其他脱机存储的目录。</p>
<p>使用openDatabase()创建的SQL数据库存储在这里。</p>
<p>默认是平台标准用户应用程序数据目录中的QML/OfflineStorage。</p>
<p>注意，该路径当前可能不存在于文件系统中，因此希望在此位置创建新文件的调用者应该首先创建它—请参阅<a href="../qtcore/qdir.html#mkpath">QDir::mkpath</a>()。</p>
<p><b>访问<span lang="zh-cn">函数</span>:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> QString </td><td class="memItemRight bottomAlign"><span class="name"><b>offlineStoragePath</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setOfflineStoragePath</b></span>(const QString &amp;<i>dir</i>)</td></tr>
</table></div>
<!-- @@@offlineStoragePath -->
</div>
<div class="func">
<h2>成员函数的文档</h2>
<!-- $$$QQmlEngine[overload1]$$$QQmlEngineQObject* -->
<h3 class="fn" id="QQmlEngine"><a name="QQmlEngine"></a>QQmlEngine::<span class="name">QQmlEngine</span>(<span class="type"><a href="../qtcore/qobject.html#QObject">QObject</a></span> *<i>parent</i> = nullptr)</h3>
<p>用给定的<i>parent<span lang="zh-cn">（</span></i>父对象<span lang="zh-cn">）</span>创建一个新的<a href="qqmlengine.html">QQmlEngine</a>。</p>
<!-- @@@QQmlEngine -->
<!-- $$$~QQmlEngine[overload1]$$$~QQmlEngine -->
<h3 class="fn" id="dtor.QQmlEngine"><a name="dtor.QQmlEngine"></a><code>[override virtual] </code>QQmlEngine::<span class="name">~QQmlEngine</span>()</h3>
<p><span lang="zh-cn">销毁</span> <a href="qqmlengine.html">QQmlEngine</a>.</p>
<p>在这个引擎上创建的任何<a href="qqmlcontext.html">QQmlContext</a>都将无效，但不会被销毁(除非它们是<a href="qqmlengine.html">QQmlEngine</a>对象的父对象)。</p>
<p>关于清理JS引擎的详细信息，请参阅<a href="qjsengine.html">QJSEngine</a>文档。</p>
<!-- @@@~QQmlEngine -->
<!-- $$$addImageProvider[overload1]$$$addImageProviderconstQString&QQmlImageProviderBase* -->
<h3 class="fn" id="addImageProvider"><a name="addImageProvider"></a><span class="type">void</span> QQmlEngine::<span class="name">addImageProvider</span>(const <span class="type"><a href="../qtcore/qstring.html">QString</a></span> &amp;<i>providerId</i>, <span class="type"><a href="qqmlimageproviderbase.html">QQmlImageProviderBase</a></span> *<i>provider</i>)</h3>
<p><i>用主机providerId设置通过image: url方案请求的图像的提供程序。<a href="qqmlengine.html">QQmlEngine</a>获得了提供商的所有权。</i>.</p>
<p>图像提供程序支持像素映射和线程化图像请求。有关实现和使用图像提供程序的详细信息，请参阅<a href="../qtquick/qquickimageprovider.html">QQuickImageProvider</a>文档。</p>
<p>在加载任何QML源文件之前，应该将所有必需的图像提供程序添加到引擎中。</p>
<p><b><span lang="zh-cn">请参考</span> </b><a href="qqmlengine.html#removeImageProvider">removeImageProvider</a>(), <a href="../qtquick/qquickimageprovider.html">QQuickImageProvider</a>
<span lang="zh-cn">和</span> <a href="qqmlimageproviderbase.html">QQmlImageProviderBase</a>.</p>
<!-- @@@addImageProvider -->
<!-- $$$addImportPath[overload1]$$$addImportPathconstQString& -->
<h3 class="fn" id="addImportPath"><a name="addImportPath"></a><span class="type">void</span> QQmlEngine::<span class="name">addImportPath</span>(const <span class="type"><a href="../qtcore/qstring.html">QString</a></span> &amp;<i>path</i>)</h3>
<p>添加path作为一个目录，引擎在该目录中搜索基于url的目录结构中安装的模块。</p>
<p>路径<span lang="zh-cn">（<i>path</i> ）</span>可以是本地文件系统目录、<a href="../qtcore/resources.html">Qt资源</a> 
路径(:/imports)、<a href="../qtcore/resources.html">Qt资源</a><span lang="zh-cn">
</span>url (qrc:/imports)或url。</p>
<p>在将路径<span lang="zh-cn">（<i>path</i> ）</span>添加到导入路径列表之前，路径将被转换为规范形式。</p>
<p>新添加的路径将在<a href="qqmlengine.html#importPathList">importPathList</a>()中的第一个。</p>
<p><b><span lang="zh-cn">请参考</span> </b><a href="qqmlengine.html#setImportPathList">setImportPathList</a>()
<span lang="zh-cn">和</span> <a href="qtqml-modules-topic.html">QML 
<span lang="zh-cn">模块</span></a><span lang="zh-cn">。</span></p>
<!-- @@@addImportPath -->
<!-- $$$addPluginPath[overload1]$$$addPluginPathconstQString& -->
<h3 class="fn" id="addPluginPath"><a name="addPluginPath"></a><span class="type">void</span> QQmlEngine::<span class="name">addPluginPath</span>(const <span class="type"><a href="../qtcore/qstring.html">QString</a></span> &amp;<i>path</i>)</h3>
<p>添加路径作为一个目录，引擎在该目录中搜索导入模块的本地插件(在qmldir文件中引用)。</p>
<p>默认情况下，列表只包含qmldir文件本身的目录中的引擎搜索。</p>
<p>新添加的路径将在<a href="qqmlengine.html#pluginPathList">pluginPathList</a>()中的第一个。</p>
<p><b><span lang="zh-cn">请参考</span> </b><a href="qqmlengine.html#setPluginPathList">setPluginPathList</a>()<span lang="zh-cn">。</span></p>
<!-- @@@addPluginPath -->
<!-- $$$baseUrl[overload1]$$$baseUrl -->
<h3 class="fn" id="baseUrl"><a name="baseUrl"></a><span class="type"><a href="../qtcore/qurl.html">QUrl</a></span> QQmlEngine::<span class="name">baseUrl</span>() const</h3>
<p>返回此引擎的基URL。基URL仅用于在将相对URL传递给<a href="qqmlcomponent.html">QQmlComponent</a>构造函数时解析组件。</p>
<p>如果未显式设置基URL，此方法将返回应用程序的当前工作目录。</p>
<p><b><span lang="zh-cn">请参考</span> </b><a href="qqmlengine.html#setBaseUrl">setBaseUrl</a>().</p>
<!-- @@@baseUrl -->
<!-- $$$clearComponentCache[overload1]$$$clearComponentCache -->
<h3 class="fn" id="clearComponentCache"><a name="clearComponentCache"></a><span class="type">void</span> QQmlEngine::<span class="name">clearComponentCache</span>()</h3>
<p>清除引擎的内部组件缓存。</p>
<p>此函数将销毁之前由引擎加载的所有组件的属性元数据。所有以前加载的组件和从这些组件创建的所有现有对象的属性绑定将停止工作。</p>
<p>该函数将引擎返回到不包含任何已加载组件数据的状态。这对于重新加载前一个组件集的较小子集或加载前一个组件的新版本可能很有用。</p>
<p>清除组件缓存后，必须先加载组件，然后才能创建任何新对象。</p>
<p><b><span lang="zh-cn">参考</span> </b><a href="qqmlengine.html#trimComponentCache">trimComponentCache</a>()<span lang="zh-cn">。</span></p>
<!-- @@@clearComponentCache -->
<!-- $$$contextForObject[overload1]$$$contextForObjectconstQObject* -->
<h3 class="fn" id="contextForObject"><a name="contextForObject"></a><code>[static] </code><span class="type"><a href="qqmlcontext.html">QQmlContext</a></span> *QQmlEngine::<span class="name">contextForObject</span>(const <span class="type"><a href="../qtcore/qobject.html#QObject">QObject</a></span> *<i>object</i>)</h3>
<p>返回对象的<a href="qqmlcontext.html">QQmlContext</a>，如果没有设置上下文，则返回0。</p>
<p>当<a href="qqmlengine.html">QQmlEngine</a>实例化一个<a href="../qtcore/qobject.html">QObject</a>时，上下文将自动设置。</p>
<p><b><span lang="zh-cn">请参考</span> </b><a href="qqmlengine.html#setContextForObject">setContextForObject</a>(), <a href="qqmlengine.html#qmlContext">qmlContext</a>(),
<span lang="zh-cn">和</span> <a href="qqmlengine.html#qmlEngine">qmlEngine</a>()<span lang="zh-cn">。</span></p>
<!-- @@@contextForObject -->
<!-- $$$event[overload1]$$$eventQEvent* -->
<h3 class="fn" id="event"><a name="event"></a><code>[override virtual protected] </code><span class="type">bool</span> QQmlEngine::<span class="name">event</span>(<span class="type"><a href="../qtcore/qevent.html">QEvent</a></span> *<i>e</i>)</h3>
<p>Reimplemented from <a href="../qtcore/qobject.html#event">QObject::event</a>().</p>
<!-- @@@event -->
<!-- $$$exit[overload1]$$$exitint -->
<h3 class="fn" id="exit"><a name="exit"></a><code>[signal] </code><span class="type">void</span> QQmlEngine::<span class="name">exit</span>(<span class="type">int</span> <i>retCode</i>)</h3>
<p>当引擎加载的QML希望使用指定的返回码retCode退出事件循环时，将发出此信号。</p>
<p>这个函数是在Qt 5.8中引入的。</p>
<p><b><span lang="zh-cn">请参考</span> </b><a href="qqmlengine.html#quit">quit</a>()<span lang="zh-cn">。</span></p>
<!-- @@@exit -->
<!-- $$$imageProvider[overload1]$$$imageProviderconstQString& -->
<h3 class="fn" id="imageProvider"><a name="imageProvider"></a><span class="type"><a href="qqmlimageproviderbase.html">QQmlImageProviderBase</a></span> *QQmlEngine::<span class="name">imageProvider</span>(const <span class="type"><a href="../qtcore/qstring.html">QString</a></span> &amp;<i>providerId</i>) const</h3>
<p>如果找到，返回providerId的图像提供程序集;否则返回nullptr。</p>
<p><b>请参考 </b><a href="../qtquick/qquickimageprovider.html">QQuickImageProvider</a><span lang="zh-cn">。</span></p>
<!-- @@@imageProvider -->
<!-- $$$importPathList[overload1]$$$importPathList -->
<h3 class="fn" id="importPathList"><a name="importPathList"></a><span class="type"><a href="../qtcore/qstringlist.html">QStringList</a></span> QQmlEngine::<span class="name">importPathList</span>() const</h3>
<p>返回在基于url的目录结构中搜索已安装模块的目录列表。</p>
<p>
例如，如果路径中有/opt/MyApp/lib/imports，那么导入com.mycompany.Feature的QML将导致QQmlEngine在/opt/MyApp/lib/imports/com/mycompany/Feature/中查找该模块提供的组件。定义类型版本映射和可能的QML扩展插件需要一个qmldir文件。</p>
<p>默认情况下，列表包含应用程序可执行文件的目录、在<code>QML2_IMPORT_PATH</code> 环境变量中指定的路径，以及来自<a href="../qtcore/qlibraryinfo.html">QLibraryInfo</a>的内置<code>Qml2ImportsPath</code> 
。</p>
<p><b>请参考 </b><a href="qqmlengine.html#addImportPath">addImportPath</a>()
<span lang="zh-cn">和</span><a href="qqmlengine.html#setImportPathList">setImportPathList</a>()<span lang="zh-cn">。</span></p>
<!-- @@@importPathList -->
<!-- $$$importPlugin[overload1]$$$importPluginconstQString&constQString&QList<QQmlError>* -->
<h3 class="fn" id="importPlugin"><a name="importPlugin"></a><span class="type">bool</span> QQmlEngine::<span class="name">importPlugin</span>(const <span class="type"><a href="../qtcore/qstring.html">QString</a></span> &amp;<i>filePath</i>, const <span class="type"><a href="../qtcore/qstring.html">QString</a></span> &amp;<i>uri</i>, <span class="type"><a href="../qtcore/qlist.html">QList</a></span>&lt;<span class="type"><a href="qqmlerror.html">QQmlError</a></span>&gt; *<i>errors</i>)</h3>
<p>使用提供的uri导入名为filePath的插件。如果成功导入插件，返回true;否则返回false。</p>
<p>如果失败且非空，则错误列表将包含发生的所有错误。</p>
<p>该插件必须是一个Qt插件，它实现了<a href="qqmlextensionplugin.html">QQmlExtensionPlugin</a>接口。</p>
<!-- @@@importPlugin -->
<!-- $$$incubationController[overload1]$$$incubationController -->
<h3 class="fn" id="incubationController"><a name="incubationController"></a><span class="type"><a href="qqmlincubationcontroller.html">QQmlIncubationController</a></span> *QQmlEngine::<span class="name">incubationController</span>() const</h3>
<p>返回当前设置的孵化控制器，如果未设置控制器则返回0。</p>
<p><b>请参考 </b><a href="qqmlengine.html#setIncubationController">setIncubationController</a>()<span lang="zh-cn">。</span></p>
<!-- @@@incubationController -->
<!-- $$$networkAccessManager[overload1]$$$networkAccessManager -->
<h3 class="fn" id="networkAccessManager"><a name="networkAccessManager"></a><span class="type">QNetworkAccessManager</span> *QQmlEngine::<span class="name">networkAccessManager</span>() const</h3>
<p>返回一个通用的QNetworkAccessManager，它可以被该引擎实例化的任何QML类型使用。</p>
<p>如果已经设置了<a href="qqmlnetworkaccessmanagerfactory.html">QQmlNetworkAccessManagerFactory</a>，但还没有创建QNetworkAccessManager，则<a href="qqmlnetworkaccessmanagerfactory.html">QQmlNetworkAccessManagerFactory</a>将用于创建QNetworkAccessManager;否则，返回的QNetworkAccessManager将没有代理或缓存设置。</p>
<p><b>请参考 </b><a href="qqmlengine.html#setNetworkAccessManagerFactory">setNetworkAccessManagerFactory</a>()<span lang="zh-cn">。</span></p>
<!-- @@@networkAccessManager -->
<!-- $$$networkAccessManagerFactory[overload1]$$$networkAccessManagerFactory -->
<h3 class="fn" id="networkAccessManagerFactory"><a name="networkAccessManagerFactory"></a><span class="type"><a href="qqmlnetworkaccessmanagerfactory.html">QQmlNetworkAccessManagerFactory</a></span> *QQmlEngine::<span class="name">networkAccessManagerFactory</span>() const</h3>
<p>返回当前<a href="qqmlnetworkaccessmanagerfactory.html">QQmlNetworkAccessManagerFactory</a>。</p>
<p><b>请参考 </b><a href="qqmlengine.html#setNetworkAccessManagerFactory">setNetworkAccessManagerFactory</a>().</p>
<!-- @@@networkAccessManagerFactory -->
<!-- $$$objectOwnership[overload1]$$$objectOwnershipQObject* -->
<h3 class="fn" id="objectOwnership"><a name="objectOwnership"></a><code>[static] </code><span class="type"><a href="qqmlengine.html#ObjectOwnership-enum">QQmlEngine::ObjectOwnership</a></span> QQmlEngine::<span class="name">objectOwnership</span>(<span class="type"><a href="../qtcore/qobject.html#QObject">QObject</a></span> *<i>object</i>)</h3>
<p>返回对象的所有权。</p>
<p><b>请参考 </b><a href="qqmlengine.html#setObjectOwnership">setObjectOwnership</a>()<span lang="zh-cn">。</span></p>
<!-- @@@objectOwnership -->
<!-- $$$offlineStorageDatabaseFilePath[overload1]$$$offlineStorageDatabaseFilePathconstQString& -->
<h3 class="fn" id="offlineStorageDatabaseFilePath"><a name="offlineStorageDatabaseFilePath"></a><span class="type"><a href="../qtcore/qstring.html">QString</a></span> QQmlEngine::<span class="name">offlineStorageDatabaseFilePath</span>(const <span class="type"><a href="../qtcore/qstring.html">QString</a></span> &amp;<i>databaseName</i>) const</h3>
<p>返回标识符<i>databaseName</i> <span lang="zh-cn">（数据库名字）</span>的本地存储数据库所在的文件路径。</p>
<p>这个函数是在Qt 5.9中引入的。</p>
<p><b>请参考 </b><a href="../qtquick/qtquick-localstorage-qmlmodule.html#opendatabasesync">LocalStorage.openDatabaseSync</a>()<span lang="zh-cn">。</span></p>
<!-- @@@offlineStorageDatabaseFilePath -->
<!-- $$$outputWarningsToStandardError[overload1]$$$outputWarningsToStandardError -->
<h3 class="fn" id="outputWarningsToStandardError"><a name="outputWarningsToStandardError"></a><span class="type">bool</span> QQmlEngine::<span class="name">outputWarningsToStandardError</span>() const</h3>
<p>如果警告消息除了由<a href="qqmlengine.html#warnings">warnings</a>()信号发出外还将输出到stderr，则返回true，否则返回false。</p>
<p>默认值为true。</p>
<p><b>请参考 </b><a href="qqmlengine.html#setOutputWarningsToStandardError">setOutputWarningsToStandardError</a>()<span lang="zh-cn">。</span></p>
<!-- @@@outputWarningsToStandardError -->
<!-- $$$pluginPathList[overload1]$$$pluginPathList -->
<h3 class="fn" id="pluginPathList"><a name="pluginPathList"></a><span class="type"><a href="../qtcore/qstringlist.html">QStringList</a></span> QQmlEngine::<span class="name">pluginPathList</span>() const</h3>
<p>返回引擎为导入的模块(在qmldir文件中引用)搜索本地插件的目录列表。</p>
<p>当引擎加载的QML要退出时，将发出此信号。</p>
<p><b>请参考 </b><a href="qqmlengine.html#addPluginPath">addPluginPath</a>() and <a href="qqmlengine.html#setPluginPathList">setPluginPathList</a>()<span lang="zh-cn">。</span></p>
<!-- @@@pluginPathList -->
<!-- $$$quit[overload1]$$$quit -->
<h3 class="fn" id="quit"><a name="quit"></a><code>[signal] </code><span class="type">void</span> QQmlEngine::<span class="name">quit</span>()</h3>
<p>当引擎加载的QML要退出时，将发出此信号。</p>
<p><b>请参考 </b><a href="qqmlengine.html#exit">exit</a>()<span lang="zh-cn">。</span></p>
<!-- @@@quit -->
<!-- $$$removeImageProvider[overload1]$$$removeImageProviderconstQString& -->
<h3 class="fn" id="removeImageProvider"><a name="removeImageProvider"></a><span class="type">void</span> QQmlEngine::<span class="name">removeImageProvider</span>(const <span class="type"><a href="../qtcore/qstring.html">QString</a></span> &amp;<i>providerId</i>)</h3>
<p>删除<i>providerId</i>的图像提供程序。</p>
<p><b>请参考 </b><a href="qqmlengine.html#addImageProvider">addImageProvider</a>()
<span lang="zh-cn">和</span><a href="../qtquick/qquickimageprovider.html">QQuickImageProvider</a><span lang="zh-cn">。</span></p>
<!-- @@@removeImageProvider -->
<!-- $$$retranslate[overload1]$$$retranslate -->
<h3 class="fn" id="retranslate"><a name="retranslate"></a><code>[slot] </code><span class="type">void</span> QQmlEngine::<span class="name">retranslate</span>()</h3>
<p>刷新所有使用标记为翻译的字符串的绑定表达式。</p>
<p>使用<a href="../qtcore/qcoreapplication.html#installTranslator">QCoreApplication::installTranslator</a>安装新的翻译程序后调用此函数，以确保用户界面显示最新的翻译。</p>
<p><b>注意:</b>由于实现中的限制，该函数会刷新所有引擎的绑定，而不仅仅是那些使用标记为翻译的字符串的绑定。这可能会在未来的版本中得到优化。</p><p>
	这个函数是在Qt 5.10中引入的。</p>
<!-- @@@retranslate -->
<!-- $$$rootContext[overload1]$$$rootContext -->
<h3 class="fn" id="rootContext"><a name="rootContext"></a><span class="type"><a href="qqmlcontext.html">QQmlContext</a></span> *QQmlEngine::<span class="name">rootContext</span>() const</h3>
<p>返回引擎的根上下文。</p>
<p>根上下文由<a href="qqmlengine.html">QQmlEngine</a>自动创建。引擎实例化的所有QML组件实例都应该可以使用的数据应该放在根上下文中。</p>
<p>应该只对组件实例的子集可用的额外数据应该添加到根上下文的子上下文中。</p>
<!-- @@@rootContext -->
<!-- $$$setBaseUrl[overload1]$$$setBaseUrlconstQUrl& -->
<h3 class="fn" id="setBaseUrl"><a name="setBaseUrl"></a><span class="type">void</span> QQmlEngine::<span class="name">setBaseUrl</span>(const <span class="type"><a href="../qtcore/qurl.html">QUrl</a></span> &amp;<i>url</i>)</h3>
<p>将此引擎的基础URL设置为<i>url</i>。</p>
<p><b>请参考 </b><a href="qqmlengine.html#baseUrl">baseUrl</a>()<span lang="zh-cn">。</span></p>
<!-- @@@setBaseUrl -->
<!-- $$$setContextForObject[overload1]$$$setContextForObjectQObject*QQmlContext* -->
<h3 class="fn" id="setContextForObject"><a name="setContextForObject"></a><code>[static] </code><span class="type">void</span> QQmlEngine::<span class="name">setContextForObject</span>(<span class="type"><a href="../qtcore/qobject.html#QObject">QObject</a></span> *<i>object</i>, <span class="type"><a href="qqmlcontext.html">QQmlContext</a></span> *<i>context</i>)</h3>
<p>将<i>object</i> <span lang="zh-cn">(</span>对象<span lang="zh-cn">)</span>的<a href="qqmlcontext.html">QQmlContext</a>设置为<i>context<span lang="zh-cn">（上下文）</span></i>。如果<i>object</i> 
<span lang="zh-cn">（</span>对象<span lang="zh-cn">）</span>已经具有上下文，则输出警告，但上下文不会更改。</p>
<p>当<a href="qqmlengine.html">QQmlEngine</a>实例化一个<a href="../qtcore/qobject.html">QObject</a>时，上下文将自动设置。</p>
<p><b>请参考 </b><a href="qqmlengine.html#contextForObject">contextForObject</a>()<span lang="zh-cn">。</span></p>
<!-- @@@setContextForObject -->
<!-- $$$setImportPathList[overload1]$$$setImportPathListconstQStringList& -->
<h3 class="fn" id="setImportPathList"><a name="setImportPathList"></a><span class="type">void</span> QQmlEngine::<span class="name">setImportPathList</span>(const <span class="type"><a href="../qtcore/qstringlist.html">QStringList</a></span> &amp;<i>paths</i>)</h3>
<p>将<i>paths</i> <span lang="zh-cn">（</span>路径<span lang="zh-cn">）</span>设置为目录列表，引擎在其中搜索基于url的目录结构中安装的模块。</p>
<p>默认情况下，列表包含应用程序可执行文件的目录、在<code>QML2_IMPORT_PATH</code> 环境变量中指定的路径，以及来自<a href="../qtcore/qlibraryinfo.html">QLibraryInfo</a>的内置<code>Qml2ImportsPath</code> 
。</p>
<p><b>请参考 </b><a href="qqmlengine.html#importPathList">importPathList</a>()
<span lang="zh-cn">和</span><a href="qqmlengine.html#addImportPath">addImportPath</a>()<span lang="zh-cn">。</span></p>
<!-- @@@setImportPathList -->
<!-- $$$setIncubationController[overload1]$$$setIncubationControllerQQmlIncubationController* -->
<h3 class="fn" id="setIncubationController"><a name="setIncubationController"></a><span class="type">void</span> QQmlEngine::<span class="name">setIncubationController</span>(<span class="type"><a href="qqmlincubationcontroller.html">QQmlIncubationController</a></span> *<i>controller</i>)</h3>
<p>&nbsp;设置引擎的孵化<i>controller<span lang="zh-cn">（</span></i>控制器<span lang="zh-cn">）</span>。引擎只能有一个活动控制器，并且它不拥有它的所有权。</p>
<p><b>请参考 </b><a href="qqmlengine.html#incubationController">incubationController</a>()<span lang="zh-cn">。</span></p>
<!-- @@@setIncubationController -->
<!-- $$$setNetworkAccessManagerFactory[overload1]$$$setNetworkAccessManagerFactoryQQmlNetworkAccessManagerFactory* -->
<h3 class="fn" id="setNetworkAccessManagerFactory"><a name="setNetworkAccessManagerFactory"></a><span class="type">void</span> QQmlEngine::<span class="name">setNetworkAccessManagerFactory</span>(<span class="type"><a href="qqmlnetworkaccessmanagerfactory.html">QQmlNetworkAccessManagerFactory</a></span> *<i>factory</i>)</h3>
<p>&nbsp;QNetworkAccessManager(s).设置用于创建QNetworkAccessManager的<i>factory</i> 
<span lang="zh-cn">（</span>工厂<span lang="zh-cn">）</span>。</p>
<p>
QML使用QNetworkAccessManager进行所有网络访问。通过实现工厂，可以创建具有专门缓存、代理和cookie支持的自定义QNetworkAccessManager。</p>
<p>在启动发动机之前必须设置好工厂。</p>
<p><b><span lang="zh-cn">注意</span>:</b><a href="qqmlengine.html">QQmlEngine</a>不拥有该工厂的所有权。</p><p><b>请参考 </b><a href="qqmlengine.html#networkAccessManagerFactory">networkAccessManagerFactory</a>()<span lang="zh-cn">。</span></p>
<!-- @@@setNetworkAccessManagerFactory -->
<!-- $$$setObjectOwnership[overload1]$$$setObjectOwnershipQObject*QQmlEngine::ObjectOwnership -->
<h3 class="fn" id="setObjectOwnership"><a name="setObjectOwnership"></a><code>[static] </code><span class="type">void</span> QQmlEngine::<span class="name">setObjectOwnership</span>(<span class="type"><a href="../qtcore/qobject.html#QObject">QObject</a></span> *<i>object</i>, <span class="type"><a href="qqmlengine.html#ObjectOwnership-enum">QQmlEngine::ObjectOwnership</a></span> <i>ownership</i>)</h3>
<p>设置<i>object<span lang="zh-cn">（</span></i>对象<span lang="zh-cn">）</span>的<i>ownership</i> 
<span lang="zh-cn">（</span>所有权<span lang="zh-cn">）</span>。</p>
<p><b>请参考 </b><a href="qqmlengine.html#objectOwnership">objectOwnership</a>()<span lang="zh-cn">。</span></p>
<!-- @@@setObjectOwnership -->
<!-- $$$setOutputWarningsToStandardError[overload1]$$$setOutputWarningsToStandardErrorbool -->
<h3 class="fn" id="setOutputWarningsToStandardError"><a name="setOutputWarningsToStandardError"></a><span class="type">void</span> QQmlEngine::<span class="name">setOutputWarningsToStandardError</span>(<span class="type">bool</span> <i>enabled</i>)</h3>
<p>设置是否将警告消息输出到stderr为启用。</p>
<p>如果<i>enabled</i> 为true, QML生成的任何警告消息都将输出到stderr，并由<a href="qqmlengine.html#warnings">warnings</a>()信号发出。如果<i>enabled</i> 
为false，则只会发出<a href="qqmlengine.html#warnings">warnings</a>()信号。这允许应用程序自己处理警告输出。</p>
<p>默认值为true。</p>
<p><b>请参考 </b><a href="qqmlengine.html#outputWarningsToStandardError">outputWarningsToStandardError</a>()<span lang="zh-cn">。</span></p>
<!-- @@@setOutputWarningsToStandardError -->
<!-- $$$setPluginPathList[overload1]$$$setPluginPathListconstQStringList& -->
<h3 class="fn" id="setPluginPathList"><a name="setPluginPathList"></a><span class="type">void</span> QQmlEngine::<span class="name">setPluginPathList</span>(const <span class="type"><a href="../qtcore/qstringlist.html">QStringList</a></span> &amp;<i>paths</i>)</h3>
<p>将引擎给导入模块(在qmldir文件中引用)搜索本地插件的目录列表设置为<i>paths<span lang="zh-cn">（</span></i>路径<span lang="zh-cn">）</span>。</p>
<p>默认情况下，列表只包含<span lang="zh-cn">，或者说</span>引擎在qmldir文件本身的目录中搜索。</p>
<p><b>请参考 </b><a href="qqmlengine.html#pluginPathList">pluginPathList</a>()
<span lang="zh-cn">和</span><a href="qqmlengine.html#addPluginPath">addPluginPath</a>()<span lang="zh-cn">。</span></p>
<!-- @@@setPluginPathList -->
<!-- $$$singletonInstance[overload1]$$$singletonInstanceint -->
<h3 class="fn" id="singletonInstance"><a name="singletonInstance"></a><span class="type">T</span> QQmlEngine::<span class="name">singletonInstance</span>(<span class="type">int</span> <i>qmlTypeId</i>)</h3>
<p>返回在<i>qmlTypeId</i>下注册的单例类型的实例。</p>
<p>模板参数<i>T</i> 可以是<a href="qjsvalue.html">QJSValue</a>，也可以是指向<a href="../qtcore/qobject.html">QObject</a>派生类型的指针，这取决于如何注册单例对象。如果还没有创建<i>T</i> 
的实例，那么现在就创建它。如果qmlTypeId不表示有效的单例类型，则返回一个默认构造的<a href="qjsvalue.html">QJSValue</a>或一个<code>nullptr</code> 
。</p>
<p><a href="../qtcore/qobject.html">QObject</a>* example:</p>
<pre class="cpp">

  <span class="keyword">class</span> MySingleton : <span class="keyword">public</span> <span class="type"><a href="../qtcore/qobject.html#QObject">QObject</a></span> {
    Q_OBJECT
    <span class="keyword">static</span> <span class="type">int</span> typeId;
    <span class="comment">// ...</span>
  };

  <span class="comment">// Register with QObject* callback</span>
  MySingleton<span class="operator">::</span>typeId <span class="operator">=</span> qmlRegisterSingletonType<span class="operator">&lt;</span>MySingleton<span class="operator">&gt;</span>(<span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>);

  <span class="comment">// Retrieve as QObject*</span>
  <span class="type"><a href="qqmlengine.html#QQmlEngine">QQmlEngine</a></span> engine;
  MySingleton<span class="operator">*</span> instance <span class="operator">=</span> engine<span class="operator">.</span>singletonInstance<span class="operator">&lt;</span>MySingleton<span class="operator">*</span><span class="operator">&gt;</span>(MySingleton<span class="operator">::</span>typeId);

</pre>
<p><a href="qjsvalue.html">QJSValue</a> <span lang="zh-cn">例子：</span></p>
<pre class="cpp">

  <span class="comment">// Register with QJSValue callback</span>
  <span class="type">int</span> typeId <span class="operator">=</span> qmlRegisterSingletonType(<span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>);

  <span class="comment">// Retrieve as QJSValue</span>
  <span class="type"><a href="qqmlengine.html#QQmlEngine">QQmlEngine</a></span> engine;
  <span class="type"><a href="qjsvalue.html">QJSValue</a></span> instance <span class="operator">=</span> engine<span class="operator">.</span>singletonInstance<span class="operator">&lt;</span><span class="type"><a href="qjsvalue.html">QJSValue</a></span><span class="operator">&gt;</span>(typeId);

</pre>
<p>建议在注册期间存储QML类型id，例如作为单例类的静态成员。否则，必须在运行时执行开销很大的<a href="qqmlengine.html#qmlTypeId">qmlTypeId</a>()查找。</p>
<p>这个函数是在Qt 5.12中引入的。</p>
<p><b>请参考 </b><a href="qqmlengine.html#qmlRegisterSingletonType">qmlRegisterSingletonType</a>()
<span lang="zh-cn">和</span> <a href="qqmlengine.html#qmlTypeId">qmlTypeId</a>()<span lang="zh-cn">。</span></p>
<!-- @@@singletonInstance -->
<!-- $$$trimComponentCache[overload1]$$$trimComponentCache -->
<h3 class="fn" id="trimComponentCache"><a name="trimComponentCache"></a><span class="type">void</span> QQmlEngine::<span class="name">trimComponentCache</span>()</h3>
<p>调整引擎的内部组件缓存。</p>
<p>此函数将销毁当前未使用的已加载组件的属性元数据。</p>
<p>如果组件本身存在任何现有的实例，使用该组件的其他组件的任何实例，或由这些组件实例化的任何对象，则该组件被认为在使用中。</p>
<p><b>请参考 </b><a href="qqmlengine.html#clearComponentCache">clearComponentCache</a>()<span lang="zh-cn">。</span></p>
<!-- @@@trimComponentCache -->
<!-- $$$warnings[overload1]$$$warningsconstQList<QQmlError>& -->
<h3 class="fn" id="warnings"><a name="warnings"></a><code>[signal] </code><span class="type">void</span> QQmlEngine::<span class="name">warnings</span>(const <span class="type"><a href="../qtcore/qlist.html">QList</a></span>&lt;<span class="type"><a href="qqmlerror.html">QQmlError</a></span>&gt; &amp;<i>warnings</i>)</h3>
<p>当QML生成警告消息时将发出此信号。</p>
<!-- @@@warnings -->
</div>
<div class="relnonmem">
<h2>相关的非成员</h2>
<!-- $$$qmlAttachedPropertiesObject[overload1]$$$qmlAttachedPropertiesObjectconstQObject*bool -->
<h3 class="fn" id="qmlAttachedPropertiesObject"><a name="qmlAttachedPropertiesObject"></a><span class="type"><a href="../qtcore/qobject.html#QObject">QObject</a></span> *<span class="name">qmlAttachedPropertiesObject</span>(const <span class="type"><a href="../qtcore/qobject.html#QObject">QObject</a></span> *<i>attachee</i>, <span class="type">bool</span> <i>create</i> = ...)</h3>
<p>这个模板函数的形式是:</p>
<pre class="cpp">

  <span class="keyword">template</span><span class="operator">&lt;</span><span class="keyword">typename</span> T<span class="operator">&gt;</span> <span class="type"><a href="../qtcore/qobject.html">QObject</a></span> <span class="operator">*</span>qmlAttachedPropertiesObject(<span class="keyword">const</span> <span class="type"><a href="../qtcore/qobject.html">QObject</a></span> <span class="operator">*</span>attachee<span class="operator">,</span> bool create <span class="operator">=</span> <span class="keyword">true</span>)

</pre>
<p>这将返回已由附加类型<i>T</i>附加到指定附加项的附加对象实例。</p>
<p>如果create为true，且类型<i>T</i>是有效的附加类型，则将创建并返回一个新的附加对象实例。</p>
<p>如果类型<i>T</i>不是有效的附加类型，或者如果create为false且之前没有为附加创建任何附加对象实例，则返回0。</p>
<p><b>请参考 </b><a href="qtqml-cppintegration-definetypes.html#providing-attached-properties">Providing Attached Properties</a><span lang="zh-cn">。</span></p>
<!-- @@@qmlAttachedPropertiesObject -->
<!-- $$$qmlClearTypeRegistrations[overload1]$$$qmlClearTypeRegistrations -->
<h3 class="fn" id="qmlClearTypeRegistrations"><a name="qmlClearTypeRegistrations"></a><span class="type">void</span> <span class="name">qmlClearTypeRegistrations</span>()</h3>
<p>清除所有存储的类型注册，例如使用<a href="qqmlengine.html#qmlRegisterType">qmlRegisterType</a>()生成的注册。</p>
<p>QQmlEngine存在时不要调用此函数，否则行为将未定义。在调用该函数之前，必须删除任何现有的QQmlEngines。此函数仅影响应用程序全局缓存。删除<a href="qqmlengine.html">QQmlEngine</a>，将清除与该引擎相关的所有缓存数据。</p>
<!-- @@@qmlClearTypeRegistrations -->
<!-- $$$qmlContext[overload1]$$$qmlContextconstQObject* -->
<h3 class="fn" id="qmlContext"><a name="qmlContext"></a><span class="type"><a href="qqmlcontext.html">QQmlContext</a></span> *<span class="name">qmlContext</span>(const <span class="type"><a href="../qtcore/qobject.html#QObject">QObject</a></span> *<i>object</i>)</h3>
<p>返回与对象关联的<a href="qqmlcontext.html">QQmlContext</a>(如果有)。这相当于<a href="qqmlengine.html#contextForObject">QQmlEngine::contextForObject</a>(object)。</p>
<p><b><span lang="zh-cn">注意</span>: </b>添加<code>#include &lt;QtQml&gt;</code>使用此函数。</p><p><b>请参考 </b><a href="qqmlengine.html#contextForObject">contextForObject</a>()
	<span lang="zh-cn">和</span><a href="qqmlengine.html#qmlEngine">qmlEngine</a>()<span lang="zh-cn">。</span></p>
<!-- @@@qmlContext -->
<!-- $$$qmlDebug[overload1]$$$qmlDebugconstQObject* -->
<h3 class="fn" id="qmlDebug"><a name="qmlDebug"></a><span class="type">QQmlInfo</span> QtQml::<span class="name">qmlDebug</span>(const <span class="type"><a href="../qtcore/qobject.html#QObject">QObject</a></span> *<i>object</i>)</h3>
<p>打印包含指定QML<i><span lang="zh-cn"> </span>object<span lang="zh-cn">（</span></i>对象<span lang="zh-cn">）</span>的文件和行号的调试消息。</p>
<p>当QML类型产生日志消息时，如果它们包括实例化的特定实例的QML文件和行号，就可以提高可跟踪性。</p>
<p>要包含文件和行号，必须传递一个对象。如果文件和行号对该实例不可用(它不是由QML引擎实例化的，或者位置信息被禁用)，那么将使用“未知位置”。例如,</p>
<pre class="cpp">

  qmlDebug(object) <span class="operator">&lt;</span><span class="operator">&lt;</span> <span class="string">&quot;Internal state: 42&quot;</span>;

</pre>
<p><span lang="zh-cn">打印</span></p>
<pre class="cpp plain">

  QML MyCustomType (unknown location): Internal state: 42

</pre>
<p>这个函数是在Qt 5.9中引入的。</p>
<p><b>请参考 </b><a href="qqmlengine.html#qmlInfo">QtQml::qmlInfo</a> 
<span lang="zh-cn">和</span> <a href="qqmlengine.html#qmlWarning">QtQml::qmlWarning</a><span lang="zh-cn">。</span></p>
<!-- @@@qmlDebug -->
<!-- $$$qmlEngine[overload1]$$$qmlEngineconstQObject* -->
<h3 class="fn" id="qmlEngine"><a name="qmlEngine"></a><span class="type"><a href="qqmlengine.html#QQmlEngine">QQmlEngine</a></span> *<span class="name">qmlEngine</span>(const <span class="type"><a href="../qtcore/qobject.html#QObject">QObject</a></span> *<i>object</i>)</h3>
<p>返回与<i>object<span lang="zh-cn">（</span></i>对象<span lang="zh-cn">）</span>关联的<a href="qqmlengine.html">QQmlEngine</a>(如果有的话)。这相当于<a href="qqmlengine.html#contextForObject">QQmlEngine::contextForObject</a>(object)-<span lang="zh-cn">&gt;</span>engine()，但更有效。</p>
<p><b><span lang="zh-cn">注意</span>: 添加<code>#include &lt;QtQml&gt;</code>使用此函数。</b></p><p><b>请参考 </b><a href="qqmlengine.html#contextForObject">contextForObject</a>()
	<span lang="zh-cn">和</span><a href="qqmlengine.html#qmlContext">qmlContext</a>()<span lang="zh-cn">。</span></p>
<!-- @@@qmlEngine -->
<!-- $$$qmlInfo[overload1]$$$qmlInfoconstQObject* -->
<h3 class="fn" id="qmlInfo"><a name="qmlInfo"></a><span class="type">QQmlInfo</span> QtQml::<span class="name">qmlInfo</span>(const <span class="type"><a href="../qtcore/qobject.html#QObject">QObject</a></span> *<i>object</i>)</h3>
<p>打印包含指定QML<i><span lang="zh-cn"> </span>object<span lang="zh-cn">（</span></i>对象<span lang="zh-cn">）</span>的文件和行号的信息消息。</p>
<p>当QML类型产生日志消息时，如果它们包括实例化的特定实例的QML文件和行号，就可以提高可跟踪性。</p>
<p>要包含文件和行号，必须传递一个对象。如果文件和行号对该实例不可用(它不是由QML引擎实例化的，或者位置信息被禁用)，那么将使用“未知位置”。</p>
<p><span lang="zh-cn">例如：</span></p>
<pre class="cpp">

  qmlInfo(object) <span class="operator">&lt;</span><span class="operator">&lt;</span> tr(<span class="string">&quot;component property is a write-once property&quot;</span>);

</pre>
<p><span lang="zh-cn">打印</span></p>
<pre class="cpp plain">

  QML MyCustomType (unknown location): component property is a write-once property

</pre>
<p><b><span lang="zh-cn">注意</span>: </b>在Qt 5.9之前的版本中，qmlInfo使用警告<a href="../qtcore/qtglobal.html#QtMsgType-enum">QtMsgType</a>报告消息。对于Qt 
5.9及以上版本，qmlInfo使用一个信息<a href="../qtcore/qtglobal.html#QtMsgType-enum">QtMsgType</a>。要发送警告，请使用<a href="qqmlengine.html#qmlWarning">qmlWarning</a>。</p><p><b>请参考 </b><a href="qqmlengine.html#qmlDebug">QtQml::qmlDebug</a> 
	<span lang="zh-cn">和</span> <a href="qqmlengine.html#qmlWarning">QtQml::qmlWarning</a><span lang="zh-cn">。</span></p>
<!-- @@@qmlInfo -->
<!-- $$$qmlProtectModule[overload1]$$$qmlProtectModuleconstchar*int -->
<h3 class="fn" id="qmlProtectModule"><a name="qmlProtectModule"></a><span class="type">bool</span> <span class="name">qmlProtectModule</span>(const <span class="type">char</span> *<i>uri</i>, <span class="type">int</span> <i>majVersion</i>)</h3>
<p>这个函数保护模块不被注册类型。这可以用来防止其他插件向模块中注入类型。它还可以提高性能，因为它允许引擎在进行导入时跳过对新类型或插件可能性的检查。</p>
<p>
性能优势主要体现在从应用程序内部注册特定的应用程序类型，而不是通过插件。使用qmlProtectModule允许引擎在导入该uri时跳过对插件的检查，这对于速度较慢的文件系统来说是很明显的。</p>
<p>调用此函数后，任何将C++类型注册到此uri的尝试，主版本组合都会导致运行时错误。在向引擎注册了所有类型后调用此函数。</p>
<p>如果以uri作为<a href="qtqml-modules-identifiedmodules.html">模块标识符</a>和<i>majVersion</i> 
作为主版本号的模块被找到并锁定，则返回true，否则返回false。模块必须包含导出的类型才能被找到。</p>
<!-- @@@qmlProtectModule -->
<!-- $$$qmlRegisterExtendedType[overload1]$$$qmlRegisterExtendedTypeconstchar*intintconstchar* -->
<h3 class="fn" id="qmlRegisterExtendedType"><a name="qmlRegisterExtendedType"></a><span class="type">int</span> <span class="name">qmlRegisterExtendedType</span>(const <span class="type">char</span> *<i>uri</i>, <span class="type">int</span> <i>versionMajor</i>, <span class="type">int</span> <i>versionMinor</i>, const <span class="type">char</span> *<i>qmlName</i>)</h3>
<p>这个模板函数在QML系统中用库中的名称<i>qmlName</i> 注册C++类型及其扩展对象，该库从uri中导入，版本号由<i>versionMajor</i> 
和<i>versionMinor</i>组成。将在扩展对象中搜索主类型中不可用的属性。</p>
<p>返回QML类型id。</p>
<p><b>请参考 </b><a href="qqmlengine.html#qmlRegisterType">qmlRegisterType</a>()
<span lang="zh-cn">和</span>
<a href="qtqml-cppintegration-definetypes.html#registering-extension-objects">
注册扩展对象</a><span lang="zh-cn">。</span></p>
<!-- @@@qmlRegisterExtendedType -->
<!-- $$$qmlRegisterExtendedUncreatableType[overload1]$$$qmlRegisterExtendedUncreatableTypeconstchar*intintconstchar*constQString& -->
<h3 class="fn" id="qmlRegisterExtendedUncreatableType"><a name="qmlRegisterExtendedUncreatableType"></a><span class="type">int</span> <span class="name">qmlRegisterExtendedUncreatableType</span>(const <span class="type">char</span> *<i>uri</i>, <span class="type">int</span> <i>versionMajor</i>, <span class="type">int</span> <i>versionMinor</i>, const <span class="type">char</span> *<i>qmlName</i>, const <span class="type"><a href="../qtcore/qstring.html">QString</a></span> &amp;<i>reason</i>)</h3>
<p>这个模板函数在QML系统中使用库中的名称<i>qmlName</i> 注册C++类型及其扩展，该库从<i>uri</i> 中导入，版本号由<i>versionMajor</i> 
和<i>versionMinor</i>组成。</p>
<p>虽然类型具有名称和类型，但不能创建它。如果用户试图创建此类型的实例，则打印带有给定原因的错误消息。</p>
<p>当类型仅用于提供附加属性、枚举值或带有其扩展的抽象基类时，这很有用。</p>
<p>Returns the QML type id.</p>
<p><b>请参考 </b><a href="qqmlengine.html#qmlRegisterUncreatableType">qmlRegisterUncreatableType</a>()<span lang="zh-cn">。</span></p>
<!-- @@@qmlRegisterExtendedUncreatableType -->
<!-- $$$qmlRegisterInterface[overload1]$$$qmlRegisterInterfaceconstchar* -->
<h3 class="fn" id="qmlRegisterInterface"><a name="qmlRegisterInterface"></a><span class="type">int</span> <span class="name">qmlRegisterInterface</span>(const <span class="type">char</span> *<i>typeName</i>)</h3>
<p>这个模板函数在QML系统中以<i>typeName</i>的名称注册C++类型。</p>
<p>在引擎中注册为接口的类型也应该声明自己为<a href="../qtcore/metaobjects.html">元对象系统</a>中的接口。例如:</p>
<pre class="cpp">

  <span class="keyword">struct</span> FooInterface
  {
  <span class="keyword">public</span>:
      <span class="keyword">virtual</span> <span class="operator">~</span>FooInterface();
      <span class="keyword">virtual</span> <span class="type">void</span> doSomething() <span class="operator">=</span> <span class="number">0</span>;
  };

  Q_DECLARE_INTERFACE(FooInterface<span class="operator">,</span> <span class="string">&quot;org.foo.FooInterface&quot;</span>)

</pre>
<p>当以这种方式向QML引擎注册时，它们可以用作属性类型:</p>
<p><a href="../qtcore/qobject.html#Q_PROPERTY">Q_PROPERTY</a>(FooInterface *foo READ foo WRITE setFoo)</p>
<p>当您将<a href="../qtcore/qobject.html">QObject</a>子类分配给此属性时，QML引擎会自动将接口转换为<code>FooInterface*</code> 
。</p>
<p>返回QML类型id。</p>
<!-- @@@qmlRegisterInterface -->
<!-- $$$qmlRegisterModule[overload1]$$$qmlRegisterModuleconstchar*intint -->
<h3 class="fn" id="qmlRegisterModule"><a name="qmlRegisterModule"></a><span class="type">void</span> <span class="name">qmlRegisterModule</span>(const <span class="type">char</span> *<i>uri</i>, <span class="type">int</span> <i>versionMajor</i>, <span class="type">int</span> <i>versionMinor</i>)</h3>
<p>这个函数用<i>versionMajor</i> 和<i>versionMinor</i>中指定的版本注册一个特定uri中的模块。</p>
<p>这可以用来使某个模块版本可用，即使该版本没有注册任何类型。这对于保持相关模块的版本同步特别有用。</p>
<p>这个函数是在Qt 5.9中引入的。</p>
<!-- @@@qmlRegisterModule -->
<!-- $$$qmlRegisterRevision[overload1]$$$qmlRegisterRevisionconstchar*intint -->
<h3 class="fn" id="qmlRegisterRevision"><a name="qmlRegisterRevision"></a><span class="type">int</span> <span class="name">qmlRegisterRevision</span>(const <span class="type">char</span> *<i>uri</i>, <span class="type">int</span> <i>versionMajor</i>, <span class="type">int</span> <i>versionMinor</i>)</h3>
<p>这个模板函数在QML系统中使用从uri导入的库注册C++类型的指定修订版，该库的版本号由<i>versionMajor</i> 和<i>versionMinor</i>组成。</p>
<p>返回QML类型id。</p>
<pre class="cpp">

  <span class="keyword">template</span><span class="operator">&lt;</span><span class="keyword">typename</span> T<span class="operator">,</span> <span class="type">int</span> metaObjectRevision<span class="operator">&gt;</span>
  <span class="type">int</span> qmlRegisterRevision(<span class="keyword">const</span> <span class="type">char</span> <span class="operator">*</span>uri<span class="operator">,</span> <span class="type">int</span> versionMajor<span class="operator">,</span> <span class="type">int</span> versionMinor);

</pre>
<p>此函数通常用于注册基类的修订，以用于类型的指定版本(请参阅<a href="qtqml-cppintegration-definetypes.html#type-revisions-and-versions">类型修订和版本</a>)。</p>
<!-- @@@qmlRegisterRevision -->
<!-- $$$qmlRegisterSingletonType[overload1]$$$qmlRegisterSingletonTypeconstchar*intintconstchar*QJSValue(*)(QQmlEngine*,QJSEngine*) -->
<h3 class="fn" id="qmlRegisterSingletonType"><a name="qmlRegisterSingletonType"></a><span class="type">int</span> <span class="name">qmlRegisterSingletonType</span>(const <span class="type">char</span> *<i>uri</i>, <span class="type">int</span> <i>versionMajor</i>, <span class="type">int</span> <i>versionMinor</i>, const <span class="type">char</span> *<i>typeName</i>, <span class="type"><a href="qjsvalue.html">QJSValue</a></span> (*)(<span class="type"><a href="qqmlengine.html#QQmlEngine">QQmlEngine</a></span> *, <span class="type"><a href="qjsengine.html#QJSEngine">QJSEngine</a></span> *) <i>callback</i>)</h3>
<p>此函数可用于在特定的<i>uri</i> 和<i>typeName</i> 中注册一个单例类型提供程序回调，版本在<i>versionMajor</i> 
和<i>versionMinor</i>中指定。</p>
<p>安装单例类型允许开发人员向客户端提供任意的功能(方法和属性)，而不需要客户端实例化该类型的单个实例。</p>
<p>单例类型可以是<a href="../qtcore/qobject.html">QObject</a>或<a href="qjsvalue.html">QJSValue</a>。这个函数应该用于注册一个单例类型提供程序函数，该函数返回一个作为单例类型的<a href="qjsvalue.html">QJSValue</a>。</p>
<p><b><span lang="zh-cn">注意</span>:</b> 如果更改了<a href="qjsvalue.html">QJSValue</a>单例类型属性，将<b>不会</b> 
触发绑定重新计算。</p>
<p>用法:</p>
<pre class="cpp">

  <span class="comment">// First, define the singleton type provider function (callback).</span>
  <span class="keyword">static</span> <span class="type"><a href="qjsvalue.html">QJSValue</a></span> example_qjsvalue_singletontype_provider(<span class="type"><a href="qqmlengine.html">QQmlEngine</a></span> <span class="operator">*</span>engine<span class="operator">,</span> <span class="type"><a href="qjsengine.html">QJSEngine</a></span> <span class="operator">*</span>scriptEngine)
  {
      Q_UNUSED(engine)

      <span class="keyword">static</span> <span class="type">int</span> seedValue <span class="operator">=</span> <span class="number">5</span>;
      <span class="type"><a href="qjsvalue.html">QJSValue</a></span> example <span class="operator">=</span> scriptEngine<span class="operator">-</span><span class="operator">&gt;</span>newObject();
      example<span class="operator">.</span>setProperty(<span class="string">&quot;someProperty&quot;</span><span class="operator">,</span> seedValue<span class="operator">+</span><span class="operator">+</span>);
      <span class="keyword">return</span> example;
  }

  <span class="comment">// Second, register the singleton type provider with QML by calling this function in an initialization function.</span>
  qmlRegisterSingletonType(<span class="string">&quot;Qt.example.qjsvalueApi&quot;</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="string">&quot;MyApi&quot;</span><span class="operator">,</span> example_qjsvalue_singletontype_provider);

</pre>
<p>或者，你可以使用C++ 11 lambda:</p>
<pre class="cpp">

  qmlRegisterSingletonType(<span class="string">&quot;Qt.example.qjsvalueApi&quot;</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="string">&quot;MyApi&quot;</span><span class="operator">,</span> <span class="operator">[</span><span class="operator">]</span>(<span class="type"><a href="qqmlengine.html">QQmlEngine</a></span> <span class="operator">*</span>engine<span class="operator">,</span> <span class="type"><a href="qjsengine.html">QJSEngine</a></span> <span class="operator">*</span>scriptEngine) <span class="operator">-</span><span class="operator">&gt;</span> <span class="type"><a href="qjsvalue.html">QJSValue</a></span> {
      Q_UNUSED(engine)

      <span class="keyword">static</span> <span class="type">int</span> seedValue <span class="operator">=</span> <span class="number">5</span>;
      <span class="type"><a href="qjsvalue.html">QJSValue</a></span> example <span class="operator">=</span> scriptEngine<span class="operator">-</span><span class="operator">&gt;</span>newObject();
      example<span class="operator">.</span>setProperty(<span class="string">&quot;someProperty&quot;</span><span class="operator">,</span> seedValue<span class="operator">+</span><span class="operator">+</span>);
      <span class="keyword">return</span> example;
  });

</pre>
<p>为了在QML中使用已注册的单例类型，您必须导入单例类型。</p>
<pre class="qml">

  import QtQuick 2.0
  import Qt.example.qjsvalueApi 1.0 as ExampleApi
  <span class="type"><a href="../qtquick/qml-qtquick-item.html">Item</a></span> {
      <span class="name">id</span>: <span class="name">root</span>
      property <span class="type"><a href="qml-int.html">int</a></span> <span class="name">someValue</span>: <span class="name">ExampleApi</span>.<span class="name">MyApi</span>.<span class="name">someProperty</span>
  }

</pre>
<p><b>请参考 </b>
<a href="qtqml-cppintegration-overview.html#choosing-the-correct-integration-method-between-c-and-qml">
选择正确的C++与QML集成方法。</a></p>
<!-- @@@qmlRegisterSingletonType -->
<!-- $$$qmlRegisterSingletonType$$$qmlRegisterSingletonTypeconstchar*intintconstchar*QObject*(*)(QQmlEngine*,QJSEngine*) -->
<h3 class="fn" id="qmlRegisterSingletonType-1"><a name="qmlRegisterSingletonType-1"></a><span class="type">int</span> <span class="name">qmlRegisterSingletonType</span>(const <span class="type">char</span> *<i>uri</i>, <span class="type">int</span> <i>versionMajor</i>, <span class="type">int</span> <i>versionMinor</i>, const <span class="type">char</span> *<i>typeName</i>, <span class="type"><a href="../qtcore/qobject.html#QObject">QObject</a></span> *(*)(<span class="type"><a href="qqmlengine.html#QQmlEngine">QQmlEngine</a></span> *, <span class="type"><a href="qjsengine.html#QJSEngine">QJSEngine</a></span> *) <i>callback</i>)</h3>
<p>此函数可用于在特定的<i>uri</i> 和<i>typeName</i> 中注册一个单例类型提供程序<i>callback</i> ，版本在<i>versionMajor</i> 
和<i>versionMinor</i>中指定。</p>
<p>在uri中安装一个单例类型允许开发人员向客户端提供任意的功能(方法和属性)，而不需要客户端实例化该类型的单个实例。</p>
<p>单例类型可以是<a href="../qtcore/qobject.html">QObject</a>或<a href="qjsvalue.html">QJSValue</a>。这个函数应该用来注册一个单例类型提供程序函数，该函数返回给定类型T的<a href="../qtcore/qobject.html">QObject</a>作为单例类型。</p>
<p><a href="../qtcore/qobject.html">QObject</a>单例类型可以通过其注册时使用的类型名来引用，这个类型名可以用作<a href="qml-qtqml-connections.html">Connections</a>类型中的目标，也可以像其他任何类型id一样使用。一个例外是<a href="../qtcore/qobject.html">QObject</a>单例类型属性可能没有别名(因为单例类型名称不能与任何其他项标识同一个组件中的对象)。</p>
<p><b><span lang="zh-cn">注意</span>:</b>从单例类型提供程序返回的<a href="../qtcore/qobject.html">QObject</a>单例类型实例由QML引擎拥有，除非该对象明确设置了<a href="qqmlengine.html#ObjectOwnership-enum">QQmlEngine::CppOwnership</a>标志。</p>
<p>Usage:</p>
<pre class="cpp">

  <span class="comment">// First, define your QObject which provides the functionality.</span>
  <span class="keyword">class</span> SingletonTypeExample : <span class="keyword">public</span> <span class="type"><a href="../qtcore/qobject.html">QObject</a></span>
  {
      Q_OBJECT
      Q_PROPERTY (<span class="type">int</span> someProperty READ someProperty WRITE setSomeProperty NOTIFY somePropertyChanged)

  <span class="keyword">public</span>:
      SingletonTypeExample(<span class="type"><a href="../qtcore/qobject.html">QObject</a></span><span class="operator">*</span> parent <span class="operator">=</span> <span class="number">0</span>)
          : <span class="type"><a href="../qtcore/qobject.html">QObject</a></span>(parent)<span class="operator">,</span> m_someProperty(<span class="number">0</span>)
      {
      }

      <span class="operator">~</span>SingletonTypeExample() {}

      Q_INVOKABLE <span class="type">int</span> doSomething() { setSomeProperty(<span class="number">5</span>); <span class="keyword">return</span> m_someProperty; }

      <span class="type">int</span> someProperty() <span class="keyword">const</span> { <span class="keyword">return</span> m_someProperty; }
      <span class="type">void</span> setSomeProperty(<span class="type">int</span> val) { m_someProperty <span class="operator">=</span> val; <span class="keyword">emit</span> somePropertyChanged(val); }

  <span class="keyword">signals</span>:
      <span class="type">void</span> somePropertyChanged(<span class="type">int</span> newValue);

  <span class="keyword">private</span>:
      <span class="type">int</span> m_someProperty;
  };

  <span class="comment">// Second, define the singleton type provider function (callback).</span>
  <span class="keyword">static</span> <span class="type"><a href="../qtcore/qobject.html">QObject</a></span> <span class="operator">*</span>example_qobject_singletontype_provider(<span class="type"><a href="qqmlengine.html">QQmlEngine</a></span> <span class="operator">*</span>engine<span class="operator">,</span> <span class="type"><a href="qjsengine.html">QJSEngine</a></span> <span class="operator">*</span>scriptEngine)
  {
      Q_UNUSED(engine)
      Q_UNUSED(scriptEngine)

      SingletonTypeExample <span class="operator">*</span>example <span class="operator">=</span> <span class="keyword">new</span> SingletonTypeExample();
      <span class="keyword">return</span> example;
  }

  <span class="comment">// Third, register the singleton type provider with QML by calling this function in an initialization function.</span>
  qmlRegisterSingletonType<span class="operator">&lt;</span>SingletonTypeExample<span class="operator">&gt;</span>(<span class="string">&quot;Qt.example.qobjectSingleton&quot;</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="string">&quot;MyApi&quot;</span><span class="operator">,</span> example_qobject_singletontype_provider);

</pre>
<p>或者，你可以使用C++ 11 lambda:</p>
<pre class="cpp">

  qmlRegisterSingletonType<span class="operator">&lt;</span>SingletonTypeExample<span class="operator">&gt;</span>(<span class="string">&quot;Qt.example.qjsvalueApi&quot;</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="string">&quot;MyApi&quot;</span><span class="operator">,</span> <span class="operator">[</span><span class="operator">]</span>(<span class="type"><a href="qqmlengine.html">QQmlEngine</a></span> <span class="operator">*</span>engine<span class="operator">,</span> <span class="type"><a href="qjsengine.html">QJSEngine</a></span> <span class="operator">*</span>scriptEngine) <span class="operator">-</span><span class="operator">&gt;</span> <span class="type"><a href="../qtcore/qobject.html">QObject</a></span> <span class="operator">*</span> {
      Q_UNUSED(engine)
      Q_UNUSED(scriptEngine)

      SingletonTypeExample <span class="operator">*</span>example <span class="operator">=</span> <span class="keyword">new</span> SingletonTypeExample();
      <span class="keyword">return</span> example;
  });

</pre>
<p>为了在QML中使用已注册的单例类型，您必须导入单例类型。</p>
<pre class="qml">

  import QtQuick 2.0
  import Qt.example.qobjectSingleton 1.0
  <span class="type"><a href="../qtquick/qml-qtquick-item.html">Item</a></span> {
      <span class="name">id</span>: <span class="name">root</span>
      property <span class="type"><a href="qml-int.html">int</a></span> <span class="name">someValue</span>: <span class="name">MyApi</span>.<span class="name">someProperty</span>

      <span class="name">Component</span>.onCompleted: {
          <span class="name">someValue</span> <span class="operator">=</span> <span class="name">MyApi</span>.<span class="name">doSomething</span>()
      }
  }

</pre>
<p><b>请参考 </b><a href="qtqml-cppintegration-overview.html#choosing-the-correct-integration-method-between-c-and-qml">选择正确的C++与QML集成方法</a>.</p>
<!-- @@@qmlRegisterSingletonType -->
<!-- $$$qmlRegisterSingletonType$$$qmlRegisterSingletonTypeconstQUrl&constchar*intintconstchar* -->
<h3 class="fn" id="qmlRegisterSingletonType-2"><a name="qmlRegisterSingletonType-2"></a><span class="type">int</span> <span class="name">qmlRegisterSingletonType</span>(const <span class="type"><a href="../qtcore/qurl.html">QUrl</a></span> &amp;<i>url</i>, const <span class="type">char</span> *<i>uri</i>, <span class="type">int</span> <i>versionMajor</i>, <span class="type">int</span> <i>versionMinor</i>, const <span class="type">char</span> *<i>qmlName</i>)</h3>
<p>该函数可用于注册名称为<i>qmlName</i>的单例类型，该单例类型从uri导入，版本号由<i>versionMinor</i>和<i>versionMajor</i> 
组成。该类型由位于url的QML文件定义。url必须是一个绝对url，即url.isRelative() == false。</p>
<p>此外，类型的QML文件的导入语句中必须有pragma Singleton语句。</p>
<p>&nbsp;单例类型可以通过其注册时使用的类型名来引用，这个类型名可以用作<a href="qml-qtqml-connections.html">Connections</a>类型中的目标，也可以像其他任何类型id一样使用。一个例外是，单例类型属性可能没有别名(因为单例类型名称不能与任何其他项标识同一个组件中的对象)。</p>
<p>Usage:</p>
<pre class="qml">

  <span class="comment">// First, define your QML singleton type which provides the functionality.</span>
  pragma Singleton
  import QtQuick 2.0
  <span class="type"><a href="../qtquick/qml-qtquick-item.html">Item</a></span> {
      property <span class="type"><a href="qml-int.html">int</a></span> <span class="name">testProp1</span>: <span class="number">125</span>
  }

</pre>
<pre class="cpp">

  <span class="comment">// Second, register the QML singleton type by calling this function in an initialization function.</span>
  qmlRegisterSingletonType(<span class="type"><a href="../qtcore/qurl.html">QUrl</a></span>(<span class="string">&quot;file:///absolute/path/SingletonType.qml&quot;</span>)<span class="operator">,</span> <span class="string">&quot;Qt.example.qobjectSingleton&quot;</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="string">&quot;RegisteredSingleton&quot;</span>);

</pre>
<p>为了在QML中使用已注册的单例类型，您必须导入单例类型。</p>
<pre class="qml">

  import QtQuick 2.0
  import Qt.example.qobjectSingleton 1.0
  <span class="type"><a href="../qtquick/qml-qtquick-item.html">Item</a></span> {
      <span class="name">id</span>: <span class="name">root</span>
      property <span class="type"><a href="qml-int.html">int</a></span> <span class="name">someValue</span>: <span class="name">RegisteredSingleton</span>.<span class="name">testProp1</span>
  }

</pre>
<p>也可以在不使用<a href="qqmlengine.html#qmlRegisterSingletonType">qmlRegisterSingletonType</a>函数的情况下注册QML单例类型。这可以通过在类型的QML文件的导入中添加一个pragma 
Singleton语句来完成。此外，类型必须在带有singleton关键字的qmldir文件中定义，QML文件必须使用singleton导入qmldir。</p>
<!-- @@@qmlRegisterSingletonType -->
<!-- $$$qmlRegisterType[overload1]$$$qmlRegisterType -->
<h3 class="fn" id="qmlRegisterType"><a name="qmlRegisterType"></a><span class="type">int</span> <span class="name">qmlRegisterType</span>()</h3>
<p>这是一个重载函数。</p>
<p>这个模板函数在QML系统中注册C++类型。不能从QML系统中创建这种类型的实例。</p>
<p>当类型不能通过名称引用时，应该使用此函数。具体来说，它必须用于作为属性绑定左侧的C++类型。</p>
<p>例如，考虑以下两个类:</p>
<pre class="cpp">

  <span class="keyword">class</span> Bar : <span class="keyword">public</span> <span class="type"><a href="../qtcore/qobject.html">QObject</a></span>
  {
      Q_OBJECT
      Q_PROPERTY(<span class="type"><a href="../qtcore/qstring.html">QString</a></span> baz READ baz WRITE setBaz NOTIFY bazChanged)

  <span class="keyword">public</span>:
      Bar() {}

      <span class="type"><a href="../qtcore/qstring.html">QString</a></span> baz() <span class="keyword">const</span> { <span class="keyword">return</span> mBaz; }

      <span class="type">void</span> setBaz(<span class="keyword">const</span> <span class="type"><a href="../qtcore/qstring.html">QString</a></span> <span class="operator">&amp;</span>baz)
      {
          <span class="keyword">if</span> (baz <span class="operator">=</span><span class="operator">=</span> mBaz)
              <span class="keyword">return</span>;

          mBaz <span class="operator">=</span> baz;
          <span class="keyword">emit</span> bazChanged();
      }

  <span class="keyword">signals</span>:
      <span class="type">void</span> bazChanged();

  <span class="keyword">private</span>:
      <span class="type"><a href="../qtcore/qstring.html">QString</a></span> mBaz;
  };

  <span class="keyword">class</span> Foo : <span class="keyword">public</span> <span class="type"><a href="../qtcore/qobject.html">QObject</a></span>
  {
      Q_OBJECT
      Q_PROPERTY(Bar <span class="operator">*</span>bar READ bar CONSTANT FINAL)

  <span class="keyword">public</span>:
      Foo() {}

      Bar <span class="operator">*</span>bar() { <span class="keyword">return</span> <span class="operator">&amp;</span>mBar; }

  <span class="keyword">private</span>:
      Bar mBar;
  };

</pre>
<p>在QML中，我们给bar的baz属性赋值一个字符串:</p>
<pre class="cpp">

  Foo {
      bar<span class="operator">.</span>baz: <span class="string">&quot;abc&quot;</span>
      Component<span class="operator">.</span>onCompleted: print(bar<span class="operator">.</span>baz)
  }

</pre>
<p>为了让QML引擎知道Bar类型有一个baz属性，我们必须让Bar知道:</p>
<pre class="cpp">

  qmlRegisterType<span class="operator">&lt;</span>Foo<span class="operator">&gt;</span>(<span class="string">&quot;App&quot;</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="string">&quot;Foo&quot;</span>);
  qmlRegisterType<span class="operator">&lt;</span>Bar<span class="operator">&gt;</span>();

</pre>
<p>因为Foo类型是在QML中实例化的，所以它必须用带有导入URI的qmlRegisterType()版本注册。</p>
<p>返回QML类型id。</p>
<p><b>请参考 </b><a href="qtqml-cppintegration-overview.html#choosing-the-correct-integration-method-between-c-and-qml">选择正确的C++与QML集成方法</a>.</p>
<!-- @@@qmlRegisterType -->
<!-- $$$qmlRegisterType[overload1]$$$qmlRegisterTypeconstchar*intintconstchar* -->
<h3 class="fn" id="qmlRegisterType"><a name="qmlRegisterType"></a><span class="type">int</span> <span class="name">qmlRegisterType</span>(const <span class="type">char</span> *<i>uri</i>, <span class="type">int</span> <i>versionMajor</i>, <span class="type">int</span> <i>versionMinor</i>, const <span class="type">char</span> *<i>qmlName</i>)</h3>
<p>这个模板函数在QML系统中以名称<i>qmlName</i>注册C++类型，在从<i>uri</i> 导入的库中，版本号由<i>versionMajor</i> 
和<i>versionMinor</i>组成。</p>
<p>返回QML类型id。</p>
<p>这个模板函数有两种形式:</p>
<pre class="cpp">

  <span class="keyword">template</span><span class="operator">&lt;</span><span class="keyword">typename</span> T<span class="operator">&gt;</span>
  <span class="type">int</span> qmlRegisterType(<span class="keyword">const</span> <span class="type">char</span> <span class="operator">*</span>uri<span class="operator">,</span> <span class="type">int</span> versionMajor<span class="operator">,</span> <span class="type">int</span> versionMinor<span class="operator">,</span> <span class="keyword">const</span> <span class="type">char</span> <span class="operator">*</span>qmlName);

  <span class="keyword">template</span><span class="operator">&lt;</span><span class="keyword">typename</span> T<span class="operator">,</span> <span class="type">int</span> metaObjectRevision<span class="operator">&gt;</span>
  <span class="type">int</span> qmlRegisterType(<span class="keyword">const</span> <span class="type">char</span> <span class="operator">*</span>uri<span class="operator">,</span> <span class="type">int</span> versionMajor<span class="operator">,</span> <span class="type">int</span> versionMinor<span class="operator">,</span> <span class="keyword">const</span> <span class="type">char</span> <span class="operator">*</span>qmlName);

</pre>
<p>前者是将类型T注册为新类型的标准形式。后者允许在指定的版本中注册类的特定修订(请参阅<a href="qtqml-cppintegration-definetypes.html#type-revisions-and-versions">类型修订和版本</a>)。</p>
<p>例如，它注册了一个C++类<code>MySliderItem</code> 
作为一个名为Slider的QML类型的1.0版本的类型命名空间“com.mycompany.qmlcomponents”:</p>
<pre class="cpp">

  qmlRegisterType<span class="operator">&lt;</span>MySliderItem<span class="operator">&gt;</span>(<span class="string">&quot;com.mycompany.qmlcomponents&quot;</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="string">&quot;Slider&quot;</span>);

</pre>
<p>一旦注册了该类型，就可以通过导入指定的类型名称空间和版本号在QML中使用该类型:</p>
<pre class="qml">

  import com.mycompany.qmlcomponents 1.0

  <span class="type"><a href="../qtquickcontrols/qml-qtquick-controls2-slider.html">Slider</a></span> {
      <span class="comment">// ...</span>
  }

</pre>
<p>
请注意，对于库来说，将类型注册到比库的实际版本更旧的版本是完全合理的。事实上，新库允许写入到以前版本的QML继续工作是正常的，即使某些类型的更高级版本可用。</p>
<p><b>请参考 </b><a href="qtqml-cppintegration-overview.html#choosing-the-correct-integration-method-between-c-and-qml">选择正确的C++与QML集成方法</a>.</p>
<!-- @@@qmlRegisterType -->
<!-- $$$qmlRegisterType$$$qmlRegisterTypeconstQUrl&constchar*intintconstchar* -->
<h3 class="fn" id="qmlRegisterType-2"><a name="qmlRegisterType-2"></a><span class="type">int</span> <span class="name">qmlRegisterType</span>(const <span class="type"><a href="../qtcore/qurl.html">QUrl</a></span> &amp;<i>url</i>, const <span class="type">char</span> *<i>uri</i>, <span class="type">int</span> <i>versionMajor</i>, <span class="type">int</span> <i>versionMinor</i>, const <span class="type">char</span> *<i>qmlName</i>)</h3>
<p>这个函数在QML系统中用名称<i>qmlName</i>注册一个类型，该类型在从<i>uri</i> 导入的库中，版本号由<i>versionMinor</i>和<i>versionMajor</i> 
组成。该类型由位于url的QML文件定义。<i>url</i>必须是一个绝对<i>url</i>，即<i>url</i>. isrelative () == 
false。</p>
<p>
通常，QML文件可以直接从其他QML文件作为类型加载，或者使用qmldir文件加载。这个函数允许从C++代码注册文件到类型，比如在启动时需要程序确定类型映射时。</p>
<p>如果注册失败，返回-1。</p>
<!-- @@@qmlRegisterType -->
<!-- $$$qmlRegisterTypeNotAvailable[overload1]$$$qmlRegisterTypeNotAvailableconstchar*intintconstchar*constQString& -->
<h3 class="fn" id="qmlRegisterTypeNotAvailable"><a name="qmlRegisterTypeNotAvailable"></a><span class="type">int</span> <span class="name">qmlRegisterTypeNotAvailable</span>(const <span class="type">char</span> *<i>uri</i>, <span class="type">int</span> <i>versionMajor</i>, <span class="type">int</span> <i>versionMinor</i>, const <span class="type">char</span> *<i>qmlName</i>, const <span class="type"><a href="../qtcore/qstring.html">QString</a></span> &amp;<i>message</i>)</h3>
<p>这个函数在QML系统中用名称<i>qmlName</i>注册一个类型，该类型名称空间从<i>uri</i> 导入，版本号由<i>versionMajor</i> 
和<i>versionMinor</i>组成，但是任何实例化该类型的尝试都会产生给定的错误<i>message<span lang="zh-cn">（</span></i>消息<span lang="zh-cn">）</span>。</p>
<p>通常，插件导出的类型应该是固定的。但是，如果C++类型不可用，您至少应该“保留”QML类型名，并给不可用类型的用户一个有意义的错误消息。</p>
<p>返回QML类型id。</p>
<p>例子:</p>
<pre class="cpp">

  <span class="preprocessor">#ifdef NO_GAMES_ALLOWED</span>
  qmlRegisterTypeNotAvailable(<span class="string">&quot;MinehuntCore&quot;</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="string">&quot;Game&quot;</span><span class="operator">,</span> <span class="string">&quot;Get back to work, slacker!&quot;</span>);
  <span class="preprocessor">#else</span>
  qmlRegisterType<span class="operator">&lt;</span>MinehuntGame<span class="operator">&gt;</span>(<span class="string">&quot;MinehuntCore&quot;</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="string">&quot;Game&quot;</span>);
  <span class="preprocessor">#endif</span>

</pre>
<p>这将导致任何导入“MinehuntCore”类型名称空间并尝试使用该类型的QML产生错误消息:</p>
<pre class="cpp">

  fun<span class="operator">.</span>qml: Get back to work<span class="operator">,</span> slacker<span class="operator">!</span>
     Game {
     <span class="operator">^</span>

</pre>
<p>如果没有这一点，就会出现“游戏不是一种类型”的信息。</p>
<p><b>请参考 </b><a href="qqmlengine.html#qmlRegisterUncreatableType">qmlRegisterUncreatableType</a>() and <a href="qtqml-cppintegration-overview.html#choosing-the-correct-integration-method-between-c-and-qml">选择正确的C++与QML集成方法</a><span lang="zh-cn">。</span></p>
<!-- @@@qmlRegisterTypeNotAvailable -->
<!-- $$$qmlRegisterUncreatableMetaObject[overload1]$$$qmlRegisterUncreatableMetaObjectconstQMetaObject&constchar*intintconstchar*constQString& -->
<h3 class="fn" id="qmlRegisterUncreatableMetaObject"><a name="qmlRegisterUncreatableMetaObject"></a><span class="type">int</span> <span class="name">qmlRegisterUncreatableMetaObject</span>(const <span class="type"><a href="../qtcore/qmetaobject.html">QMetaObject</a></span> &amp;<i>staticMetaObject</i>, const <span class="type">char</span> *<i>uri</i>, <span class="type">int</span> <i>versionMajor</i>, <span class="type">int</span> <i>versionMinor</i>, const <span class="type">char</span> *<i>qmlName</i>, const <span class="type"><a href="../qtcore/qstring.html">QString</a></span> &amp;<i>reason</i>)</h3>
<p>这个函数在QML系统中使用库中的名称<i>qmlName</i> 注册<i>staticMetaObject</i> 
及其扩展，该库从uri中导入，版本号由<i>versionMajor</i> 和<i>versionMinor</i>组成。</p>
<p>无法创建元对象的实例。如果用户试图创建它，就会打印一个带有给定原因的错误消息。</p>
<p>这个函数对于注册<a href="../qtcore/qobject.html#Q_NAMESPACE">Q_NAMESPACE</a>名称空间非常有用。</p>
<p>返回QML类型id。</p>
<p>例如:</p>
<pre class="cpp">

  <span class="keyword">namespace</span> MyNamespace {
    Q_NAMESPACE
    <span class="keyword">enum</span> MyEnum {
        Key1<span class="operator">,</span>
        Key2<span class="operator">,</span>
    };
    Q_ENUMS(MyEnum)
  }

  <span class="comment">//...</span>
  qmlRegisterUncreatableMetaObject(MyNamespace<span class="operator">::</span>staticMetaObject<span class="operator">,</span> <span class="string">&quot;io.qt&quot;</span><span class="operator">,</span> <span class="number">1</span><span class="operator">,</span> <span class="number">0</span><span class="operator">,</span> <span class="string">&quot;MyNamespace&quot;</span><span class="operator">,</span> <span class="string">&quot;Access to enums &amp; flags only&quot;</span>);

</pre>
<p>在QML方面，您现在可以使用已注册的枚举:</p>
<pre class="cpp">

  Component<span class="operator">.</span>onCompleted: console<span class="operator">.</span>log(MyNamespace<span class="operator">.</span>Key2)

</pre>
<p>这个函数是在Qt 5.8中引入的。</p>
<!-- @@@qmlRegisterUncreatableMetaObject -->
<!-- $$$qmlRegisterUncreatableType[overload1]$$$qmlRegisterUncreatableTypeconstchar*intintconstchar*constQString& -->
<h3 class="fn" id="qmlRegisterUncreatableType"><a name="qmlRegisterUncreatableType"></a><span class="type">int</span> <span class="name">qmlRegisterUncreatableType</span>(const <span class="type">char</span> *<i>uri</i>, <span class="type">int</span> <i>versionMajor</i>, <span class="type">int</span> <i>versionMinor</i>, const <span class="type">char</span> *<i>qmlName</i>, const <span class="type"><a href="../qtcore/qstring.html">QString</a></span> &amp;<i>message</i>)</h3>
<p>这个模板函数在QML系统中以名称<i>qmlName</i>注册<span lang="zh-cn">C</span>++类型，在从uri导入的库中，版本号由<i>versionMajor</i> 
和<i>versionMinor</i>组成。</p>
<p>虽然类型具有名称和类型，但无法创建它，如果尝试创建，则会产生给定的错误消息。</p>
<p>当类型仅用于提供附加属性或枚举值时，这非常有用。</p>
<p>返回QML类型id。</p>
<p><b>请参考 </b><a href="qqmlengine.html#qmlRegisterTypeNotAvailable">qmlRegisterTypeNotAvailable</a>() and <a href="qtqml-cppintegration-overview.html#choosing-the-correct-integration-method-between-c-and-qml">选择正确的C++与QML集成方法</a>.</p>
<!-- @@@qmlRegisterUncreatableType -->
<!-- $$$qmlTypeId[overload1]$$$qmlTypeIdconstchar*intintconstchar* -->
<h3 class="fn" id="qmlTypeId"><a name="qmlTypeId"></a><span class="type">int</span> <span class="name">qmlTypeId</span>(const <span class="type">char</span> *<i>uri</i>, <span class="type">int</span> <i>versionMajor</i>, <span class="type">int</span> <i>versionMinor</i>, const <span class="type">char</span> *<i>qmlName</i>)</h3>
<p>返回类型的QML类型id，该类型是用特定uri中的名称<i>qmlName</i> 注册的，以及在<i>versionMajor</i> 和<i>versionMinor</i>中指定的版本。</p>
<p>该函数返回与QML类型注册函数(如<a href="qqmlengine.html#qmlRegisterType">qmlRegisterType</a>()和<a href="qqmlengine.html#qmlRegisterSingletonType">qmlRegisterSingletonType</a>())相同的值。</p>
<p>如果<i>qmlName</i>、<i>uri</i> 和<i>versionMajor</i> 匹配注册的类型，但是<i>versionMinor</i> 
中指定的次要版本较高，则返回与次要版本最近的类型id。</p>
<p>如果未找到匹配类型或给定参数之一无效，则返回-1。</p>
<p>这个函数是在Qt 5.12中引入的。</p>
<p><b>请参考 </b><a href="qqmlengine.html#qmlRegisterType">qmlRegisterType</a>()
<span lang="zh-cn">和</span> <a href="qqmlengine.html#qmlRegisterSingletonType">qmlRegisterSingletonType</a>()<span lang="zh-cn">。</span></p>
<!-- @@@qmlTypeId -->
<!-- $$$qmlWarning[overload1]$$$qmlWarningconstQObject* -->
<h3 class="fn" id="qmlWarning"><a name="qmlWarning"></a><span class="type">QQmlInfo</span> QtQml::<span class="name">qmlWarning</span>(const <span class="type"><a href="../qtcore/qobject.html#QObject">QObject</a></span> *<i>object</i>)</h3>
<p>打印警告消息，其中包括指定QML<i><span lang="zh-cn"> </span>object<span lang="zh-cn">（</span></i>对象<span lang="zh-cn">）</span>的文件和行号。</p>
<p>当QML类型产生日志消息时，如果它们包括实例化的特定实例的QML文件和行号，就可以提高可跟踪性。</p>
<p>要包含文件和行号，必须传递一个对象。如果文件和行号对该实例不可用(它不是由QML引擎实例化的，或者位置信息被禁用)，那么将使用“未知位置”。</p>
<p>For example,</p>
<pre class="cpp">

  qmlInfo(object) <span class="operator">&lt;</span><span class="operator">&lt;</span> tr(<span class="string">&quot;property cannot be set to 0&quot;</span>);

</pre>
<p><span lang="zh-cn">打印</span></p>
<pre class="cpp plain">

  QML MyCustomType (unknown location): property cannot be set to 0

</pre>
<p>这个函数是在Qt 5.9中引入的。</p>
<p><b>请参考 </b><a href="qqmlengine.html#qmlDebug">QtQml::qmlDebug</a> 
<span lang="zh-cn">和</span> <a href="qqmlengine.html#qmlInfo">QtQml::qmlInfo</a><span lang="zh-cn">。</span></p>
<!-- @@@qmlWarning -->
</div>
<div class="macros">
<h2><span lang="zh-cn">宏文档</span></h2>
<!-- $$$QML_DECLARE_TYPE[overload1]$$$QML_DECLARE_TYPE -->
<h3 class="fn" id="QML_DECLARE_TYPE"><a name="QML_DECLARE_TYPE"></a><span class="name">QML_DECLARE_TYPE</span></h3>
<p>Equivalent to <code>Q_DECLARE_METATYPE(TYPE *)</code> and <code>Q_DECLARE_METATYPE(QQmlListProperty&lt;TYPE&gt;)</code></p>
<!-- @@@QML_DECLARE_TYPE -->
<!-- $$$QML_DECLARE_TYPEINFO[overload1]$$$QML_DECLARE_TYPEINFO -->
<h3 class="fn" id="QML_DECLARE_TYPEINFO"><a name="QML_DECLARE_TYPEINFO"></a><span class="name">QML_DECLARE_TYPEINFO</span>(<i>Type</i>, <i>Flags</i>)</h3>
<p>按照指定的标志声明给定类型的附加属性。</p>
<p>当前唯一支持的类型信息是QML_HAS_ATTACHED_PROPERTIES，它声明<i>Type</i> 支持<a href="qtqml-syntax-objectattributes.html#attached-properties-and-attached-signal-handlers">附加属性</a>。</p>
<!-- @@@QML_DECLARE_TYPEINFO -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2019 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
