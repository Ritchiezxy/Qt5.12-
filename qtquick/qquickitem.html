<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qquickitem.cpp -->
  <title>QQuickItem 类 | Qt Quick 5.12.3</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
  <div class="main">
    <div class="main-rounded">
      <div class="navigationbar">
        <table><tr>
<td ><a href="../qtdoc/index.html">Qt 5.12</a></td><td ><a href="qtquick-index.html">Qt Quick 模块</a></td><td ><a href="qtquick-module.html">C++ 类</a></td><td >QQuickItem</td></tr></table><table class="buildversion"><tr>
<td id="buildversion" width="100%" align="right"><a href="qtquick-index.html">Qt 5.12.3 参考指南</a></td>
        </tr></table>
      </div>
    </div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3><a name="toc">目录</a></h3>
<ul>
<li class="level1"><a href="#public-types">公用类型</a></li>
<li class="level1"><a href="#properties">属性</a></li>
<li class="level1"><a href="#public-functions">公用函数</a></li>
<li class="level1"><a href="#public-slots">公用槽函数</a></li>
<li class="level1"><a href="#signals">信号</a></li>
<li class="level1"><a href="#static-public-members">静态公用成员</a></li>
<li class="level1"><a href="#protected-functions">保护函数</a></li>
<li class="level1"><a href="#reimplemented-protected-functions">重新实现的保护函数</a></li>
<li class="level1"><a href="#details">详细信息</a></li>
<li class="level2"><a href="#custom-scene-graph-items">Custom Scene Graph Items</a></li>
<li class="level2"><a href="#custom-qpainter-items">Custom QPainter Items</a></li>
<li class="level2"><a href="#behavior-animations">Behavior Animations</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">QQuickItem 类</h1>
<!-- $$$QQuickItem-brief -->
<p><a href="qquickitem.html">QQuickItem</a>类提供了<a href="qtquick-index.html">Qt Quick 模块</a>中最基本的可视化项。 <a href="#details">更多...</a></p>
<!-- @@@QQuickItem -->
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign">头文件：</td><td class="memItemRight bottomAlign">   <span class="preprocessor">#include &lt;QQuickItem&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += quick</td></tr><tr><td class="memItemLeft rightAlign topAlign"> 
	实例化:</td><td class="memItemRight bottomAlign"> <a href="qml-qtquick-item.html">Item</a></td></tr><tr><td class="memItemLeft rightAlign topAlign">继承自：</td><td class="memItemRight bottomAlign"> <a href="../qtcore/qobject.html">QObject</a> and <a href="../qtqml/qqmlparserstatus.html">QQmlParserStatus</a></td></tr><tr><td class="memItemLeft rightAlign topAlign"> 被继承：</td><td class="memItemRight bottomAlign"> <p><a href="qquickframebufferobject.html">QQuickFramebufferObject</a> and <a href="qquickpainteditem.html">QQuickPaintedItem</a></p>
</td></tr></table></div><ul>
<li><a href="qquickitem-members.html">所有成员的列表，包括继承成员</a></li>
<li><a href="qquickitem-obsolete.html">废弃的成员</a></li>
</ul>
<a name="public-types"></a>
<h2 id="public-types">公用类型</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> class </td><td class="memItemRight bottomAlign"><b><a href="qquickitem-itemchangedata.html">ItemChangeData</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> class </td><td class="memItemRight bottomAlign"><b><a href="qquickitem-updatepaintnodedata.html">UpdatePaintNodeData</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#Flag-enum">Flag</a></b> { ItemClipsChildrenToShape, ItemAcceptsInputMethod, ItemIsFocusScope, ItemHasContents, ItemAcceptsDrops }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> flags </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#Flag-enum">Flags</a></b></td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#ItemChange-enum">ItemChange</a></b> { ItemChildAddedChange, ItemChildRemovedChange, ItemSceneChange, ItemVisibleHasChanged, ..., ItemEnabledHasChanged }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#TransformOrigin-enum">TransformOrigin</a></b> { TopLeft, Top, TopRight, Left, ..., BottomRight }</td></tr>
</table></div>
<a name="properties"></a>
<h2 id="properties">属性</h2>
<div class="table"><table class="propsummary">
<tr><td class="topAlign"><ul>
<li class="fn"><b><a href="qquickitem.html#activeFocus-prop">activeFocus</a></b> : const bool</li>
<li class="fn"><b><a href="qquickitem.html#activeFocusOnTab-prop">activeFocusOnTab</a></b> : bool</li>
<li class="fn"><b><a href="qquickitem.html#antialiasing-prop">antialiasing</a></b> : bool</li>
<li class="fn"><b><a href="qquickitem.html#baselineOffset-prop">baselineOffset</a></b> : qreal</li>
<li class="fn"><b><a href="qquickitem.html#childrenRect-prop">childrenRect</a></b> : const QRectF</li>
<li class="fn"><b><a href="qquickitem.html#clip-prop">clip</a></b> : bool</li>
<li class="fn"><b><a href="qquickitem.html#containmentMask-prop">containmentMask</a></b> : QObject*</li>
<li class="fn"><b><a href="qquickitem.html#enabled-prop">enabled</a></b> : bool</li>
<li class="fn"><b><a href="qquickitem.html#focus-prop">focus</a></b> : bool</li>
<li class="fn"><b><a href="qquickitem.html#height-prop">height</a></b> : qreal</li>
<li class="fn"><b><a href="qquickitem.html#implicitHeight-prop">implicitHeight</a></b> : qreal</li>
<li class="fn"><b><a href="qquickitem.html#implicitWidth-prop">implicitWidth</a></b> : qreal</li>
</ul></td><td class="topAlign"><ul>
<li class="fn"><b><a href="qquickitem.html#opacity-prop">opacity</a></b> : qreal</li>
<li class="fn"><b><a href="qquickitem.html#parent-prop">parent</a></b> : QQuickItem*</li>
<li class="fn"><b><a href="qquickitem.html#rotation-prop">rotation</a></b> : qreal</li>
<li class="fn"><b><a href="qquickitem.html#scale-prop">scale</a></b> : qreal</li>
<li class="fn"><b><a href="qquickitem.html#smooth-prop">smooth</a></b> : bool</li>
<li class="fn"><b><a href="qquickitem.html#state-prop">state</a></b> : QString</li>
<li class="fn"><b><a href="qquickitem.html#transformOrigin-prop">transformOrigin</a></b> : TransformOrigin</li>
<li class="fn"><b><a href="qquickitem.html#visible-prop">visible</a></b> : bool</li>
<li class="fn"><b><a href="qquickitem.html#width-prop">width</a></b> : qreal</li>
<li class="fn"><b><a href="qquickitem.html#x-prop">x</a></b> : qreal</li>
<li class="fn"><b><a href="qquickitem.html#y-prop">y</a></b> : qreal</li>
<li class="fn"><b><a href="qquickitem.html#z-prop">z</a></b> : qreal</li>
</ul>
</td></tr>
</table></div>
<ul>
<li class="fn">1 个属性继承自<a href="../qtcore/qobject.html#properties">QObject</a></li>
</ul>
<a name="public-functions"></a>
<h2 id="public-functions">公用函数</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#QQuickItem">QQuickItem</a></b>(QQuickItem *<i>parent</i> = nullptr)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#dtor.QQuickItem">~QQuickItem</a></b>() override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#acceptHoverEvents">acceptHoverEvents</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#acceptTouchEvents">acceptTouchEvents</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Qt::MouseButtons </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#acceptedMouseButtons">acceptedMouseButtons</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#activeFocusOnTab-prop">activeFocusOnTab</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#antialiasing-prop">antialiasing</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qreal </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#baselineOffset-prop">baselineOffset</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQuickItem *</td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#childAt">childAt</a></b>(qreal <i>x</i>, qreal <i>y</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;QQuickItem *&gt; </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#childItems">childItems</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRectF </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#childrenRect-prop">childrenRect</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#clip-prop">clip</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QObject *</td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#containmentMask-prop">containmentMask</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#contains">contains</a></b>(const QPointF &amp;<i>point</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCursor </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#cursor">cursor</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#filtersChildMouseEvents">filtersChildMouseEvents</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQuickItem::Flags </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#flags">flags</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#forceActiveFocus">forceActiveFocus</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#forceActiveFocus-1">forceActiveFocus</a></b>(Qt::FocusReason <i>reason</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#grabMouse">grabMouse</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSharedPointer&lt;QQuickItemGrabResult&gt; </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#grabToImage">grabToImage</a></b>(const QSize &amp;<i>targetSize</i> = QSize())</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#grabTouchPoints">grabTouchPoints</a></b>(const QVector&lt;int&gt; &amp;<i>ids</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#activeFocus-prop">hasActiveFocus</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#focus-prop">hasFocus</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qreal </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#height-prop">height</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qreal </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#implicitHeight-prop">implicitHeight</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qreal </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#implicitWidth">implicitWidth</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QVariant </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#inputMethodQuery">inputMethodQuery</a></b>(Qt::InputMethodQuery <i>query</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#isAncestorOf">isAncestorOf</a></b>(const QQuickItem *<i>child</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#enabled-prop">isEnabled</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#isFocusScope">isFocusScope</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#isTextureProvider">isTextureProvider</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#visible-prop">isVisible</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#keepMouseGrab">keepMouseGrab</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#keepTouchGrab">keepTouchGrab</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPointF </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#mapFromGlobal">mapFromGlobal</a></b>(const QPointF &amp;<i>point</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPointF </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#mapFromItem">mapFromItem</a></b>(const QQuickItem *<i>item</i>, const QPointF &amp;<i>point</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPointF </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#mapFromScene">mapFromScene</a></b>(const QPointF &amp;<i>point</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRectF </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#mapRectFromItem">mapRectFromItem</a></b>(const QQuickItem *<i>item</i>, const QRectF &amp;<i>rect</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRectF </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#mapRectFromScene">mapRectFromScene</a></b>(const QRectF &amp;<i>rect</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRectF </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#mapRectToItem">mapRectToItem</a></b>(const QQuickItem *<i>item</i>, const QRectF &amp;<i>rect</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRectF </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#mapRectToScene">mapRectToScene</a></b>(const QRectF &amp;<i>rect</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPointF </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#mapToGlobal">mapToGlobal</a></b>(const QPointF &amp;<i>point</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPointF </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#mapToItem">mapToItem</a></b>(const QQuickItem *<i>item</i>, const QPointF &amp;<i>point</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPointF </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#mapToScene">mapToScene</a></b>(const QPointF &amp;<i>point</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQuickItem *</td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#nextItemInFocusChain">nextItemInFocusChain</a></b>(bool <i>forward</i> = true)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qreal </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#opacity-prop">opacity</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQuickItem *</td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#parent-prop">parentItem</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#polish">polish</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#antialiasing-prop">resetAntialiasing</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#height-prop">resetHeight</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#width-prop">resetWidth</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qreal </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#rotation-prop">rotation</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qreal </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#scale-prop">scale</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQuickItem *</td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#scopedFocusItem">scopedFocusItem</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#setAcceptHoverEvents">setAcceptHoverEvents</a></b>(bool <i>enabled</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#setAcceptTouchEvents">setAcceptTouchEvents</a></b>(bool <i>enabled</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#setAcceptedMouseButtons">setAcceptedMouseButtons</a></b>(Qt::MouseButtons <i>buttons</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#activeFocusOnTab-prop">setActiveFocusOnTab</a></b>(<i>bool</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#antialiasing-prop">setAntialiasing</a></b>(<i>bool</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#baselineOffset-prop">setBaselineOffset</a></b>(<i>qreal</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#clip-prop">setClip</a></b>(<i>bool</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#containmentMask-prop">setContainmentMask</a></b>(QObject *<i>mask</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#setCursor">setCursor</a></b>(const QCursor &amp;<i>cursor</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#enabled-prop">setEnabled</a></b>(<i>bool</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#setFiltersChildMouseEvents">setFiltersChildMouseEvents</a></b>(bool <i>filter</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#setFlag">setFlag</a></b>(QQuickItem::Flag <i>flag</i>, bool <i>enabled</i> = true)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#setFlags">setFlags</a></b>(QQuickItem::Flags <i>flags</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#focus-prop">setFocus</a></b>(<i>bool</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#focus-prop">setFocus</a></b>(bool <i>focus</i>, Qt::FocusReason <i>reason</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#height-prop">setHeight</a></b>(<i>qreal</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#implicitHeight-prop">setImplicitHeight</a></b>(<i>qreal</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#implicitWidth-prop">setImplicitWidth</a></b>(<i>qreal</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#setKeepMouseGrab">setKeepMouseGrab</a></b>(bool <i>keep</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#setKeepTouchGrab">setKeepTouchGrab</a></b>(bool <i>keep</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#opacity-prop">setOpacity</a></b>(<i>qreal</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#parent-prop">setParentItem</a></b>(QQuickItem *<i>parent</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#rotation-prop">setRotation</a></b>(<i>qreal</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#scale-prop">setScale</a></b>(<i>qreal</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#setSize">setSize</a></b>(const QSizeF &amp;<i>size</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#smooth-prop">setSmooth</a></b>(<i>bool</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#state-prop">setState</a></b>(<i>const QString &amp;</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#transformOrigin-prop">setTransformOrigin</a></b>(<i>QQuickItem::TransformOrigin</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#visible-prop">setVisible</a></b>(<i>bool</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#width-prop">setWidth</a></b>(<i>qreal</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#x-prop">setX</a></b>(<i>qreal</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#y-prop">setY</a></b>(<i>qreal</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#z-prop">setZ</a></b>(<i>qreal</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSizeF </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#size">size</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#smooth-prop">smooth</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#stackAfter">stackAfter</a></b>(const QQuickItem *<i>sibling</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#stackBefore">stackBefore</a></b>(const QQuickItem *<i>sibling</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#state-prop">state</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QSGTextureProvider *</td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#textureProvider">textureProvider</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQuickItem::TransformOrigin </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#transformOrigin-prop">transformOrigin</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#ungrabMouse">ungrabMouse</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#ungrabTouchPoints">ungrabTouchPoints</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#unsetCursor">unsetCursor</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qreal </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#width-prop">width</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QQuickWindow *</td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#window">window</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qreal </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#x-prop">x</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qreal </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#y-prop">y</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qreal </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#z-prop">z</a></b>() const</td></tr>
</table></div>
<ul>
<li class="fn">31 个公用函数继承自<a href="../qtcore/qobject.html#public-functions">QObject</a></li>
<li class="fn">2 个公用函数继承自<a href="../qtqml/qqmlparserstatus.html#public-functions">QQmlParserStatus</a></li>
</ul>
<a name="public-slots"></a>
<h2 id="public-slots">公用槽函数</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#update">update</a></b>()</td></tr>
</table></div>
<ul>
<li class="fn">1 个公用槽函数继承自<a href="../qtcore/qobject.html#public-slots">QObject</a></li>
</ul>
<a name="signals"></a>
<h2 id="signals">信号</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#containmentMask-prop">containmentMaskChanged</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#windowChanged">windowChanged</a></b>(QQuickWindow *<i>window</i>)</td></tr>
</table></div>
<ul>
<li class="fn">2 个信号继承自<a href="../qtcore/qobject.html#signals">QObject</a></li>
</ul>
<a name="static-public-members"></a>
<h2 id="static-public-members">静态公用成员</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> const QMetaObject </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#staticMetaObject-var">staticMetaObject</a></b></td></tr>
</table></div>
<ul>
<li class="fn">9 个静态公用成员继承自<a href="../qtcore/qobject.html#static-public-members">QObject</a></li>
</ul>
<a name="protected-functions"></a>
<h2 id="protected-functions">保护函数</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#childMouseEventFilter">childMouseEventFilter</a></b>(QQuickItem *<i>item</i>, QEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#dragEnterEvent">dragEnterEvent</a></b>(QDragEnterEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#dragLeaveEvent">dragLeaveEvent</a></b>(QDragLeaveEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#dragMoveEvent">dragMoveEvent</a></b>(QDragMoveEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#dropEvent">dropEvent</a></b>(QDropEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#focusInEvent">focusInEvent</a></b>(<i>QFocusEvent *</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#focusOutEvent">focusOutEvent</a></b>(<i>QFocusEvent *</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#geometryChanged">geometryChanged</a></b>(const QRectF &amp;<i>newGeometry</i>, const QRectF &amp;<i>oldGeometry</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#heightValid">heightValid</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#hoverEnterEvent">hoverEnterEvent</a></b>(QHoverEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#hoverLeaveEvent">hoverLeaveEvent</a></b>(QHoverEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#hoverMoveEvent">hoverMoveEvent</a></b>(QHoverEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#inputMethodEvent">inputMethodEvent</a></b>(QInputMethodEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#isComponentComplete">isComponentComplete</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#itemChange">itemChange</a></b>(QQuickItem::ItemChange <i>change</i>, const QQuickItem::ItemChangeData &amp;<i>value</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#keyPressEvent">keyPressEvent</a></b>(QKeyEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#keyReleaseEvent">keyReleaseEvent</a></b>(QKeyEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#mouseDoubleClickEvent">mouseDoubleClickEvent</a></b>(QMouseEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#mouseMoveEvent">mouseMoveEvent</a></b>(QMouseEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#mousePressEvent">mousePressEvent</a></b>(QMouseEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#mouseReleaseEvent">mouseReleaseEvent</a></b>(QMouseEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#mouseUngrabEvent">mouseUngrabEvent</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#releaseResources">releaseResources</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#touchEvent">touchEvent</a></b>(QTouchEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#touchUngrabEvent">touchUngrabEvent</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#updateInputMethod">updateInputMethod</a></b>(Qt::InputMethodQueries <i>queries</i> = Qt::ImQueryInput)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QSGNode *</td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#updatePaintNode">updatePaintNode</a></b>(QSGNode *<i>oldNode</i>, QQuickItem::UpdatePaintNodeData *<i>updatePaintNodeData</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#updatePolish">updatePolish</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#wheelEvent">wheelEvent</a></b>(QWheelEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#widthValid">widthValid</a></b>() const</td></tr>
</table></div>
<a name="reimplemented-protected-functions"></a>
<h2 id="reimplemented-protected-functions">重新实现的保护函数</h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#classBegin">classBegin</a></b>() override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#componentComplete">componentComplete</a></b>() override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qquickitem.html#event">event</a></b>(QEvent *<i>ev</i>) override</td></tr>
</table></div>
<ul>
<li class="fn">9 个保护函数继承自<a href="../qtcore/qobject.html#protected-functions">QObject</a></li>
</ul>
<a name="details"></a>
<!-- $$$QQuickItem-description -->
<div class="descr">
<h2 id="details">详细信息</h2>
<p><a href="qquickitem.html">QQuickItem</a>类提供了<a href="qtquick-index.html">Qt Quick 模块</a>中最基本的可视化项。</p>
<p>Qt Quick 中的所有可视项都继承自<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html">QQuickItem</a>。虽然<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html">QQuickItem</a>实例没有视觉外观，但它定义了所有视觉项共有的属性，例如 x 和 y 位置、宽度和高度、<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qtquick-positioning-anchors.html">锚定</a>和键处理支持。</p>
<p>您可以将<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html">QQuickItem</a>子类化以提供您自己的继承这些功能的自定义可视项。</p>
<a name="custom-scene-graph-items"></a>
<h3 >自定义场景图项</h3>
<p>所有可视化 QML 项都使用场景图进行渲染，其默认实现是与 OpenGL 密切相关的低级高性能渲染堆栈。<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#Flag-enum">通过设置QQuickItem::ItemHasContents</a>标志并重新实现<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#updatePaintNode">QQuickItem::updatePaintNode</a> () 函数， <a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html">QQuickItem</a>的子类可以将自己的自定义内容添加到场景图中。<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#Flag-enum"></a><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#updatePaintNode"></a></p>
<p><b>警告：</b> OpenGL 操作和与场景图的交互仅发生在渲染线程上是至关重要的，主要是在<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#updatePaintNode">updatePaintNode</a> () 调用期间。最好的经验法则是只在<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#updatePaintNode">QQuickItem::updatePaintNode</a> () 函数中使用带有“QSG”前缀的类。</p>
<p><b>注意：</b>所有带有 QSG 前缀的类都应该只在场景图的渲染线程上使用。有关详细信息，请参阅<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qtquick-visualcanvas-scenegraph.html#scene-graph-and-rendering">场景图和渲染</a>。</p><a name="graphics-resource-handling"></a>
<h4 >图形资源处理</h4>
<p>处理场景图中使用的图形资源清理的首选方法是依靠节点的自动清理。从<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qsgnode.html">QQuickItem </a><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#updatePaintNode">::updatePaintNode</a> ()返回的QSGNode在正确的时间在正确的线程上自动删除。<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qsgnode.html">QSGNode</a>实例的树是通过使用默认设置的<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qsgnode.html#Flag-enum">QSGNode::OwnedByParent</a>来管理的。因此，对于大多数自定义场景图项，不需要额外的工作。</p>
<p>将图形资源存储在节点树之外的实现，例如实现<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#textureProvider">QQuickItem::textureProvider</a> () 的项，需要注意根据项在 QML 中的使用方式正确清理它。需要处理的情况有：</p>
<ul>
<li>场景图失效；例如，如果使用<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtgui/qwindow.html#hide">QQuickWindow::hide</a> () 隐藏窗口，就会发生这种情况。如果 item 类实现了<code>slot</code>named <code>invalidateSceneGraph()</code>，则在 GUI 线程被阻塞时，将在渲染线程上调用此插槽。这相当于连接到<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickwindow.html#sceneGraphInvalidated">QQuickWindow::sceneGraphInvalidated</a> ()。调用此插槽时，将绑定此项窗口的 OpenGL 上下文。唯一的例外是，如果原生 OpenGL 已在 Qt 的控制之外被破坏，例如通过<code>EGL_CONTEXT_LOST</code>.</li>
<li>该项已从场景中移除；如果一个项被带出场景，例如因为它的父项被设置为<code>null</code>或另一个窗口中的项，<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#releaseResources">QQuickItem::releaseResources</a> () 将在 GUI 线程上调用。<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickwindow.html#scheduleRenderJob">QQuickWindow::scheduleRenderJob</a> () 应该用于调度渲染资源的清理。</li>
<li>该项被删除；当一个项运行时的析构函数，它应该删除它拥有的所有图形资源。如果以上两个条件都没有满足，则该项将成为窗口的一部分，并且可以使用<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickwindow.html#scheduleRenderJob">QQuickWindow::scheduleRenderJob</a> () 来清理它们。如果实现忽略了对<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#releaseResources">QQuickItem::releaseResources</a> () 的调用，则在许多情况下，该项将不再有权访问<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickwindow.html">QQuickWindow</a>，因此无法调度清理。</li>
</ul>
<p>当调度清理图形资源使用<a href="qquickwindow.html#scheduleRenderJob">QQuickWindow::scheduleRenderJob</a>()，一个应该使用<a href="qquickwindow.html#RenderStage-enum">QQuickWindow::BeforeSynchronizingStage</a>或<a href="qquickwindow.html#RenderStage-enum">QQuickWindow::AfterSynchronizingStage</a>。<a href="qtquick-visualcanvas-scenegraph.html#scene-graph-and-rendering">同步阶段</a>是由于对QML树的更改而更改场景图的阶段。如果清理被安排在其他时间，它可能会导致场景图的其他部分引用新删除的对象，因为这些部分还没有更新。</p>
<p><b>注意：</b>不建议使用<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtcore/qobject.html#deleteLater">QObject::deleteLater</a>() 来清理图形资源，因为它会在任意时间运行，并且在删除发生时是否会绑定 OpenGL 上下文是未知的。</p><a name="custom-qpainter-items"></a>
<h3 >自定义 QPainter 项</h3>
<p>QQuickItem提供了一个子类<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickpainteditem.html">QQuickPaintedItem </a><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html">，</a>它允许用户使用<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtgui/qpainter.html">QPainter</a>渲染内容。<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickpainteditem.html"></a><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtgui/qpainter.html"></a></p>
<p><b>警告：</b>使用<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickpainteditem.html">QQuickPaintedItem</a>使用间接 2D 表面来渲染其内容，使用软件光栅化或使用 OpenGL 帧缓冲区对象 (FBO)，因此渲染是一个两步操作。首先栅格化表面，然后绘制表面。直接使用场景图 API 总是要快得多。</p>
<a name="behavior-animations"></a>
<h3 >行为动画</h3>
<p>如果您的 Item 使用<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qml-qtquick-behavior.html">Behavior</a>类型来定义属性更改的动画，则当您需要从 C++ 修改这些属性时，您应该始终使用<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtcore/qobject.html#setProperty">QObject::setProperty</a> ()、QQmlProperty() 或<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtcore/qmetaproperty.html#write">QMetaProperty::write ()。</a>这确保 QML 引擎知道属性更改。否则，引擎将无法执行您请求的动画。请注意，这些函数会导致轻微的性能损失。有关更多详细信息，请参阅<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtqml/qtqml-cppintegration-interactqmlfromcpp.html#accessing-members-of-a-qml-object-type-from-c">从 C++ 访问 QML 对象类型的成章节</a>。</p>
</div>
<p><b>请参考 </b><a href="qquickwindow.html">QQuickWindow</a> 和 <a href="qquickpainteditem.html">QQuickPaintedItem</a>。</p>
<!-- @@@QQuickItem -->
<div class="types">
<h2>成员类型文档</h2>
<!-- $$$Flag$$$ItemClipsChildrenToShape$$$ItemAcceptsInputMethod$$$ItemIsFocusScope$$$ItemHasContents$$$ItemAcceptsDrops -->
<h3 class="flags" id="Flag-enum"><a name="Flag-enum"></a>enum QQuickItem::<span class="name">Flag</span><br/>flags QQuickItem::<span class="name">Flags</span></h3>
<p>此枚举类型用于指定各种项属性。</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">常量</th><th class="tblval">值</th><th class="tbldscr">描述</th></tr>
<tr><td class="topAlign"><code>QQuickItem::ItemClipsChildrenToShape</code></td><td class="topAlign tblval"><code>0x01</code></td><td class="topAlign">
	指示此项应在视觉上剪辑其子项，以便它们仅在此项的边界内渲染。</td></tr>
<tr><td class="topAlign"><code>QQuickItem::ItemAcceptsInputMethod</code></td><td class="topAlign tblval"><code>0x02</code></td><td class="topAlign">表示该项支持文本输入法。</td></tr>
<tr><td class="topAlign"><code>QQuickItem::ItemIsFocusScope</code></td><td class="topAlign tblval"><code>0x04</code></td><td class="topAlign">指示该项是焦点范围。有关详细信息，请参阅<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qtquick-input-focus.html">Qt Quick 中的键盘焦点</a>。</td></tr>
<tr><td class="topAlign"><code>QQuickItem::ItemHasContents</code></td><td class="topAlign tblval"><code>0x08</code></td><td class="topAlign">指示项具有可视内容，应由场景图渲染。</td></tr>
<tr><td class="topAlign"><code>QQuickItem::ItemAcceptsDrops</code></td><td class="topAlign tblval"><code>0x10</code></td><td class="topAlign">指示项接受拖放事件。</td></tr>
</table></div>
<p>Flags 类型是<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtcore/qflags.html">QFlags</a> &lt;Flag&gt; 的 typedef。它存储标志值的 OR 组合。</p>
<p><b>请参考 </b><a href="qquickitem.html#setFlag">setFlag</a>(), <a href="qquickitem.html#setFlags">setFlags</a>(), 和 <a href="qquickitem.html#flags">flags</a>()。</p>
<!-- @@@Flag -->
<!-- $$$ItemChange$$$ItemChildAddedChange$$$ItemChildRemovedChange$$$ItemSceneChange$$$ItemVisibleHasChanged$$$ItemParentHasChanged$$$ItemOpacityHasChanged$$$ItemActiveFocusHasChanged$$$ItemRotationHasChanged$$$ItemAntialiasingHasChanged$$$ItemDevicePixelRatioHasChanged$$$ItemEnabledHasChanged -->
<h3 class="fn" id="ItemChange-enum"><a name="ItemChange-enum"></a>enum QQuickItem::<span class="name">ItemChange</span></h3>
<p>与<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#itemChange">QQuickItem::itemChange</a> () 一起使用以通知项有关某些类型的更改。</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">
	常量</th><th class="tblval">值</th><th class="tbldscr">描述</th></tr>
<tr><td class="topAlign"><code>QQuickItem::ItemChildAddedChange</code></td><td class="topAlign tblval"><code>0</code></td><td class="topAlign">添加了一个孩子。<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem-itemchangedata.html#item-var">ItemChangeData::item</a>包含添加的子项。</td></tr>
<tr><td class="topAlign"><code>QQuickItem::ItemChildRemovedChange</code></td><td class="topAlign tblval"><code>1</code></td><td class="topAlign">一个孩子被删除了。<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem-itemchangedata.html#item-var">ItemChangeData::item</a>包含已删除的子项。</td></tr>
<tr><td class="topAlign"><code>QQuickItem::ItemSceneChange</code></td><td class="topAlign tblval"><code>2</code></td><td class="topAlign">该项已添加到场景中或从场景中移除。渲染场景的<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickwindow.html">QQuickWindow使用</a><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem-itemchangedata.html#window-var">ItemChangeData::window</a>指定。当项从场景中移除时，window 参数为空。</td></tr>
<tr><td class="topAlign"><code>QQuickItem::ItemVisibleHasChanged</code></td><td class="topAlign tblval"><code>3</code></td><td class="topAlign">该项的可见性已更改。<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem-itemchangedata.html#boolValue-var">ItemChangeData::boolValue</a>包含新的可见性。</td></tr>
<tr><td class="topAlign"><code>QQuickItem::ItemParentHasChanged</code></td><td class="topAlign tblval"><code>4</code></td><td class="topAlign">项的父项已更改。<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem-itemchangedata.html#item-var">ItemChangeData::item</a>包含新的父项。</td></tr>
<tr><td class="topAlign"><code>QQuickItem::ItemOpacityHasChanged</code></td><td class="topAlign tblval"><code>5</code></td><td class="topAlign">项的不透明度已更改。<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem-itemchangedata.html#realValue-var">ItemChangeData::realValue</a>包含新的不透明度。</td></tr>
<tr><td class="topAlign"><code>QQuickItem::ItemActiveFocusHasChanged</code></td><td class="topAlign tblval"><code>6</code></td><td class="topAlign">该项的焦点已更改。<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem-itemchangedata.html#boolValue-var">ItemChangeData::boolValue</a>包含项是否有焦点。</td></tr>
<tr><td class="topAlign"><code>QQuickItem::ItemRotationHasChanged</code></td><td class="topAlign tblval"><code>7</code></td><td class="topAlign">物品的旋转发生了变化。<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem-itemchangedata.html#realValue-var">ItemChangeData::realValue</a>包含新的旋转。</td></tr>
<tr><td class="topAlign"><code>QQuickItem::ItemDevicePixelRatioHasChanged</code></td><td class="topAlign tblval"><code>9</code></td><td class="topAlign">该项所在屏幕的设备像素比已更改。ItemChangedData::realValue 包含新的设备像素比率。</td></tr>
<tr><td class="topAlign"><code>QQuickItem::ItemAntialiasingHasChanged</code></td><td class="topAlign tblval"><code>8</code></td><td class="topAlign">抗锯齿已更改。当前（布尔）值可以在<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#antialiasing-prop">QQuickItem::antialiasing</a>中找到。</td></tr>
<tr><td class="topAlign"><code>QQuickItem::ItemEnabledHasChanged</code></td><td class="topAlign tblval"><code>10</code></td><td class="topAlign">该项的启用状态已更改。<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem-itemchangedata.html#boolValue-var">ItemChangeData::boolValue</a>包含新的启用状态。（自 Qt 5.10 起）</td></tr>
</table></div>
<!-- @@@ItemChange -->
<!-- $$$TransformOrigin$$$TopLeft$$$Top$$$TopRight$$$Left$$$Center$$$Right$$$BottomLeft$$$Bottom$$$BottomRight -->
<h3 class="fn" id="TransformOrigin-enum"><a name="TransformOrigin-enum"></a>enum QQuickItem::<span class="name">TransformOrigin</span></h3>
<p>控制应用比例等简单变换的点。</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">常量</th><th class="tblval">值</th><th class="tbldscr">描述</th></tr>
<tr><td class="topAlign"><code>QQuickItem::TopLeft</code></td><td class="topAlign tblval"><code>0</code></td><td class="topAlign">项的左上角。</td></tr>
<tr><td class="topAlign"><code>QQuickItem::Top</code></td><td class="topAlign tblval"><code>1</code></td><td class="topAlign">项顶部的中心点。</td></tr>
<tr><td class="topAlign"><code>QQuickItem::TopRight</code></td><td class="topAlign tblval"><code>2</code></td><td class="topAlign">项顶部的中心点。</td></tr>
<tr><td class="topAlign"><code>QQuickItem::Left</code></td><td class="topAlign tblval"><code>3</code></td><td class="topAlign">垂直中间最左边的点。</td></tr>
<tr><td class="topAlign"><code>QQuickItem::Center</code></td><td class="topAlign tblval"><code>4</code></td><td class="topAlign">项的中心。</td></tr>
<tr><td class="topAlign"><code>QQuickItem::Right</code></td><td class="topAlign tblval"><code>5</code></td><td class="topAlign">垂直中间的最右边点。</td></tr>
<tr><td class="topAlign"><code>QQuickItem::BottomLeft</code></td><td class="topAlign tblval"><code>6</code></td><td class="topAlign">项的左下角。</td></tr>
<tr><td class="topAlign"><code>QQuickItem::Bottom</code></td><td class="topAlign tblval"><code>7</code></td><td class="topAlign">项底部的中心点。</td></tr>
<tr><td class="topAlign"><code>QQuickItem::BottomRight</code></td><td class="topAlign tblval"><code>8</code></td><td class="topAlign">项的右下角。</td></tr>
</table></div>
<p><b>请参考 </b><a href="qquickitem.html#transformOrigin-prop">transformOrigin</a>() 和 <a href="qquickitem.html#transformOrigin-prop">setTransformOrigin</a>()。</p>
<!-- @@@TransformOrigin -->
</div>
<div class="prop">
<h2>属性文档</h2>
<!-- $$$activeFocus-prop$$$hasActiveFocus -->
<h3 class="fn" id="activeFocus-prop"><a name="activeFocus-prop"></a><span class="name">activeFocus</span> : const <span class="type">bool</span></h3>
<p>此只读属性指示项是否具有活动焦点。</p>
<p>如果 activeFocus 为 true，则此项是当前接收键盘输入的项，或者是当前接收键盘输入的项的<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qml-qtquick-focusscope.html">FocusScope</a>祖先。</p>
<p>通常，通过将<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#focus-prop">焦点</a>设置在项及其封闭的<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qml-qtquick-focusscope.html">FocusScope</a>对象上来获得 activeFocus。在以下示例中，<code>input</code>and<code>focusScope</code>对象将具有活动焦点，而根矩形对象则不会。</p>
<pre class="qml">

  import QtQuick 2.0

  <span class="type"><a href="qml-qtquick-rectangle.html">Rectangle</a></span> {
      <span class="name">width</span>: <span class="number">100</span>; <span class="name">height</span>: <span class="number">100</span>

      <span class="type"><a href="qml-qtquick-focusscope.html">FocusScope</a></span> {
          <span class="name">focus</span>: <span class="number">true</span>

          <span class="type"><a href="qml-qtquick-textinput.html">TextInput</a></span> {
              <span class="name">id</span>: <span class="name">input</span>
              <span class="name">focus</span>: <span class="number">true</span>
          }
      }
  }

</pre>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><span class="name"><b>hasActiveFocus</b></span>() const</td></tr>
</table></div>
<p><b>请参考 </b><a href="qquickitem.html#focus-prop">焦点</a> 和 <a href="qtquick-input-focus.html">Qt Quick中的键盘焦点</a>。</p>
<!-- @@@activeFocus -->
<!-- $$$activeFocusOnTab-prop$$$activeFocusOnTab$$$setActiveFocusOnTabbool -->
<h3 class="fn" id="activeFocusOnTab-prop"><a name="activeFocusOnTab-prop"></a><span class="name">activeFocusOnTab</span> : <span class="type">bool</span></h3>
<p>

此属性保存项是否要位于选项卡焦点链中。默认情况下，此设置为<code>false</code>。</p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><span class="name"><b>activeFocusOnTab</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setActiveFocusOnTab</b></span>(<i>bool</i>)</td></tr>
</table></div>
<!-- @@@activeFocusOnTab -->
<!-- $$$antialiasing-prop$$$antialiasing$$$setAntialiasingbool$$$resetAntialiasing -->
<h3 class="fn" id="antialiasing-prop"><a name="antialiasing-prop"></a><span class="name">antialiasing</span> : <span class="type">bool</span></h3>
<p>

指定项是否抗锯齿</p>
<p>

由视觉元素用来决定项是否应该使用抗锯齿。在某些情况下，具有抗锯齿功能的项需要更多内存并且渲染速度可能较慢（有关详细信息，请参阅<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qtquick-visualcanvas-scenegraph-renderer.html#antialiasing">抗锯齿）。</a></p>
<p>

默认值为 false，但可能会被派生元素覆盖。</p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><span class="name"><b>antialiasing</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setAntialiasing</b></span>(<i>bool</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>resetAntialiasing</b></span>()</td></tr>
</table></div>
<!-- @@@antialiasing -->
<!-- $$$baselineOffset-prop$$$baselineOffset$$$setBaselineOffsetqreal -->
<h3 class="fn" id="baselineOffset-prop"><a name="baselineOffset-prop"></a><span class="name">baselineOffset</span> : <span class="type"><a href="../qtcore/qtglobal.html#qreal-typedef">qreal</a></span></h3>
<p>

指定项基线在本地坐标中的位置。</p>
<p>

<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qml-qtquick-text.html">文本</a>项的基线是文本所在的假想线。包含文本的控件通常将其基线设置为其文本的基线。</p>
<p>

对于非文本项，使用默认的基线偏移量 0。</p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> qreal </td><td class="memItemRight bottomAlign"><span class="name"><b>baselineOffset</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setBaselineOffset</b></span>(<i>qreal</i>)</td></tr>
</table></div>
<!-- @@@baselineOffset -->
<!-- $$$childrenRect-prop$$$childrenRect -->
<h3 class="fn" id="childrenRect-prop"><a name="childrenRect-prop"></a><span class="name">childrenRect</span> : const <span class="type"><a href="../qtcore/qrectf.html">QRectF</a></span></h3>
<p>
此属性保存项子项的集体位置和大小。</p>
<p>

如果您需要访问项的子项的集体几何图形以正确调整项的大小，则此属性很有用。</p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> QRectF </td><td class="memItemRight bottomAlign"><span class="name"><b>childrenRect</b></span>()</td></tr>
</table></div>
<!-- @@@childrenRect -->
<!-- $$$clip-prop$$$clip$$$setClipbool -->
<h3 class="fn" id="clip-prop"><a name="clip-prop"></a><span class="name">clip</span> : <span class="type">bool</span></h3>
<p>

此属性保存是否启用剪辑。默认剪辑值为<code>false</code>。</p>
<p>

如果启用了剪辑，则项会将其自己的绘画以及其子项的绘画剪辑到其边界矩形。如果在项的绘制操作期间设置剪辑，请记住重新设置它以防止剪辑场景的其余部分。</p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><span class="name"><b>clip</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setClip</b></span>(<i>bool</i>)</td></tr>
</table></div>
<!-- @@@clip -->
<!-- $$$containmentMask-prop$$$containmentMask$$$setContainmentMaskQObject*$$$containmentMaskChanged -->
<h3 class="fn" id="containmentMask-prop"><a name="containmentMask-prop"></a><span class="name">containmentMask</span> : <span class="type"><a href="../qtcore/qobject.html#QObject">QObject</a></span>*</h3>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> QObject *</td><td class="memItemRight bottomAlign"><span class="name"><b>containmentMask</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setContainmentMask</b></span>(QObject *<i>mask</i>)</td></tr>
</table></div>
<p><b>通知信号:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>containmentMaskChanged</b></span>()</td></tr>
</table></div>
<!-- @@@containmentMask -->
<!-- $$$enabled-prop$$$isEnabled$$$setEnabledbool -->
<h3 class="fn" id="enabled-prop"><a name="enabled-prop"></a><span class="name">enabled</span> : <span class="type">bool</span></h3>
<p>

此属性保存项是否接收鼠标和键盘事件。默认情况下这是真的。</p>
<p>设置此属性将直接影响子项的<code>enabled</code> 值。当设置为false时，所有子项的<code>enabled</code> 值也变为<code>false</code>。当设置为true时，子项的<code>enabled</code> 
值将返回<code>true</code>，除非它们被显式地设置为<code>false</code>。</p>
<p>

将此属性设置为<code>false</code>自动会导致<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#activeFocus-prop">activeFocus</a>设置为<code>false</code>，并且该项将不再接收键盘事件。</p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><span class="name"><b>isEnabled</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setEnabled</b></span>(<i>bool</i>)</td></tr>
</table></div>
<p><b>请参考 </b><a href="qquickitem.html#visible-prop">visible</a>。</p>
<!-- @@@enabled -->
<!-- $$$focus-prop$$$hasFocus$$$setFocusbool$$$setFocusboolQt::FocusReason -->
<h3 class="fn" id="focus-prop"><a name="focus-prop"></a><span class="name">focus</span> : <span class="type">bool</span></h3>
<p>

此属性保存项是否在封闭的<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qml-qtquick-focusscope.html">FocusScope</a>内具有焦点。<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qml-qtquick-focusscope.html">如果为 true，则当封闭的FocusScope</a>获得活动焦点时，此项将获得活动焦点。</p>
<p>

在以下示例中，当获得主动<code>input</code>焦点时将<code>scope</code>获得主动焦点：</p>
<pre class="qml">

  import QtQuick 2.0

  <span class="type"><a href="qml-qtquick-rectangle.html">Rectangle</a></span> {
      <span class="name">width</span>: <span class="number">100</span>; <span class="name">height</span>: <span class="number">100</span>

      <span class="type"><a href="qml-qtquick-focusscope.html">FocusScope</a></span> {
          <span class="name">id</span>: <span class="name">scope</span>

          <span class="type"><a href="qml-qtquick-textinput.html">TextInput</a></span> {
              <span class="name">id</span>: <span class="name">input</span>
              <span class="name">focus</span>: <span class="number">true</span>
          }
      }
  }

</pre>
<p>

出于此属性的目的，假设整个场景就像一个焦点范围。在实践层面上，这意味着以下 QML 将积极关注<code>input</code>启动。</p>
<pre class="qml">

  <span class="type"><a href="qml-qtquick-rectangle.html">Rectangle</a></span> {
      <span class="name">width</span>: <span class="number">100</span>; <span class="name">height</span>: <span class="number">100</span>

      <span class="type"><a href="qml-qtquick-textinput.html">TextInput</a></span> {
            <span class="name">id</span>: <span class="name">input</span>
            <span class="name">focus</span>: <span class="number">true</span>
      }
  }

</pre>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><span class="name"><b>hasFocus</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setFocus</b></span>(<i>bool</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setFocus</b></span>(bool <i>focus</i>, Qt::FocusReason <i>reason</i>)</td></tr>
</table></div>
<p><b>请参考 </b><a href="qquickitem.html#activeFocus-prop">activeFocus</a> 和 <a href="qtquick-input-focus.html">Qt Quick中的键盘焦点</a>。</p>
<!-- @@@focus -->
<!-- $$$height-prop$$$height$$$setHeightqreal$$$resetHeight -->
<h3 class="fn" id="height-prop"><a name="height-prop"></a><span class="name">height</span> : <span class="type"><a href="../qtcore/qtglobal.html#qreal-typedef">qreal</a></span></h3>
<p>此属性保存此项的高度。</p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> qreal </td><td class="memItemRight bottomAlign"><span class="name"><b>height</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setHeight</b></span>(<i>qreal</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>resetHeight</b></span>()</td></tr>
</table></div>
<!-- @@@height -->
<!-- $$$opacity-prop$$$opacity$$$setOpacityqreal -->
<h3 class="fn" id="opacity-prop"><a name="opacity-prop"></a><span class="name">opacity</span> : <span class="type"><a href="../qtcore/qtglobal.html#qreal-typedef">qreal</a></span></h3>
<p>

此属性保存项的不透明度。不透明度指定为介于 0.0（完全透明）和 1.0（完全不透明）之间的数字。默认值为 1.0。</p>
<p>

设置此属性时，指定的不透明度也将单独应用于子项。在某些情况下，这可能会产生意想不到的影响。例如，在下面的第二组矩形中，红色矩形指定的不透明度为 0.5，这会影响其蓝色子矩形的不透明度，即使子矩形没有指定不透明度。</p>
<p>

超出 0 到 1 范围的值将被限制。</p>
<div class="table"><table class="generic">
 <tr valign="top" class="odd"><td ><p class="centerAlign"><img src="images/declarative-item_opacity1.png" alt="" /></p></td><td ><pre class="qml">

  <span class="type"><a href="qml-qtquick-item.html">Item</a></span> {
      <span class="type"><a href="qml-qtquick-rectangle.html">Rectangle</a></span> {
          <span class="name">color</span>: <span class="string">&quot;red&quot;</span>
          <span class="name">width</span>: <span class="number">100</span>; <span class="name">height</span>: <span class="number">100</span>
          <span class="type"><a href="qml-qtquick-rectangle.html">Rectangle</a></span> {
              <span class="name">color</span>: <span class="string">&quot;blue&quot;</span>
              <span class="name">x</span>: <span class="number">50</span>; <span class="name">y</span>: <span class="number">50</span>; <span class="name">width</span>: <span class="number">100</span>; <span class="name">height</span>: <span class="number">100</span>
          }
      }
  }

</pre>
</td></tr>
<tr valign="top" class="even"><td ><p class="centerAlign"><img src="images/declarative-item_opacity2.png" alt="" /></p></td><td ><pre class="qml">

  <span class="type"><a href="qml-qtquick-item.html">Item</a></span> {
      <span class="type"><a href="qml-qtquick-rectangle.html">Rectangle</a></span> {
          <span class="name">opacity</span>: <span class="number">0.5</span>
          <span class="name">color</span>: <span class="string">&quot;red&quot;</span>
          <span class="name">width</span>: <span class="number">100</span>; <span class="name">height</span>: <span class="number">100</span>
          <span class="type"><a href="qml-qtquick-rectangle.html">Rectangle</a></span> {
              <span class="name">color</span>: <span class="string">&quot;blue&quot;</span>
              <span class="name">x</span>: <span class="number">50</span>; <span class="name">y</span>: <span class="number">50</span>; <span class="name">width</span>: <span class="number">100</span>; <span class="name">height</span>: <span class="number">100</span>
          }
      }
  }

</pre>
</td></tr>
</table></div>
<p>

更改项的不透明度不会影响项是否接收用户输入事件。（相反，设置<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#visible-prop">visible</a>属性以<code>false</code>停止鼠标事件，设置<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#enabled-prop">enabled</a>属性以<code>false</code>停止鼠标和键盘事件，并从项中移除活动焦点。）</p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> qreal </td><td class="memItemRight bottomAlign"><span class="name"><b>opacity</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setOpacity</b></span>(<i>qreal</i>)</td></tr>
</table></div>
<p><b>请参考 </b><a href="qquickitem.html#visible-prop">visible</a>。</p>
<!-- @@@opacity -->
<!-- $$$parent-prop$$$parentItem$$$setParentItemQQuickItem* -->
<h3 class="fn" id="parent-prop"><a name="parent-prop"></a><span class="name">parent</span> : <span class="type"><a href="qquickitem.html#QQuickItem">QQuickItem</a></span>*</h3>
<p>

此属性保存项的可视父项。</p>
<p>

<b>注意：</b><i>visual parent</i>的概念与<i><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtcore/qobject.html">QObject</a> parent</i>的概念不同。项的视觉父项不一定与其对象父项相同。有关更多详细信息，请参阅<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qtquick-visualcanvas-visualparent.html">概念 - Qt Quick 中的可视父级。</a></p><p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> QQuickItem *</td><td class="memItemRight bottomAlign"><span class="name"><b>parentItem</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setParentItem</b></span>(QQuickItem *<i>parent</i>)</td></tr>
</table></div>
<!-- @@@parent -->
<!-- $$$rotation-prop$$$rotation$$$setRotationqreal -->
<h3 class="fn" id="rotation-prop"><a name="rotation-prop"></a><span class="name">rotation</span> : <span class="type"><a href="../qtcore/qtglobal.html#qreal-typedef">qreal</a></span></h3>
<p>

此属性保存项围绕其<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#transformOrigin-prop">transformOrigin</a>顺时针旋转的度数。</p>
<p>

默认值为 0 度（即不旋转）。</p>
<div class="table"><table class="generic">
 <tr valign="top" class="odd"><td ><p class="centerAlign"><img src="images/declarative-rotation.png" alt="" /></p></td><td ><pre class="qml">

  <span class="type"><a href="qml-qtquick-rectangle.html">Rectangle</a></span> {
      <span class="name">color</span>: <span class="string">&quot;blue&quot;</span>
      <span class="name">width</span>: <span class="number">100</span>; <span class="name">height</span>: <span class="number">100</span>
      <span class="type"><a href="qml-qtquick-rectangle.html">Rectangle</a></span> {
          <span class="name">color</span>: <span class="string">&quot;red&quot;</span>
          <span class="name">x</span>: <span class="number">25</span>; <span class="name">y</span>: <span class="number">25</span>; <span class="name">width</span>: <span class="number">50</span>; <span class="name">height</span>: <span class="number">50</span>
          <span class="name">rotation</span>: <span class="number">30</span>
      }
  }

</pre>
</td></tr>
</table></div>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> qreal </td><td class="memItemRight bottomAlign"><span class="name"><b>rotation</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setRotation</b></span>(<i>qreal</i>)</td></tr>
</table></div>
<p><b>请参考 </b><a href="qml-qtquick-transform.html">Transform</a> 和 <a href="qml-qtquick-rotation.html">Rotation</a>。</p>
<!-- @@@rotation -->
<!-- $$$scale-prop$$$scale$$$setScaleqreal -->
<h3 class="fn" id="scale-prop"><a name="scale-prop"></a><span class="name">scale</span> : <span class="type"><a href="../qtcore/qtglobal.html#qreal-typedef">qreal</a></span></h3>
<p>

此属性保存此项的比例因子。</p>
<p>

小于 1.0 的比例会导致以较小的尺寸渲染项，而大于 1.0 的比例会以较大的尺寸渲染项。负比例会导致项在渲染时被镜像。</p>
<p>

默认值为 1.0。</p>
<p>

从<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#transformOrigin-prop">transformOrigin</a>应用缩放。</p>
<div class="table"><table class="generic">
 <tr valign="top" class="odd"><td ><p class="centerAlign"><img src="images/declarative-scale.png" alt="" /></p></td><td ><pre class="qml">

  import QtQuick 2.0

  <span class="type"><a href="qml-qtquick-rectangle.html">Rectangle</a></span> {
      <span class="name">color</span>: <span class="string">&quot;blue&quot;</span>
      <span class="name">width</span>: <span class="number">100</span>; <span class="name">height</span>: <span class="number">100</span>

      <span class="type"><a href="qml-qtquick-rectangle.html">Rectangle</a></span> {
          <span class="name">color</span>: <span class="string">&quot;green&quot;</span>
          <span class="name">width</span>: <span class="number">25</span>; <span class="name">height</span>: <span class="number">25</span>
      }

      <span class="type"><a href="qml-qtquick-rectangle.html">Rectangle</a></span> {
          <span class="name">color</span>: <span class="string">&quot;red&quot;</span>
          <span class="name">x</span>: <span class="number">25</span>; <span class="name">y</span>: <span class="number">25</span>; <span class="name">width</span>: <span class="number">50</span>; <span class="name">height</span>: <span class="number">50</span>
          <span class="name">scale</span>: <span class="number">1.4</span>
      }
  }

</pre>
</td></tr>
</table></div>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> qreal </td><td class="memItemRight bottomAlign"><span class="name"><b>scale</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setScale</b></span>(<i>qreal</i>)</td></tr>
</table></div>
<p><b>请参考 </b><a href="qml-qtquick-transform.html">Transform</a> 和 <a href="qml-qtquick-scale.html">Scale</a>。</p>
<!-- @@@scale -->
<!-- $$$smooth-prop$$$smooth$$$setSmoothbool -->
<h3 class="fn" id="smooth-prop"><a name="smooth-prop"></a><span class="name">smooth</span> : <span class="type">bool</span></h3>
<p>

指定项是否平滑</p>
<p>

主要用于基于图像的项，以决定项是否应该使用平滑采样。平滑采样使用线性插值执行，而非平滑采样使用最近邻执行。</p>
<p>

在 Qt Quick 2.0 中，此属性对性能的影响很小。</p>
<p>

默认情况下，此属性设置为<code>true</code>。</p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><span class="name"><b>smooth</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setSmooth</b></span>(<i>bool</i>)</td></tr>
</table></div>
<!-- @@@smooth -->
<!-- $$$state-prop$$$state$$$setStateconstQString& -->
<h3 class="fn" id="state-prop"><a name="state-prop"></a><span class="name">state</span> : <span class="type"><a href="../qtcore/qstring.html">QString</a></span></h3>
<p>

此属性保存项当前状态的名称。</p>
<p>

如果项处于其默认状态，即未设置显式状态，则此属性包含一个空字符串。同样，您可以通过将此属性设置为空字符串来将项返回到其默认状态。</p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> QString </td><td class="memItemRight bottomAlign"><span class="name"><b>state</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setState</b></span>(<i>const QString &amp;</i>)</td></tr>
</table></div>
<p><b>请参考 </b><a href="qtquick-statesanimations-states.html">Qt Quick
状态</a>。</p>
<!-- @@@state -->
<!-- $$$transformOrigin-prop$$$transformOrigin$$$setTransformOriginQQuickItem::TransformOrigin -->
<h3 class="fn" id="transformOrigin-prop"><a name="transformOrigin-prop"></a><span class="name">transformOrigin</span> : <span class="type"><a href="qquickitem.html#TransformOrigin-enum">TransformOrigin</a></span></h3>
<p>

此属性保存缩放和旋转变换所围绕的原点。</p>
<p>

有九个变换原点可用，如下图所示。默认变换原点是<code>Item.Center</code>.</p>
<p class="centerAlign"><img src="images/declarative-transformorigin.png" alt="" /></p><p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> QQuickItem::TransformOrigin </td><td class="memItemRight bottomAlign"><span class="name"><b>transformOrigin</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setTransformOrigin</b></span>(<i>QQuickItem::TransformOrigin</i>)</td></tr>
</table></div>
<!-- @@@transformOrigin -->
<!-- $$$visible-prop$$$isVisible$$$setVisiblebool -->
<h3 class="fn" id="visible-prop"><a name="visible-prop"></a><span class="name">visible</span> : <span class="type">bool</span></h3>
<p>

此属性保存项是否可见。默认情况下这是真的。</p>
<p>设置此属性将直接影响子项的<code>visible</code>值。当设置为<code>false</code>时，所有子项的<code>visible</code>值也变为<code>false</code>。当设置为<code>true</code>时，子项的<code>visible</code> 
值将返回<code>true</code>，除非它们被显式地设置为<code>false</code>。</p>
<p>

（由于这种流动行为，<code>visible</code>如果属性绑定应该只响应显式属性更改，则使用该属性可能不会产生预期的效果。在这种情况下，使用<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qtquick-effects-topic.html#opacity">opacity</a>属性可能会更好。）</p>
<p>

如果此属性设置为<code>false</code>，则该项将不再接收鼠标事件，但将继续接收按键事件，并且如果已设置，将保留键盘<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#focus-prop">焦点。</a>（相反，将<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#enabled-prop">enabled</a>属性设置为<code>false</code>停止鼠标和键盘事件，并从项中移除焦点。）</p>
<p><b>注意:</b>此属性的值仅受此属性或父属性可见属性更改的影响。例如，如果这个项移出屏幕，或者<a href="qtquick-effects-topic.html#opacity">不透明度</a>变为0，那么它不会改变。</p><p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><span class="name"><b>isVisible</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setVisible</b></span>(<i>bool</i>)</td></tr>
</table></div>
<p><b>请参考 </b><a href="qtquick-effects-topic.html#opacity">
不透明度</a> 和 <a href="qquickitem.html#enabled-prop">启动</a>。</p>
<!-- @@@visible -->
<!-- $$$width-prop$$$width$$$setWidthqreal$$$resetWidth -->
<h3 class="fn" id="width-prop"><a name="width-prop"></a><span class="name">width</span> : <span class="type"><a href="../qtcore/qtglobal.html#qreal-typedef">qreal</a></span></h3>
<p>

此属性保存此项的宽度。</p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> qreal </td><td class="memItemRight bottomAlign"><span class="name"><b>width</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setWidth</b></span>(<i>qreal</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>resetWidth</b></span>()</td></tr>
</table></div>
<!-- @@@width -->
<!-- $$$x-prop$$$x$$$setXqreal -->
<h3 class="fn" id="x-prop"><a name="x-prop"></a><span class="name">x</span> : <span class="type"><a href="../qtcore/qtglobal.html#qreal-typedef">qreal</a></span></h3>
<p>

定义项相对于其父项的 x 位置。</p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> qreal </td><td class="memItemRight bottomAlign"><span class="name"><b>x</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setX</b></span>(<i>qreal</i>)</td></tr>
</table></div>
<!-- @@@x -->
<!-- $$$y-prop$$$y$$$setYqreal -->
<h3 class="fn" id="y-prop"><a name="y-prop"></a><span class="name">y</span> : <span class="type"><a href="../qtcore/qtglobal.html#qreal-typedef">qreal</a></span></h3>
<p>

定义项相对于其父项的 y 位置。</p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> qreal </td><td class="memItemRight bottomAlign"><span class="name"><b>y</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setY</b></span>(<i>qreal</i>)</td></tr>
</table></div>
<!-- @@@y -->
<!-- $$$z-prop$$$z$$$setZqreal -->
<h3 class="fn" id="z-prop"><a name="z-prop"></a><span class="name">z</span> : <span class="type"><a href="../qtcore/qtglobal.html#qreal-typedef">qreal</a></span></h3>
<p>

设置同级项的堆叠顺序。默认情况下，堆叠顺序为 0。</p>
<p>

具有较高堆叠值的项被绘制在具有较低堆叠顺序的同级之上。具有相同堆叠值的项按照它们出现的顺序自下而上绘制。具有负堆叠值的项被绘制在其父项的内容下。</p>
<p>

以下示例显示了堆叠顺序的各种效果。</p>
<div class="table"><table class="generic">
 <tr valign="top" class="odd"><td ><p class="centerAlign"><img src="images/declarative-item_stacking1.png" alt="" /></p></td><td >

	 相同<code>z</code>- 较早的孩子高于较晚的孩子：<pre class="qml">

  <span class="type"><a href="qml-qtquick-item.html">Item</a></span> {
      <span class="type"><a href="qml-qtquick-rectangle.html">Rectangle</a></span> {
          <span class="name">color</span>: <span class="string">&quot;red&quot;</span>
          <span class="name">width</span>: <span class="number">100</span>; <span class="name">height</span>: <span class="number">100</span>
      }
      <span class="type"><a href="qml-qtquick-rectangle.html">Rectangle</a></span> {
          <span class="name">color</span>: <span class="string">&quot;blue&quot;</span>
          <span class="name">x</span>: <span class="number">50</span>; <span class="name">y</span>: <span class="number">50</span>; <span class="name">width</span>: <span class="number">100</span>; <span class="name">height</span>: <span class="number">100</span>
      }
  }

</pre>
</td></tr>
<tr valign="top" class="even"><td ><p class="centerAlign"><img src="images/declarative-item_stacking2.png" alt="" /></p></td><td >

	<code>z</code>顶部更高：<pre class="qml">

  <span class="type"><a href="qml-qtquick-item.html">Item</a></span> {
      <span class="type"><a href="qml-qtquick-rectangle.html">Rectangle</a></span> {
          <span class="name">z</span>: <span class="number">1</span>
          <span class="name">color</span>: <span class="string">&quot;red&quot;</span>
          <span class="name">width</span>: <span class="number">100</span>; <span class="name">height</span>: <span class="number">100</span>
      }
      <span class="type"><a href="qml-qtquick-rectangle.html">Rectangle</a></span> {
          <span class="name">color</span>: <span class="string">&quot;blue&quot;</span>
          <span class="name">x</span>: <span class="number">50</span>; <span class="name">y</span>: <span class="number">50</span>; <span class="name">width</span>: <span class="number">100</span>; <span class="name">height</span>: <span class="number">100</span>
      }
  }

</pre>
</td></tr>
<tr valign="top" class="odd"><td style="height: 305px" ><p class="centerAlign"><img src="images/declarative-item_stacking3.png" alt="" /></p></td>
	<td style="height: 305px" >

	相同<code>z</code>- 父母以上的孩子：<pre class="qml">

  <span class="type"><a href="qml-qtquick-item.html">Item</a></span> {
      <span class="type"><a href="qml-qtquick-rectangle.html">Rectangle</a></span> {
          <span class="name">color</span>: <span class="string">&quot;red&quot;</span>
          <span class="name">width</span>: <span class="number">100</span>; <span class="name">height</span>: <span class="number">100</span>
          <span class="type"><a href="qml-qtquick-rectangle.html">Rectangle</a></span> {
              <span class="name">color</span>: <span class="string">&quot;blue&quot;</span>
              <span class="name">x</span>: <span class="number">50</span>; <span class="name">y</span>: <span class="number">50</span>; <span class="name">width</span>: <span class="number">100</span>; <span class="name">height</span>: <span class="number">100</span>
          }
      }
  }

</pre>
</td></tr>
<tr valign="top" class="even"><td ><p class="centerAlign"><img src="images/declarative-item_stacking4.png" alt="" /></p></td><td >

	低于<code>z</code>：<pre class="qml">

  <span class="type"><a href="qml-qtquick-item.html">Item</a></span> {
      <span class="type"><a href="qml-qtquick-rectangle.html">Rectangle</a></span> {
          <span class="name">color</span>: <span class="string">&quot;red&quot;</span>
          <span class="name">width</span>: <span class="number">100</span>; <span class="name">height</span>: <span class="number">100</span>
          <span class="type"><a href="qml-qtquick-rectangle.html">Rectangle</a></span> {
              <span class="name">z</span>: -<span class="number">1</span>
              <span class="name">color</span>: <span class="string">&quot;blue&quot;</span>
              <span class="name">x</span>: <span class="number">50</span>; <span class="name">y</span>: <span class="number">50</span>; <span class="name">width</span>: <span class="number">100</span>; <span class="name">height</span>: <span class="number">100</span>
          }
      }
  }

</pre>
</td></tr>
</table></div>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> qreal </td><td class="memItemRight bottomAlign"><span class="name"><b>z</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setZ</b></span>(<i>qreal</i>)</td></tr>
</table></div>
<!-- @@@z -->
</div>
<div class="func">
<h2>成员函数文档</h2>
<!-- $$$ -->
<div class="fngroup">
</div>
<p>

<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#width-prop">如果未指定宽度</a>或<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#height-prop">高度</a>，则定义项的自然宽度或高度。</p>
<p>

大多数项的默认隐式大小是 0x0，但是有些项具有无法覆盖的固有隐式大小，例如<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qml-qtquick-image.html">Image</a>和<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qml-qtquick-text.html">Text</a>。</p>
<p>

设置隐式大小对于根据内容定义具有首选大小的组件很有用，例如：</p>
<pre class="qml">

  <span class="comment">// Label.qml</span>
  import QtQuick 2.0

  <span class="type"><a href="qml-qtquick-item.html">Item</a></span> {
      property <span class="type">alias</span> <span class="name">icon</span>: <span class="name">image</span>.<span class="name">source</span>
      property <span class="type">alias</span> <span class="name">label</span>: <span class="name">text</span>.<span class="name">text</span>
      <span class="name">implicitWidth</span>: <span class="name">text</span>.<span class="name">implicitWidth</span> <span class="operator">+</span> <span class="name">image</span>.<span class="name">implicitWidth</span>
      <span class="name">implicitHeight</span>: <span class="name">Math</span>.<span class="name">max</span>(<span class="name">text</span>.<span class="name">implicitHeight</span>, <span class="name">image</span>.<span class="name">implicitHeight</span>)
      <span class="type"><a href="qml-qtquick-image.html">Image</a></span> { <span class="name">id</span>: <span class="name">image</span> }
      <span class="type"><a href="qml-qtquick-text.html">Text</a></span> {
          <span class="name">id</span>: <span class="name">text</span>
          <span class="name">wrapMode</span>: <span class="name">Text</span>.<span class="name">Wrap</span>
          <span class="name">anchors</span>.left: <span class="name">image</span>.<span class="name">right</span>; <span class="name">anchors</span>.right: <span class="name">parent</span>.<span class="name">right</span>
          <span class="name">anchors</span>.verticalCenter: <span class="name">parent</span>.<span class="name">verticalCenter</span>
      }
  }

</pre>
<p>

<b>注意：</b>使用<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qml-qtquick-text.html">Text</a>或<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qml-qtquick-textedit.html">TextEdit</a>的<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#implicitWidth-prop">implicitWidth</a>并显式设置宽度会导致性能损失，因为文本必须布局两次。<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qml-qtquick-text.html"></a><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qml-qtquick-textedit.html"></a></p><!-- @@@ -->
<!-- $$$QQuickItem[overload1]$$$QQuickItemQQuickItem* -->
<h3 class="fn" id="QQuickItem"><a name="QQuickItem"></a>QQuickItem::<span class="name">QQuickItem</span>(<span class="type"><a href="qquickitem.html#QQuickItem">QQuickItem</a></span> *<i>parent</i> = nullptr)</h3>
<p>用给定的<i>parent</i>构造一个<a href="qquickitem.html">QQuickItem</a>。</p>
<p>

将<code>parent</code>用作<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#parent-prop">视觉父级</a>和<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtcore/qobject.html">QObject</a>父级。</p>
<!-- @@@QQuickItem -->
<!-- $$$~QQuickItem[overload1]$$$~QQuickItem -->
<h3 class="fn" id="dtor.QQuickItem"><a name="dtor.QQuickItem"></a><code>[override virtual] </code>QQuickItem::<span class="name">~QQuickItem</span>()</h3>
<p>

销毁<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html">QQuickItem</a>。</p>
<!-- @@@~QQuickItem -->
<!-- $$$acceptHoverEvents[overload1]$$$acceptHoverEvents -->
<h3 class="fn" id="acceptHoverEvents"><a name="acceptHoverEvents"></a><span class="type">bool</span> QQuickItem::<span class="name">acceptHoverEvents</span>() const</h3>
<p>

返回此项是否接受悬停事件。</p>
<p>

默认值为假。</p>
<p>

如果为 false，则 item 将不会通过<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#hoverEnterEvent">hoverEnterEvent</a> ()、<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#hoverMoveEvent">hoverMoveEvent</a> () 和<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#hoverLeaveEvent">hoverLeaveEvent</a> () 函数接收任何悬停事件。</p>
<p><b>请参考 </b><a href="qquickitem.html#setAcceptHoverEvents">setAcceptHoverEvents</a>()。</p>
<!-- @@@acceptHoverEvents -->
<!-- $$$acceptTouchEvents[overload1]$$$acceptTouchEvents -->
<h3 class="fn" id="acceptTouchEvents"><a name="acceptTouchEvents"></a><span class="type">bool</span> QQuickItem::<span class="name">acceptTouchEvents</span>() const</h3>
<p>

返回此项是否接受触摸事件。</p>
<p>

默认值为假。</p>
<p>

如果为 false，则 item 将不会通过<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#touchEvent">touchEvent</a>() 函数接收任何触摸事件。</p>
<p>该函数于Qt 5.10中引入。</p>
<p><b>请参考 </b><a href="qquickitem.html#setAcceptTouchEvents">setAcceptTouchEvents</a>()。</p>
<!-- @@@acceptTouchEvents -->
<!-- $$$acceptedMouseButtons[overload1]$$$acceptedMouseButtons -->
<h3 class="fn" id="acceptedMouseButtons"><a name="acceptedMouseButtons"></a><span class="type"><a href="../qtcore/qt.html#MouseButton-enum">Qt::MouseButtons</a></span> QQuickItem::<span class="name">acceptedMouseButtons</span>() const</h3>
<p>

返回此项接受的鼠标按钮。</p>
<p>

默认值为<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtcore/qt.html#MouseButton-enum">Qt::NoButton</a>；也就是说，不接受鼠标按钮。</p>
<p>

如果项不接受特定鼠标事件的鼠标按钮，则鼠标事件将不会传递给该项，而是传递给项层次结构中的下一个项。</p>
<p><b>请参考 </b><a href="qquickitem.html#setAcceptedMouseButtons">setAcceptedMouseButtons</a>()。</p>
<!-- @@@acceptedMouseButtons -->
<!-- $$$childAt[overload1]$$$childAtqrealqreal -->
<h3 class="fn" id="childAt"><a name="childAt"></a><span class="type"><a href="qquickitem.html#QQuickItem">QQuickItem</a></span> *QQuickItem::<span class="name">childAt</span>(<span class="type"><a href="../qtcore/qtglobal.html#qreal-typedef">qreal</a></span> <i>x</i>, <span class="type"><a href="../qtcore/qtglobal.html#qreal-typedef">qreal</a></span> <i>y</i>) const</h3>
<p>返回在该项的坐标系内的点 ( x , y ) 处找到的第一个可见子项。</p>
<p>如果没有这样的项，返回<code>nullptr</code> 。</p>
<p>

<b>注意：</b>这个函数可以通过元对象系统和 QML 调用。请参阅<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtcore/qobject.html#Q_INVOKABLE">Q_INVOKABLE</a>。</p>
<!-- @@@childAt -->
<!-- $$$childItems[overload1]$$$childItems -->
<h3 class="fn" id="childItems"><a name="childItems"></a><span class="type"><a href="../qtcore/qlist.html">QList</a></span>&lt;<span class="type"><a href="qquickitem.html#QQuickItem">QQuickItem</a></span> *&gt; QQuickItem::<span class="name">childItems</span>() const</h3>
<p>

返回此项的子项。</p>
<!-- @@@childItems -->
<!-- $$$childMouseEventFilter[overload1]$$$childMouseEventFilterQQuickItem*QEvent* -->
<h3 class="fn" id="childMouseEventFilter"><a name="childMouseEventFilter"></a><code>[virtual protected] </code><span class="type">bool</span> QQuickItem::<span class="name">childMouseEventFilter</span>(<span class="type"><a href="qquickitem.html#QQuickItem">QQuickItem</a></span> *<i>item</i>, <span class="type"><a href="../qtcore/qevent.html">QEvent</a></span> *<i>event</i>)</h3>
<p>

重新实现此方法以过滤此项的子项接收到的鼠标事件。</p>
<p>仅当<a href="qquickitem.html#filtersChildMouseEvents">filtersChildMouseEvents</a>() 
为 true时才会调用此方法。</p>
<p>
如果指定的<i>event</i> 不应传递到指定的子<i>item</i>，则返回 true，否则返回 false。</p>
<p><b>请参考 </b><a href="qquickitem.html#setFiltersChildMouseEvents">setFiltersChildMouseEvents</a>()。</p>
<!-- @@@childMouseEventFilter -->
<!-- $$$classBegin[overload1]$$$classBegin -->
<h3 class="fn" id="classBegin"><a name="classBegin"></a><code>[override virtual protected] </code><span class="type">void</span> QQuickItem::<span class="name">classBegin</span>()</h3>
<p>重新实现自<a href="../qtqml/qqmlparserstatus.html#classBegin">QQmlParserStatus::classBegin</a>()。</p>
<p>

派生类应在添加自己的操作以在 classBegin 处执行之前调用基类方法。</p>
<!-- @@@classBegin -->
<!-- $$$componentComplete[overload1]$$$componentComplete -->
<h3 class="fn" id="componentComplete"><a name="componentComplete"></a><code>[override virtual protected] </code><span class="type">void</span> QQuickItem::<span class="name">componentComplete</span>()</h3>
<p>重新实现自<a href="../qtqml/qqmlparserstatus.html#componentComplete">QQmlParserStatus::componentComplete</a>()。</p>
<p>

派生类应在添加自己的操作以在 componentComplete 处执行之前调用基类方法。</p>
<!-- @@@componentComplete -->
<!-- $$$contains[overload1]$$$containsconstQPointF& -->
<h3 class="fn" id="contains"><a name="contains"></a><code>[virtual] </code><span class="type">bool</span> QQuickItem::<span class="name">contains</span>(const <span class="type"><a href="../qtcore/qpointf.html">QPointF</a></span> &amp;<i>point</i>) const</h3>
<p>
如果此项包含<i>point</i>，则返回 true，表示点位于本地坐标中；否则返回 false。</p>
<p>

可以覆盖此函数以处理具有自定义形状的项中的点碰撞。默认实现检查该点是否在项的边界矩形内。</p>
<p>

请注意，该方法一般用于检查项是否在鼠标光标下，因此该函数的实现应尽可能轻量级。</p>
<p>

<b>注意：</b>这个函数可以通过元对象系统和 QML 调用。请参阅<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtcore/qobject.html#Q_INVOKABLE">Q_INVOKABLE</a>。</p>
<!-- @@@contains -->
<!-- $$$cursor[overload1]$$$cursor -->
<h3 class="fn" id="cursor"><a name="cursor"></a><span class="type"><a href="../qtgui/qcursor.html">QCursor</a></span> QQuickItem::<span class="name">cursor</span>() const</h3>
<p>

返回此项的光标形状。</p>
<p>

除非设置了覆盖光标，否则鼠标光标将在此项上方时渲染此形状。有关一系列有用的形状，请参阅<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtcore/qt.html#CursorShape-enum">预定义光标对象列表。</a></p>
<p>

如果没有设置光标形状，则返回具有<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtcore/qt.html#CursorShape-enum">Qt::ArrowCursor</a>形状的光标，但是如果重叠项具有有效光标，则可能会显示另一个光标形状。</p>
<p><b>请参考 </b><a href="qquickitem.html#setCursor">setCursor</a>() 和 <a href="qquickitem.html#unsetCursor">unsetCursor</a>()。</p>
<!-- @@@cursor -->
<!-- $$$dragEnterEvent[overload1]$$$dragEnterEventQDragEnterEvent* -->
<h3 class="fn" id="dragEnterEvent"><a name="dragEnterEvent"></a><code>[virtual protected] </code><span class="type">void</span> QQuickItem::<span class="name">dragEnterEvent</span>(<span class="type"><a href="../qtgui/qdragenterevent.html">QDragEnterEvent</a></span> *<i>event</i>)</h3>
<p>

此事件处理程序可以在子类中重新实现，以接收项的拖动输入事件。事件信息由<i>event</i>参数提供。</p>
<p>

仅当已为此项设置了<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#Flag-enum">ItemAcceptsDrops</a>标志时才提供拖放事件。</p>
<p>

默认情况下接受该事件，因此如果您重新实现此功能，则无需显式接受该事件。如果您不接受该事件，请<code>调用event-&gt;ignore()</code>。</p>
<p><b>请参考 </b><a href="qml-qtquick-drag.html">拖</a> 和  
&nbsp;<a href="../qtgui/qtgui-index.html#drag-and-drop">拖放</a>。</p>
<!-- @@@dragEnterEvent -->
<!-- $$$dragLeaveEvent[overload1]$$$dragLeaveEventQDragLeaveEvent* -->
<h3 class="fn" id="dragLeaveEvent"><a name="dragLeaveEvent"></a><code>[virtual protected] </code><span class="type">void</span> QQuickItem::<span class="name">dragLeaveEvent</span>(<span class="type"><a href="../qtgui/qdragleaveevent.html">QDragLeaveEvent</a></span> *<i>event</i>)</h3>
<p>

此事件处理程序可以在子类中重新实现，以接收项的拖离事件。事件信息由<i>event</i>参数提供。</p>
<p>

仅当已为此项设置了<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#Flag-enum">ItemAcceptsDrops</a>标志时才提供拖放事件。</p>
<p>

默认情况下接受该事件，因此如果您重新实现此功能，则无需显式接受该事件。如果您不接受该事件，请调用<code>event-&gt;ignore()</code>。</p>
<p><b>请参考 </b><a href="qml-qtquick-drag.html">拖</a> 和  
&nbsp;<a href="../qtgui/qtgui-index.html#drag-and-drop">拖放</a>。</p>
<!-- @@@dragLeaveEvent -->
<!-- $$$dragMoveEvent[overload1]$$$dragMoveEventQDragMoveEvent* -->
<h3 class="fn" id="dragMoveEvent"><a name="dragMoveEvent"></a><code>[virtual protected] </code><span class="type">void</span> QQuickItem::<span class="name">dragMoveEvent</span>(<span class="type"><a href="../qtgui/qdragmoveevent.html">QDragMoveEvent</a></span> *<i>event</i>)</h3>
<p>

此事件处理程序可以在子类中重新实现，以接收项的拖动-移动事件。事件信息由<i>event</i>参数提供。</p>
<p>

仅当已为此项设置了<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#Flag-enum">ItemAcceptsDrops</a>标志时才提供拖放事件。</p>
<p>

默认情况下接受该事件，因此如果您重新实现此功能，则无需显式接受该事件。如果您不接受该事件，请调用<code>event-&gt;ignore()</code>。</p>
<p><b>请参考 </b><a href="qml-qtquick-drag.html">拖</a> 和  
&nbsp;<a href="../qtgui/qtgui-index.html#drag-and-drop">拖放</a>。</p>
<!-- @@@dragMoveEvent -->
<!-- $$$dropEvent[overload1]$$$dropEventQDropEvent* -->
<h3 class="fn" id="dropEvent"><a name="dropEvent"></a><code>[virtual protected] </code><span class="type">void</span> QQuickItem::<span class="name">dropEvent</span>(<span class="type"><a href="../qtgui/qdropevent.html">QDropEvent</a></span> *<i>event</i>)</h3>
<p>

此事件处理程序可以在子类中重新实现以接收项的放置事件。事件信息由<i>event</i>参数提供。</p>
<p>

仅当已为此项设置了<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#Flag-enum">ItemAcceptsDrops</a>标志时才提供拖放事件。</p>
<p>

默认情况下接受该事件，因此如果您重新实现此功能，则无需显式接受该事件。如果您不接受该事件，请调用<code>event-&gt;ignore()</code>。</p>
<p><b>请参考 </b><a href="qml-qtquick-drag.html">拖</a> 和  
&nbsp;<a href="../qtgui/qtgui-index.html#drag-and-drop">拖放</a>。</p>
<!-- @@@dropEvent -->
<!-- $$$event[overload1]$$$eventQEvent* -->
<h3 class="fn" id="event"><a name="event"></a><code>[override virtual protected] </code><span class="type">bool</span> QQuickItem::<span class="name">event</span>(<span class="type"><a href="../qtcore/qevent.html">QEvent</a></span> *<i>ev</i>)</h3>
<p>重新实现自<a href="../qtcore/qobject.html#event">QObject::event</a>()。</p>
<!-- @@@event -->
<!-- $$$filtersChildMouseEvents[overload1]$$$filtersChildMouseEvents -->
<h3 class="fn" id="filtersChildMouseEvents"><a name="filtersChildMouseEvents"></a><span class="type">bool</span> QQuickItem::<span class="name">filtersChildMouseEvents</span>() const</h3>
<p>

返回此项的子项的鼠标和触摸事件是否应通过该项过滤。</p>
<p><b>请参考 </b><a href="qquickitem.html#setFiltersChildMouseEvents">setFiltersChildMouseEvents</a>() 和 <a href="qquickitem.html#childMouseEventFilter">childMouseEventFilter</a>()。</p>
<!-- @@@filtersChildMouseEvents -->
<!-- $$$flags[overload1]$$$flags -->
<h3 class="fn" id="flags"><a name="flags"></a><span class="type"><a href="qquickitem.html#Flag-enum">QQuickItem::Flags</a></span> QQuickItem::<span class="name">flags</span>() const</h3>
<p>

返回此项的项标志。</p>
<p><b>请参考 </b><a href="qquickitem.html#setFlags">setFlags</a>() 和 <a href="qquickitem.html#setFlag">setFlag</a>()。</p>
<!-- @@@flags -->
<!-- $$$focusInEvent[overload1]$$$focusInEventQFocusEvent* -->
<h3 class="fn" id="focusInEvent"><a name="focusInEvent"></a><code>[virtual protected] </code><span class="type">void</span> QQuickItem::<span class="name">focusInEvent</span>(<i>QFocusEvent *</i>)</h3>
<p>

此事件处理程序可以在子类中重新实现，以接收项的焦点事件。事件信息由<code>event</code>参数提供。</p>
<p>

默认情况下接受该事件，因此如果您重新实现此功能，则无需显式接受该事件。如果您不接受该事件，请致电<code>event-&gt;ignore()</code>。</p>
<p>

如果你确实重新实现了这个函数，你应该调用基类实现。</p>
<!-- @@@focusInEvent -->
<!-- $$$focusOutEvent[overload1]$$$focusOutEventQFocusEvent* -->
<h3 class="fn" id="focusOutEvent"><a name="focusOutEvent"></a><code>[virtual protected] </code><span class="type">void</span> QQuickItem::<span class="name">focusOutEvent</span>(<i>QFocusEvent *</i>)</h3>
<p>

此事件处理程序可以在子类中重新实现，以接收项的焦点事件。事件信息由<code>event</code>参数提供。</p>
<p>

默认情况下接受该事件，因此如果您重新实现此功能，则无需显式接受该事件。如果您不接受该事件，请致电<code>event-&gt;ignore()</code>。</p>
<!-- @@@focusOutEvent -->
<!-- $$$forceActiveFocus[overload1]$$$forceActiveFocus -->
<h3 class="fn" id="forceActiveFocus"><a name="forceActiveFocus"></a><span class="type">void</span> QQuickItem::<span class="name">forceActiveFocus</span>()</h3>
<p>

强制将焦点集中在项上。</p>
<p>

此方法将焦点设置在项上，并确保对象层次结构中的所有祖先<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qml-qtquick-focusscope.html">FocusScope</a>对象也被赋予<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#focus-prop">焦点</a>。</p>
<p>
焦点更改的原因将是<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtcore/qt.html#FocusReason-enum">Qt::OtherFocusReason</a>。使用重载方法指定焦点原因，以便更好地处理焦点更改。</p>
<p>

<b>注意：</b>这个函数可以通过元对象系统和 QML 调用。请参阅<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtcore/qobject.html#Q_INVOKABLE">Q_INVOKABLE</a>。</p>
<p><b>请参考 </b><a href="qquickitem.html#activeFocus-prop">activeFocus</a>。</p>
<!-- @@@forceActiveFocus -->
<!-- $$$forceActiveFocus$$$forceActiveFocusQt::FocusReason -->
<h3 class="fn" id="forceActiveFocus-1"><a name="forceActiveFocus-1"></a><span class="type">void</span> QQuickItem::<span class="name">forceActiveFocus</span>(<span class="type"><a href="../qtcore/qt.html#FocusReason-enum">Qt::FocusReason</a></span> <i>reason</i>)</h3>
<p>这是一个重载函数。</p>
<p>以给定的<i>reason</i>强制将注意力集中在项上。</p>
<p>

此方法将焦点设置在项上，并确保对象层次结构中的所有祖先<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qml-qtquick-focusscope.html">FocusScope</a>对象也被赋予<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#focus-prop">焦点</a>。</p>
<p>该函数于Qt 5.1中引入。</p>
<p>

<b>注意：</b>这个函数可以通过元对象系统和 QML 调用。请参阅<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtcore/qobject.html#Q_INVOKABLE">Q_INVOKABLE</a>。</p>
<p><b>请参考 </b><a href="qquickitem.html#activeFocus-prop">activeFocus</a> 和 <a href="../qtcore/qt.html#FocusReason-enum">Qt::FocusReason</a>。</p>
<!-- @@@forceActiveFocus -->
<!-- $$$geometryChanged[overload1]$$$geometryChangedconstQRectF&constQRectF& -->
<h3 class="fn" id="geometryChanged"><a name="geometryChanged"></a><code>[virtual protected] </code><span class="type">void</span> QQuickItem::<span class="name">geometryChanged</span>(const <span class="type"><a href="../qtcore/qrectf.html">QRectF</a></span> &amp;<i>newGeometry</i>, const <span class="type"><a href="../qtcore/qrectf.html">QRectF</a></span> &amp;<i>oldGeometry</i>)</h3>
<p>

调用此函数来处理该项在几何中从<i>oldGeometry</i>到<i>newGeometry</i>的变化。如果两个几何形状相同，则它不会做任何事情。</p>
<p>

派生类必须在其实现中调用基类方法。</p>
<!-- @@@geometryChanged -->
<!-- $$$grabMouse[overload1]$$$grabMouse -->
<h3 class="fn" id="grabMouse"><a name="grabMouse"></a><span class="type">void</span> QQuickItem::<span class="name">grabMouse</span>()</h3>
<p>

抓取鼠标输入。</p>
<p>

该项将接收所有鼠标事件，直到<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#ungrabMouse">调用 ungrabMouse</a> ()。通常不应调用此函数，因为接受例如鼠标按下事件可确保将以下事件传递给项。如果一个项想要从当前接收者那里接管鼠标事件，它需要调用这个函数。</p>
<p>

<b>警告：</b>应谨慎使用此功能。</p>
<!-- @@@grabMouse -->
<!-- $$$grabToImage[overload1]$$$grabToImageconstQSize& -->
<h3 class="fn" id="grabToImage"><a name="grabToImage"></a><span class="type"><a href="../qtcore/qsharedpointer.html">QSharedPointer</a></span>&lt;<span class="type"><a href="qquickitemgrabresult.html">QQuickItemGrabResult</a></span>&gt; QQuickItem::<span class="name">grabToImage</span>(const <span class="type"><a href="../qtcore/qsize.html">QSize</a></span> &amp;<i>targetSize</i> = QSize())</h3>
<p>

项抓取到内存中的图像中。</p>
<p>

抓取是异步发生的，当抓取完成时会发出信号<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitemgrabresult.html#ready">QQuickItemGrabResult::ready ()。</a></p>
<p>

使用<i>targetSize</i>指定目标图像的大小。默认情况下，结果将具有与 item 相同的大小。</p>
<p>

如果无法启动抓取，则函数返回<code>null</code>。</p>
<p>

<b>注意：</b>此函数会将项渲染到屏幕外表面并将该表面从 GPU 的内存复制到 CPU 的内存中，这可能会非常昂贵。对于“实时”预览，请使用<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qml-qtquick-item.html#layer.enabled-prop">图层</a>或<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qml-qtquick-shadereffectsource.html">ShaderEffectSource</a>。</p><p><b>See also </b><a href="qquickwindow.html#grabWindow">QQuickWindow::grabWindow</a>()。</p>
<!-- @@@grabToImage -->
<!-- $$$grabTouchPoints[overload1]$$$grabTouchPointsconstQVector<int>& -->
<h3 class="fn" id="grabTouchPoints"><a name="grabTouchPoints"></a><span class="type">void</span> QQuickItem::<span class="name">grabTouchPoints</span>(const <span class="type"><a href="../qtcore/qvector.html">QVector</a></span>&lt;<span class="type">int</span>&gt; &amp;<i>ids</i>)</h3>
<p>

<i>抓</i>抓取<i>ids</i>指定的触碰点。</p>
<p>

在发布之前，这些触摸点将归项所有。或者，抓取可以被 Flickable 之类的过滤项窃取。使用<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#setKeepTouchGrab">setKeepTouchGrab</a> () 防止抓取被盗。</p>
<p><b>请参考 </b><a href="qquickitem.html#ungrabTouchPoints">ungrabTouchPoints</a>() 和 <a href="qquickitem.html#setKeepTouchGrab">setKeepTouchGrab</a>()。</p>
<!-- @@@grabTouchPoints -->
<!-- $$$heightValid[overload1]$$$heightValid -->
<h3 class="fn" id="heightValid"><a name="heightValid"></a><code>[protected] </code><span class="type">bool</span> QQuickItem::<span class="name">heightValid</span>() const</h3>
<p>

返回是否明确设置了 height 属性。</p>
<!-- @@@heightValid -->
<!-- $$$hoverEnterEvent[overload1]$$$hoverEnterEventQHoverEvent* -->
<h3 class="fn" id="hoverEnterEvent"><a name="hoverEnterEvent"></a><code>[virtual protected] </code><span class="type">void</span> QQuickItem::<span class="name">hoverEnterEvent</span>(<span class="type"><a href="../qtgui/qhoverevent.html">QHoverEvent</a></span> *<i>event</i>)</h3>
<p>

此事件处理程序可以在子类中重新实现，以接收项的悬停输入事件。事件信息由<i>event</i>参数提供。</p>
<p>
仅当<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#acceptHoverEvents">acceptHoverEvents</a> () 为真时才提供悬停事件。</p>
<p>

默认情况下接受该事件，因此如果您重新实现此功能，则无需显式接受该事件。如果您不接受该事件，请致电<code>event-&gt;ignore()</code>。</p>
<!-- @@@hoverEnterEvent -->
<!-- $$$hoverLeaveEvent[overload1]$$$hoverLeaveEventQHoverEvent* -->
<h3 class="fn" id="hoverLeaveEvent"><a name="hoverLeaveEvent"></a><code>[virtual protected] </code><span class="type">void</span> QQuickItem::<span class="name">hoverLeaveEvent</span>(<span class="type"><a href="../qtgui/qhoverevent.html">QHoverEvent</a></span> *<i>event</i>)</h3>
<p>

此事件处理程序可以在子类中重新实现，以接收项的悬停离开事件。事件信息由<i>event</i>参数提供。</p>
<p>
仅当<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#acceptHoverEvents">acceptHoverEvents</a> () 为真时才提供悬停事件。</p>
<p>默认情况下接受该事件，因此如果您重新实现此功能，则无需显式接受该事件。如果您不接受该事件，请调用<code>event-&gt;ignore()</code>。</p>
<!-- @@@hoverLeaveEvent -->
<!-- $$$hoverMoveEvent[overload1]$$$hoverMoveEventQHoverEvent* -->
<h3 class="fn" id="hoverMoveEvent"><a name="hoverMoveEvent"></a><code>[virtual protected] </code><span class="type">void</span> QQuickItem::<span class="name">hoverMoveEvent</span>(<span class="type"><a href="../qtgui/qhoverevent.html">QHoverEvent</a></span> *<i>event</i>)</h3>
<p>

此事件处理程序可以在子类中重新实现，以接收项的悬停移动事件。事件信息由<i>event</i>参数提供。</p>
<p>
仅当<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#acceptHoverEvents">acceptHoverEvents</a>() 为真时才提供悬停事件。</p>
<p>默认情况下接受该事件，因此如果您重新实现此功能，则无需显式接受该事件。如果您不接受该事件，请调用<code>event-&gt;ignore()</code>。</p>
<!-- @@@hoverMoveEvent -->
<!-- $$$implicitWidth -->
<h3 class="fn" id="implicitWidth"><a name="implicitWidth"></a><span class="type"><a href="../qtcore/qtglobal.html#qreal-typedef">qreal</a></span> QQuickItem::<span class="name">implicitWidth</span>() const</h3>
<p>

返回确定内容的其他属性所隐含的项的宽度。</p>
<p><b>注意:</b>属性<a href="qquickitem.html#implicitWidth-prop">implicitWidth</a>的获取函数。</p><p>
	<b>请参考 </b><a href="qquickitem.html#implicitWidth-prop">setImplicitWidth</a>()。</p>
<!-- @@@implicitWidth -->
<!-- $$$inputMethodEvent[overload1]$$$inputMethodEventQInputMethodEvent* -->
<h3 class="fn" id="inputMethodEvent"><a name="inputMethodEvent"></a><code>[virtual protected] </code><span class="type">void</span> QQuickItem::<span class="name">inputMethodEvent</span>(<span class="type"><a href="../qtgui/qinputmethodevent.html">QInputMethodEvent</a></span> *<i>event</i>)</h3>
<p>

此事件处理程序可以在子类中重新实现，以接收项的输入法事件。事件信息由<i>event</i>参数提供。</p>
<p>默认情况下接受该事件，因此如果您重新实现此功能，则无需显式接受该事件。如果您不接受该事件，请调用<code>event-&gt;ignore()</code>。</p>
<!-- @@@inputMethodEvent -->
<!-- $$$inputMethodQuery[overload1]$$$inputMethodQueryQt::InputMethodQuery -->
<h3 class="fn" id="inputMethodQuery"><a name="inputMethodQuery"></a><code>[virtual] </code><span class="type"><a href="../qtcore/qvariant.html">QVariant</a></span> QQuickItem::<span class="name">inputMethodQuery</span>(<span class="type"><a href="../qtcore/qt.html#InputMethodQuery-enum">Qt::InputMethodQuery</a></span> <i>query</i>) const</h3>
<p>

此方法仅与输入项相关。</p>
<p>

如果此项是输入项，则应重新实现此方法以返回给定<i>query</i>的相关输入法标志。</p>
<p><b>请参考 </b><a href="../qtwidgets/qwidget.html#inputMethodQuery">QWidget::inputMethodQuery</a>()。</p>
<!-- @@@inputMethodQuery -->
<!-- $$$isAncestorOf[overload1]$$$isAncestorOfconstQQuickItem* -->
<h3 class="fn" id="isAncestorOf"><a name="isAncestorOf"></a><span class="type">bool</span> QQuickItem::<span class="name">isAncestorOf</span>(const <span class="type"><a href="qquickitem.html#QQuickItem">QQuickItem</a></span> *<i>child</i>) const</h3>
<p>如果该项是<i>child</i> 项的祖先(即，如果该项是<i>child</i> 项的父项，或<i>child</i> 目的父项的祖先之一)，则返回<code>true</code> 
。</p>
<p>该函数于Qt 5.7中引入。</p>
<p><b>请参考 </b><a href="qquickitem.html#parent-prop">parentItem</a>()。</p>
<!-- @@@isAncestorOf -->
<!-- $$$isComponentComplete[overload1]$$$isComponentComplete -->
<h3 class="fn" id="isComponentComplete"><a name="isComponentComplete"></a><code>[protected] </code><span class="type">bool</span> QQuickItem::<span class="name">isComponentComplete</span>() const</h3>
<p>

如果 QML 组件的构建完成，则返回 true；否则返回false。</p>
<p>

通常希望延迟一些处理直到组件完成。</p>
<p><b>请参考 </b><a href="qquickitem.html#componentComplete">componentComplete</a>()。</p>
<!-- @@@isComponentComplete -->
<!-- $$$isFocusScope[overload1]$$$isFocusScope -->
<h3 class="fn" id="isFocusScope"><a name="isFocusScope"></a><span class="type">bool</span> QQuickItem::<span class="name">isFocusScope</span>() const</h3>
<p>

如果此项是焦点范围，则返回 true，否则返回 false。</p>
<!-- @@@isFocusScope -->
<!-- $$$isTextureProvider[overload1]$$$isTextureProvider -->
<h3 class="fn" id="isTextureProvider"><a name="isTextureProvider"></a><code>[virtual] </code><span class="type">bool</span> QQuickItem::<span class="name">isTextureProvider</span>() const</h3>
<p>

如果此项是纹理提供程序，则返回 true。默认实现返回 false。</p>
<p style="height: 20px">

可以从任何线程调用此函数。</p>
<!-- @@@isTextureProvider -->
<!-- $$$itemChange[overload1]$$$itemChangeQQuickItem::ItemChangeconstQQuickItem::ItemChangeData& -->
<h3 class="fn" id="itemChange"><a name="itemChange"></a><code>[virtual protected] </code><span class="type">void</span> QQuickItem::<span class="name">itemChange</span>(<span class="type"><a href="qquickitem.html#ItemChange-enum">QQuickItem::ItemChange</a></span> <i>change</i>, const <span class="type"><a href="qquickitem-itemchangedata.html">QQuickItem::ItemChangeData</a></span> &amp;<i>value</i>)</h3>
<p>
当此项发生<i>change</i> 时调用。</p>
<p>

<i>value</i>包含与更改相关的额外信息（如果适用）。</p>
<p>

如果您在子类中重新实现此方法，请务必调用</p>
<pre class="cpp">

  <span class="type"><a href="qquickitem.html#QQuickItem">QQuickItem</a></span><span class="operator">::</span>itemChange(change<span class="operator">,</span> value);

</pre>
<p>

通常在您的实现结束时，以确保将发出<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#windowChanged">windowChanged</a>()信号。</p>
<!-- @@@itemChange -->
<!-- $$$keepMouseGrab[overload1]$$$keepMouseGrab -->
<h3 class="fn" id="keepMouseGrab"><a name="keepMouseGrab"></a><span class="type">bool</span> QQuickItem::<span class="name">keepMouseGrab</span>() const</h3>
<p>

返回鼠标输入是否应仅保留在此项中。</p>
<p><b>请参考 </b><a href="qquickitem.html#setKeepMouseGrab">setKeepMouseGrab</a>()。</p>
<!-- @@@keepMouseGrab -->
<!-- $$$keepTouchGrab[overload1]$$$keepTouchGrab -->
<h3 class="fn" id="keepTouchGrab"><a name="keepTouchGrab"></a><span class="type">bool</span> QQuickItem::<span class="name">keepTouchGrab</span>() const</h3>
<p>

返回此项抓取的触摸点是否应该独占地保留在此项中。</p>
<p><b>请参考 </b><a href="qquickitem.html#setKeepTouchGrab">setKeepTouchGrab</a>() 和 <a href="qquickitem.html#keepMouseGrab">keepMouseGrab</a>()。</p>
<!-- @@@keepTouchGrab -->
<!-- $$$keyPressEvent[overload1]$$$keyPressEventQKeyEvent* -->
<h3 class="fn" id="keyPressEvent"><a name="keyPressEvent"></a><code>[virtual protected] </code><span class="type">void</span> QQuickItem::<span class="name">keyPressEvent</span>(<span class="type"><a href="../qtgui/qkeyevent.html">QKeyEvent</a></span> *<i>event</i>)</h3>
<p>

此事件处理程序可以在子类中重新实现，以接收项的按键事件。事件信息由<i>event</i>参数提供。</p>
<p>默认情况下接受该事件，因此如果您重新实现此功能，则无需显式接受该事件。如果您不接受该事件，请调用<code>event-&gt;ignore()</code>。</p>
<!-- @@@keyPressEvent -->
<!-- $$$keyReleaseEvent[overload1]$$$keyReleaseEventQKeyEvent* -->
<h3 class="fn" id="keyReleaseEvent"><a name="keyReleaseEvent"></a><code>[virtual protected] </code><span class="type">void</span> QQuickItem::<span class="name">keyReleaseEvent</span>(<span class="type"><a href="../qtgui/qkeyevent.html">QKeyEvent</a></span> *<i>event</i>)</h3>
<p>

此事件处理程序可以在子类中重新实现，以接收项的键释放事件。事件信息由<i>event</i>参数提供。</p>
<p>默认情况下接受该事件，因此如果您重新实现此功能，则无需显式接受该事件。如果您不接受该事件，请调用<code>event-&gt;ignore()</code>。</p>
<!-- @@@keyReleaseEvent -->
<!-- $$$mapFromGlobal[overload1]$$$mapFromGlobalconstQPointF& -->
<h3 class="fn" id="mapFromGlobal"><a name="mapFromGlobal"></a><span class="type"><a href="../qtcore/qpointf.html">QPointF</a></span> QQuickItem::<span class="name">mapFromGlobal</span>(const <span class="type"><a href="../qtcore/qpointf.html">QPointF</a></span> &amp;<i>point</i>) const</h3>
<p>

将全局屏幕坐标系中的给<i>定点</i>映射到此项坐标系中的等效点，并返回映射后的坐标。</p>
<p>

映射中使用了项的以下属性：<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#x-prop">x</a>、<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#y-prop">y</a>、<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#scale-prop">scale</a>、<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#rotation-prop">rotation</a>、<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#transformOrigin-prop">transformOrigin</a>和<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qml-qtquick-item.html#transform-prop">transform</a>。</p>
<p>

例如，这可能有助于将弹出窗口添加到 Qt Quick 组件。</p>
<p>

<b>注意：</b>窗口定位由窗口管理器完成，此值仅作为提示处理。因此，生成的窗口位置可能与预期的不同。</p><p>该函数于Qt 5.7中引入。</p>
<p>

<b>请参考</b><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qtquick-visualcanvas-coordinates.html">概念 - Qt Quick 中的视觉坐标</a>。</p>
<!-- @@@mapFromGlobal -->
<!-- $$$mapFromItem[overload1]$$$mapFromItemconstQQuickItem*constQPointF& -->
<h3 class="fn" id="mapFromItem"><a name="mapFromItem"></a><span class="type"><a href="../qtcore/qpointf.html">QPointF</a></span> QQuickItem::<span class="name">mapFromItem</span>(const <span class="type"><a href="qquickitem.html#QQuickItem">QQuickItem</a></span> *<i>item</i>, const <span class="type"><a href="../qtcore/qpointf.html">QPointF</a></span> &amp;<i>point</i>) const</h3>
<p>
将 item 坐标系中的给定<i>point</i>映射到该<i>item</i>坐标系中的等效点，并返回映射后的坐标。</p>
<p>

映射中使用了项的以下属性：<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#x-prop">x</a>、<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#y-prop">y</a>、<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#scale-prop">scale</a>、<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#rotation-prop">rotation</a>、<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#transformOrigin-prop">transformOrigin</a>和<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qml-qtquick-item.html#transform-prop">transform</a>。</p>
<p>

如果<i>item</i>为 0，则此映射<i>point</i>来自场景的坐标系。</p>
<p>

<b>请参考</b><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qtquick-visualcanvas-coordinates.html">概念 - Qt Quick 中的视觉坐标</a>。</p>
<!-- @@@mapFromItem -->
<!-- $$$mapFromScene[overload1]$$$mapFromSceneconstQPointF& -->
<h3 class="fn" id="mapFromScene"><a name="mapFromScene"></a><span class="type"><a href="../qtcore/qpointf.html">QPointF</a></span> QQuickItem::<span class="name">mapFromScene</span>(const <span class="type"><a href="../qtcore/qpointf.html">QPointF</a></span> &amp;<i>point</i>) const</h3>
<p>

将场景坐标系中的给定<i>point</i>映射到此项坐标系中的等效点，并返回映射后的坐标。</p>
<p>映射中使用了项的以下属性：<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#x-prop">x</a>、<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#y-prop">y</a>、<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#scale-prop">scale</a>、<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#rotation-prop">rotation</a>、<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#transformOrigin-prop">transformOrigin</a>和<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qml-qtquick-item.html#transform-prop">transform</a>。</p>
<p>

<b>请参考</b><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qtquick-visualcanvas-coordinates.html">概念 - Qt Quick 中的视觉坐标</a>。</p>
<!-- @@@mapFromScene -->
<!-- $$$mapRectFromItem[overload1]$$$mapRectFromItemconstQQuickItem*constQRectF& -->
<h3 class="fn" id="mapRectFromItem"><a name="mapRectFromItem"></a><span class="type"><a href="../qtcore/qrectf.html">QRectF</a></span> QQuickItem::<span class="name">mapRectFromItem</span>(const <span class="type"><a href="qquickitem.html#QQuickItem">QQuickItem</a></span> *<i>item</i>, const <span class="type"><a href="../qtcore/qrectf.html">QRectF</a></span> &amp;<i>rect</i>) const</h3>
<p>将 item 坐标系中的给定<i>rect</i>映射到该<i>item</i>坐标系中的等效矩形区域，并返回映射的矩形值。</p>
<p>映射中使用了项的以下属性：<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#x-prop">x</a>、<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#y-prop">y</a>、<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#scale-prop">scale</a>、<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#rotation-prop">rotation</a>、<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#transformOrigin-prop">transformOrigin</a>和<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qml-qtquick-item.html#transform-prop">transform</a>。</p>
<p>如果<i>item</i>为 0，则从场景的坐标系映射<i>rect 。</i></p>
<p>

<b>请参考</b><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qtquick-visualcanvas-coordinates.html">概念 - Qt Quick 中的视觉坐标</a>。</p>
<!-- @@@mapRectFromItem -->
<!-- $$$mapRectFromScene[overload1]$$$mapRectFromSceneconstQRectF& -->
<h3 class="fn" id="mapRectFromScene"><a name="mapRectFromScene"></a><span class="type"><a href="../qtcore/qrectf.html">QRectF</a></span> QQuickItem::<span class="name">mapRectFromScene</span>(const <span class="type"><a href="../qtcore/qrectf.html">QRectF</a></span> &amp;<i>rect</i>) const</h3>
<p>将场景坐标系中的给定<i>rect</i>映射到此项坐标系中的等效矩形区域，并返回映射的矩形值。</p>
<p>映射中使用了项的以下属性：<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#x-prop">x</a>、<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#y-prop">y</a>、<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#scale-prop">scale</a>、<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#rotation-prop">rotation</a>、<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#transformOrigin-prop">transformOrigin</a>和<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qml-qtquick-item.html#transform-prop">transform</a>。</p>
<p>

<b>请参考</b><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qtquick-visualcanvas-coordinates.html">概念 - Qt Quick 中的视觉坐标</a>。</p>
<!-- @@@mapRectFromScene -->
<!-- $$$mapRectToItem[overload1]$$$mapRectToItemconstQQuickItem*constQRectF& -->
<h3 class="fn" id="mapRectToItem"><a name="mapRectToItem"></a><span class="type"><a href="../qtcore/qrectf.html">QRectF</a></span> QQuickItem::<span class="name">mapRectToItem</span>(const <span class="type"><a href="qquickitem.html#QQuickItem">QQuickItem</a></span> *<i>item</i>, const <span class="type"><a href="../qtcore/qrectf.html">QRectF</a></span> &amp;<i>rect</i>) const</h3>
<p>将 item 坐标系中的给定<i>rect映射到item</i>坐标系中的等效矩形区域，并返回映射的矩形值。</p>
<p>映射中使用了项的以下属性：<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#x-prop">x</a>、<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#y-prop">y</a>、<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#scale-prop">scale</a>、<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#rotation-prop">rotation</a>、<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#transformOrigin-prop">transformOrigin</a>和<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qml-qtquick-item.html#transform-prop">transform</a>。</p>
<p>如果<i>item</i>为 0，这会将<i>rect</i>映射到场景的坐标系。</p>
<p>

<b>请参考</b><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qtquick-visualcanvas-coordinates.html">概念 - Qt Quick 中的视觉坐标</a>。</p>
<!-- @@@mapRectToItem -->
<!-- $$$mapRectToScene[overload1]$$$mapRectToSceneconstQRectF& -->
<h3 class="fn" id="mapRectToScene"><a name="mapRectToScene"></a><span class="type"><a href="../qtcore/qrectf.html">QRectF</a></span> QQuickItem::<span class="name">mapRectToScene</span>(const <span class="type"><a href="../qtcore/qrectf.html">QRectF</a></span> &amp;<i>rect</i>) const</h3>
<p>将此项坐标系中的给定<i>矩形</i>映射到场景坐标系中的等效矩形区域，并返回映射的矩形值。</p>
<p>映射中使用了项的以下属性：<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#x-prop">x</a>、<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#y-prop">y</a>、<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#scale-prop">scale</a>、<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#rotation-prop">rotation</a>、<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#transformOrigin-prop">transformOrigin</a>和<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qml-qtquick-item.html#transform-prop">transform</a>。</p>
<p>

<b>请参考</b><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qtquick-visualcanvas-coordinates.html">概念 - Qt Quick 中的视觉坐标</a>。</p>
<!-- @@@mapRectToScene -->
<!-- $$$mapToGlobal[overload1]$$$mapToGlobalconstQPointF& -->
<h3 class="fn" id="mapToGlobal"><a name="mapToGlobal"></a><span class="type"><a href="../qtcore/qpointf.html">QPointF</a></span> QQuickItem::<span class="name">mapToGlobal</span>(const <span class="type"><a href="../qtcore/qpointf.html">QPointF</a></span> &amp;<i>point</i>) const</h3>
<p>将此项坐标系中的给定<i>point</i>映射到全局屏幕坐标系中的等效点，并返回映射后的坐标。</p>
<p>映射中使用了项的以下属性：<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#x-prop">x</a>、<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#y-prop">y</a>、<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#scale-prop">scale</a>、<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#rotation-prop">rotation</a>、<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#transformOrigin-prop">transformOrigin</a>和<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qml-qtquick-item.html#transform-prop">transform</a>。</p>
<p>例如，这可能有助于将弹出窗口添加到 Qt Quick 组件。</p>
<p><b>注意：</b>窗口定位由窗口管理器完成，此值仅作为提示处理。因此，生成的窗口位置可能与预期的不同。</p><p>该函数于Qt 5.7中引入。</p>
<p>

<b>请参考</b><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qtquick-visualcanvas-coordinates.html">概念 - Qt Quick 中的视觉坐标</a>。</p>
<!-- @@@mapToGlobal -->
<!-- $$$mapToItem[overload1]$$$mapToItemconstQQuickItem*constQPointF& -->
<h3 class="fn" id="mapToItem"><a name="mapToItem"></a><span class="type"><a href="../qtcore/qpointf.html">QPointF</a></span> QQuickItem::<span class="name">mapToItem</span>(const <span class="type"><a href="qquickitem.html#QQuickItem">QQuickItem</a></span> *<i>item</i>, const <span class="type"><a href="../qtcore/qpointf.html">QPointF</a></span> &amp;<i>point</i>) const</h3>
<p>将 item 坐标系中的<i>给定point映射到item</i>坐标系中的等效点，并返回映射后的坐标。</p>
<p>映射中使用了项的以下属性：<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#x-prop">x</a>、<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#y-prop">y</a>、<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#scale-prop">scale</a>、<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#rotation-prop">rotation</a>、<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#transformOrigin-prop">transformOrigin</a>和<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qml-qtquick-item.html#transform-prop">transform</a>。</p>
<p>如果<i>item</i> 为0，则将<i>point</i> 映射到场景的坐标系统。</p>
<p>

<b>请参考</b><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qtquick-visualcanvas-coordinates.html">概念 - Qt Quick 中的视觉坐标</a>。</p>
<!-- @@@mapToItem -->
<!-- $$$mapToScene[overload1]$$$mapToSceneconstQPointF& -->
<h3 class="fn" id="mapToScene"><a name="mapToScene"></a><span class="type"><a href="../qtcore/qpointf.html">QPointF</a></span> QQuickItem::<span class="name">mapToScene</span>(const <span class="type"><a href="../qtcore/qpointf.html">QPointF</a></span> &amp;<i>point</i>) const</h3>
<p>将此项坐标系中的<i>给定point</i>映射到场景坐标系中的等效点，并返回映射后的坐标。</p>
<p>映射中使用了项的以下属性：<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#x-prop">x</a>、<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#y-prop">y</a>、<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#scale-prop">scale</a>、<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#rotation-prop">rotation</a>、<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#transformOrigin-prop">transformOrigin</a>和<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qml-qtquick-item.html#transform-prop">transform</a>。</p>
<p>

<b>请参考</b><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qtquick-visualcanvas-coordinates.html">概念 - Qt Quick 中的视觉坐标</a>。</p>
<!-- @@@mapToScene -->
<!-- $$$mouseDoubleClickEvent[overload1]$$$mouseDoubleClickEventQMouseEvent* -->
<h3 class="fn" id="mouseDoubleClickEvent"><a name="mouseDoubleClickEvent"></a><code>[virtual protected] </code><span class="type">void</span> QQuickItem::<span class="name">mouseDoubleClickEvent</span>(<span class="type"><a href="../qtgui/qmouseevent.html">QMouseEvent</a></span> *<i>event</i>)</h3>
<p>此事件处理程序可以在子类中重新实现，以接收项的鼠标双击事件。事件信息由<i>event</i>参数提供。</p>
<p>默认情况下接受该事件，因此如果您重新实现此功能，则无需显式接受该事件。如果您不接受该事件，请调用<code>event-&gt;ignore()</code>。</p>
<!-- @@@mouseDoubleClickEvent -->
<!-- $$$mouseMoveEvent[overload1]$$$mouseMoveEventQMouseEvent* -->
<h3 class="fn" id="mouseMoveEvent"><a name="mouseMoveEvent"></a><code>[virtual protected] </code><span class="type">void</span> QQuickItem::<span class="name">mouseMoveEvent</span>(<span class="type"><a href="../qtgui/qmouseevent.html">QMouseEvent</a></span> *<i>event</i>)</h3>
<p>此事件处理程序可以在子类中重新实现，以接收项的鼠标移动事件。事件信息由<i>event</i>参数提供。</p>
<p>默认情况下接受该事件，因此如果您重新实现此功能，则无需显式接受该事件。如果您不接受该事件，请调用<code>event-&gt;ignore()</code>。</p>
<!-- @@@mouseMoveEvent -->
<!-- $$$mousePressEvent[overload1]$$$mousePressEventQMouseEvent* -->
<h3 class="fn" id="mousePressEvent"><a name="mousePressEvent"></a><code>[virtual protected] </code><span class="type">void</span> QQuickItem::<span class="name">mousePressEvent</span>(<span class="type"><a href="../qtgui/qmouseevent.html">QMouseEvent</a></span> *<i>event</i>)</h3>
<p>此事件处理程序可以在子类中重新实现，以接收项的鼠标按下事件。事件信息由<i>event</i>参数提供。</p>
<p>默认情况下接受该事件，因此如果您重新实现此功能，则无需显式接受该事件。如果您不接受该事件，请调用<code>event-&gt;ignore()</code>。</p>
<!-- @@@mousePressEvent -->
<!-- $$$mouseReleaseEvent[overload1]$$$mouseReleaseEventQMouseEvent* -->
<h3 class="fn" id="mouseReleaseEvent"><a name="mouseReleaseEvent"></a><code>[virtual protected] </code><span class="type">void</span> QQuickItem::<span class="name">mouseReleaseEvent</span>(<span class="type"><a href="../qtgui/qmouseevent.html">QMouseEvent</a></span> *<i>event</i>)</h3>
<p>此事件处理程序可以在子类中重新实现，以接收项的鼠标释放事件。事件信息由<i>event</i>参数提供。</p>
<p>默认情况下接受该事件，因此如果您重新实现此功能，则无需显式接受该事件。如果您不接受该事件，请调用<code>event-&gt;ignore()</code>。</p>
<!-- @@@mouseReleaseEvent -->
<!-- $$$mouseUngrabEvent[overload1]$$$mouseUngrabEvent -->
<h3 class="fn" id="mouseUngrabEvent"><a name="mouseUngrabEvent"></a><code>[virtual protected] </code><span class="type">void</span> QQuickItem::<span class="name">mouseUngrabEvent</span>()</h3>
<p>此事件处理程序可以在子类中重新实现，以便在此项上发生鼠标取消抓取事件时得到通知。</p>
<!-- @@@mouseUngrabEvent -->
<!-- $$$nextItemInFocusChain[overload1]$$$nextItemInFocusChainbool -->
<h3 class="fn" id="nextItemInFocusChain"><a name="nextItemInFocusChain"></a><span class="type"><a href="qquickitem.html#QQuickItem">QQuickItem</a></span> *QQuickItem::<span class="name">nextItemInFocusChain</span>(<span class="type">bool</span> <i>forward</i> = true)</h3>
<p>返回焦点链中与该项相邻的项。如果<i>forward</i>是<code>true</code>或未提供，则它是 forwards 方向的下一个项。如果<i>forward</i>是<code>false</code>，则它是向后方向的下一个项。</p>
<p><b>注意：</b>这个函数可以通过元对象系统和 QML 调用。请参阅<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtcore/qobject.html#Q_INVOKABLE">Q_INVOKABLE</a>。</p>
<!-- @@@nextItemInFocusChain -->
<!-- $$$polish[overload1]$$$polish -->
<h3 class="fn" id="polish"><a name="polish"></a><span class="type">void</span> QQuickItem::<span class="name">polish</span>()</h3>
<p>为这个项安排一个抛光事件。</p>
<p>当场景图处理请求时，会在这个item上调用<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#updatePolish">updatePolish ()。</a></p>
<!-- @@@polish -->
<!-- $$$releaseResources[overload1]$$$releaseResources -->
<h3 class="fn" id="releaseResources"><a name="releaseResources"></a><code>[virtual protected] </code><span class="type">void</span> QQuickItem::<span class="name">releaseResources</span>()</h3>
<p>当项应该释放尚未由<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#updatePaintNode">QQuickItem::updatePaintNode</a> () 返回的节点管理的图形资源时调用此函数。</p>
<p>当项即将从之前渲染到的窗口中移除时，就会发生这种情况。调用该函数时，该项保证有一个<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#window">窗口。</a></p>
<p>该函数在 GUI 线程上调用，渲染线程的状态在使用时是未知的。不应直接删除对象，而是使用<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickwindow.html#scheduleRenderJob">QQuickWindow::scheduleRenderJob</a> () 安排清理对象。</p>
<p><b>请参考</b><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#graphics-resource-handling">图形资源处理</a>。</p>
<!-- @@@releaseResources -->
<!-- $$$scopedFocusItem[overload1]$$$scopedFocusItem -->
<h3 class="fn" id="scopedFocusItem"><a name="scopedFocusItem"></a><span class="type"><a href="qquickitem.html#QQuickItem">QQuickItem</a></span> *QQuickItem::<span class="name">scopedFocusItem</span>() const</h3>
<p>如果此项是焦点范围，则返回其焦点链中当前具有焦点的项。</p>
<p>如果该项不是焦点范围，则返回<code>nullptr</code> 。</p>
<!-- @@@scopedFocusItem -->
<!-- $$$setAcceptHoverEvents[overload1]$$$setAcceptHoverEventsbool -->
<h3 class="fn" id="setAcceptHoverEvents"><a name="setAcceptHoverEvents"></a><span class="type">void</span> QQuickItem::<span class="name">setAcceptHoverEvents</span>(<span class="type">bool</span> <i>enabled</i>)</h3>
<p>如果<i>enabled</i>为真，这会将项设置为接受悬停事件；否则，此项不接受悬停事件。</p>
<p><b>请参考 </b><a href="qquickitem.html#acceptHoverEvents">acceptHoverEvents</a>()。</p>
<!-- @@@setAcceptHoverEvents -->
<!-- $$$setAcceptTouchEvents[overload1]$$$setAcceptTouchEventsbool -->
<h3 class="fn" id="setAcceptTouchEvents"><a name="setAcceptTouchEvents"></a><span class="type">void</span> QQuickItem::<span class="name">setAcceptTouchEvents</span>(<span class="type">bool</span> <i>enabled</i>)</h3>
<p>如果<i>enabled</i>为真，这会将项设置为接受触摸事件；否则，此项不接受触摸事件。</p>
<p>该函数于Qt 5.10中引入。</p>
<p><b>请参考 </b><a href="qquickitem.html#acceptTouchEvents">acceptTouchEvents</a>()。</p>
<!-- @@@setAcceptTouchEvents -->
<!-- $$$setAcceptedMouseButtons[overload1]$$$setAcceptedMouseButtonsQt::MouseButtons -->
<h3 class="fn" id="setAcceptedMouseButtons"><a name="setAcceptedMouseButtons"></a><span class="type">void</span> QQuickItem::<span class="name">setAcceptedMouseButtons</span>(<span class="type"><a href="../qtcore/qt.html#MouseButton-enum">Qt::MouseButtons</a></span> <i>buttons</i>)</h3>
<p>将此项接受的鼠标按钮设置为<i>buttons</i>。</p>
<p><b>请参考 </b><a href="qquickitem.html#acceptedMouseButtons">acceptedMouseButtons</a>()。</p>
<!-- @@@setAcceptedMouseButtons -->
<!-- $$$setCursor[overload1]$$$setCursorconstQCursor& -->
<h3 class="fn" id="setCursor"><a name="setCursor"></a><span class="type">void</span> QQuickItem::<span class="name">setCursor</span>(const <span class="type"><a href="../qtgui/qcursor.html">QCursor</a></span> &amp;<i>cursor</i>)</h3>
<p>设置此项的<i>cursor</i>形状。</p>
<p><b>请参考 </b><a href="qquickitem.html#cursor">cursor</a>() 和 <a href="qquickitem.html#unsetCursor">unsetCursor</a>()。</p>
<!-- @@@setCursor -->
<!-- $$$setFiltersChildMouseEvents[overload1]$$$setFiltersChildMouseEventsbool -->
<h3 class="fn" id="setFiltersChildMouseEvents"><a name="setFiltersChildMouseEvents"></a><span class="type">void</span> QQuickItem::<span class="name">setFiltersChildMouseEvents</span>(<span class="type">bool</span> <i>filter</i>)</h3>
<p>设置是否应通过此项过滤此项的子项的鼠标和触摸事件。</p>
<p>如果<i>filter</i>为真，<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#childMouseEventFilter">childMouseEventFilter</a> () 将在子项触发鼠标事件时被调用。</p>
<p><b>请参考 </b><a href="qquickitem.html#filtersChildMouseEvents">filtersChildMouseEvents</a>()。</p>
<!-- @@@setFiltersChildMouseEvents -->
<!-- $$$setFlag[overload1]$$$setFlagQQuickItem::Flagbool -->
<h3 class="fn" id="setFlag"><a name="setFlag"></a><span class="type">void</span> QQuickItem::<span class="name">setFlag</span>(<span class="type"><a href="qquickitem.html#Flag-enum">QQuickItem::Flag</a></span> <i>flag</i>, <span class="type">bool</span> <i>enabled</i> = true)</h3>
<p>如果<i>enabled</i>为 true，则启用此项的指定<i>flag；</i>如果<i>enabled</i>为 false，则禁用该标志。</p>
<p>这些为该项提供了各种提示；例如，<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#Flag-enum">ItemClipsChildrenToShape</a>标志指示该项的所有子项都应该被剪裁以适合项区域。</p>
<!-- @@@setFlag -->
<!-- $$$setFlags[overload1]$$$setFlagsQQuickItem::Flags -->
<h3 class="fn" id="setFlags"><a name="setFlags"></a><span class="type">void</span> QQuickItem::<span class="name">setFlags</span>(<span class="type"><a href="qquickitem.html#Flag-enum">QQuickItem::Flags</a></span> <i>flags</i>)</h3>
<p>启用此项的指定<i>flags</i>。</p>
<p><b>请参考 </b><a href="qquickitem.html#flags">flags</a>() 和 <a href="qquickitem.html#setFlag">setFlag</a>()。</p>
<!-- @@@setFlags -->
<!-- $$$setKeepMouseGrab[overload1]$$$setKeepMouseGrabbool -->
<h3 class="fn" id="setKeepMouseGrab"><a name="setKeepMouseGrab"></a><span class="type">void</span> QQuickItem::<span class="name">setKeepMouseGrab</span>(<span class="type">bool</span> <i>keep</i>)</h3>
<p>设置鼠标输入是否应独占此项。</p>
<p>这对于希望在预定义的手势之后抓取并保持鼠标交互的项很有用。例如，一旦超过阈值，对水平鼠标移动感兴趣的项可能<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#keepMouseGrab">会将 keepMouseGrab设置为 true。</a>一旦将<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#keepMouseGrab">keepMouseGrab</a>设置为 true，过滤项将不会对鼠标事件做出反应。</p>
<p>如果<i>keep</i>为 false，则过滤项可能会窃取抓取。例如，如果<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qml-qtquick-flickable.html">Flickable</a>检测到用户已经开始移动视口，它可能会尝试窃取鼠标抓取。</p>
<p><b>请参考 </b><a href="qquickitem.html#keepMouseGrab">keepMouseGrab</a>()。</p>
<!-- @@@setKeepMouseGrab -->
<!-- $$$setKeepTouchGrab[overload1]$$$setKeepTouchGrabbool -->
<h3 class="fn" id="setKeepTouchGrab"><a name="setKeepTouchGrab"></a><span class="type">void</span> QQuickItem::<span class="name">setKeepTouchGrab</span>(<span class="type">bool</span> <i>keep</i>)</h3>
<p>设置此项抓取的触摸点是否应独占此项。</p>
<p>这对于希望按照预定义手势抓取并保持特定触摸点的项很有用。例如，一旦超过阈值，对水平触摸点移动感兴趣的项可能会将 setKeepTouchGrab 设置为 true。一旦 setKeepTouchGrab 设置为 true，过滤项将不会对相关的触摸点做出反应。</p>
<p>如果<i>keep</i>为 false，则过滤项可能会窃取抓取。例如，如果<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qml-qtquick-flickable.html">Flickable</a>检测到用户已经开始移动视口，它可能会尝试窃取触摸点抓取。</p>
<p><b>请参考 </b><a href="qquickitem.html#keepTouchGrab">keepTouchGrab</a>() 和 <a href="qquickitem.html#setKeepMouseGrab">setKeepMouseGrab</a>()。</p>
<!-- @@@setKeepTouchGrab -->
<!-- $$$setSize[overload1]$$$setSizeconstQSizeF& -->
<h3 class="fn" id="setSize"><a name="setSize"></a><span class="type">void</span> QQuickItem::<span class="name">setSize</span>(const <span class="type"><a href="../qtcore/qsizef.html">QSizeF</a></span> &amp;<i>size</i>)</h3>
<p>将项的大小设置为<i>size</i>。</p>
<p>该函数于Qt 5.10中引入。</p>
<p><b>请参考</b> <a href="qquickitem.html#size">size</a>，<a href="qquickitem.html#width-prop">setWidth</a> 和 <a href="qquickitem.html#height-prop">setHeight</a>。</p>
<!-- @@@setSize -->
<!-- $$$size[overload1]$$$size -->
<h3 class="fn" id="size"><a name="size"></a><span class="type"><a href="../qtcore/qsizef.html">QSizeF</a></span> QQuickItem::<span class="name">size</span>() const</h3>
<p>回项的大小。</p>
<p>该函数于Qt 5.10中引入。</p>
<p><b>请参考</b> <a href="qquickitem.html#setSize">setSize</a>，<a href="qquickitem.html#width-prop">width</a> 和 <a href="qquickitem.html#height-prop">height</a>。</p>
<!-- @@@size -->
<!-- $$$stackAfter[overload1]$$$stackAfterconstQQuickItem* -->
<h3 class="fn" id="stackAfter"><a name="stackAfter"></a><span class="type">void</span> QQuickItem::<span class="name">stackAfter</span>(const <span class="type"><a href="qquickitem.html#QQuickItem">QQuickItem</a></span> *<i>sibling</i>)</h3>
<p>将指定的<i>sibling</i> 项移动到子项列表中此项之后的索引。子项的顺序会影响视觉堆叠顺序和选项卡焦点导航顺序。</p>
<p>假设两个项的 z 值相同，这将导致<i>sibling</i> 项在该项下方渲染。</p>
<p>如果两个项都将<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#activeFocusOnTab-prop">activeFocusOnTab</a>设置为<code>true</code>，这也会导致选项卡焦点顺序发生变化，<i>sibling</i>在此项之前获得焦点。</p>
<p>给定的<i>sibling</i> 必须是该项的<i>sibling</i> ；也就是说，它们必须具有相同的直接<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#parent-prop">父级</a>。</p>
<p><b>请参考 </b><a href="qtquick-visualcanvas-visualparent.html">概念 - Qt 
Quick中的可视父级</a>。</p>
<!-- @@@stackAfter -->
<!-- $$$stackBefore[overload1]$$$stackBeforeconstQQuickItem* -->
<h3 class="fn" id="stackBefore"><a name="stackBefore"></a><span class="type">void</span> QQuickItem::<span class="name">stackBefore</span>(const <span class="type"><a href="qquickitem.html#QQuickItem">QQuickItem</a></span> *<i>sibling</i>)</h3>
<p>将指定的<i>sibling</i> 项移动到子项列表中此项之前的索引。子项的顺序会影响视觉堆叠顺序和选项卡焦点导航顺序。</p>
<p>Assuming the z values of both items are the same, this will cause <i>sibling</i> to be rendered above this item.假设两个项的 z 值相同，这将导致<i>兄弟</i>项在该项上方渲染。</p>
<p>如果两个项都将<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#activeFocusOnTab-prop">activeFocusOnTab</a>设置为<code>true</code>，这也会导致选项卡焦点顺序发生变化，<i>sibling</i>在该项之后获得焦点。</p>
<p>给定的<i>sibling</i> 必须是该项的兄弟姐妹；也就是说，它们必须具有相同的直接<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#parent-prop">父级</a>。</p>
<p><b>请参考 </b><a href="qtquick-visualcanvas-visualparent.html">概念 - Qt 
Quick中的可视父级</a>。</p>
<!-- @@@stackBefore -->
<!-- $$$textureProvider[overload1]$$$textureProvider -->
<h3 class="fn" id="textureProvider"><a name="textureProvider"></a><code>[virtual] </code><span class="type"><a href="qsgtextureprovider.html">QSGTextureProvider</a></span> *QQuickItem::<span class="name">textureProvider</span>() const</h3>
<p>返回项的纹理提供程序。默认实现返回<code>nullptr</code>.</p>
<p>该函数只能在渲染线程上调用。</p>
<!-- @@@textureProvider -->
<!-- $$$touchEvent[overload1]$$$touchEventQTouchEvent* -->
<h3 class="fn" id="touchEvent"><a name="touchEvent"></a><code>[virtual protected] </code><span class="type">void</span> QQuickItem::<span class="name">touchEvent</span>(<span class="type"><a href="../qtgui/qtouchevent.html">QTouchEvent</a></span> *<i>event</i>)</h3>
<p>此事件处理程序可以在子类中重新实现以接收项的触摸事件。事件信息由<i>event</i>参数提供。</p>
<p>默认情况下接受该事件，因此如果您重新实现此功能，则无需显式接受该事件。如果您不接受该事件，请调用<code>event-&gt;ignore()</code>。</p>
<!-- @@@touchEvent -->
<!-- $$$touchUngrabEvent[overload1]$$$touchUngrabEvent -->
<h3 class="fn" id="touchUngrabEvent"><a name="touchUngrabEvent"></a><code>[virtual protected] </code><span class="type">void</span> QQuickItem::<span class="name">touchUngrabEvent</span>()</h3>
<p>此事件处理程序可以在子类中重新实现，以便在此项上发生触摸取消抓取事件时得到通知。</p>
<!-- @@@touchUngrabEvent -->
<!-- $$$ungrabMouse[overload1]$$$ungrabMouse -->
<h3 class="fn" id="ungrabMouse"><a name="ungrabMouse"></a><span class="type">void</span> QQuickItem::<span class="name">ungrabMouse</span>()</h3>
<p>在调用<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#grabMouse">grabMouse</a> () 后释放鼠标抓取。</p>
<p>请注意，仅当项想要停止处理更多事件时才应调用此函数。在释放或取消事件之后无需调用此函数，因为在任何情况下都不会收到未来的事件。调用此函数后，不会传递任何移动或释放事件。</p>
<!-- @@@ungrabMouse -->
<!-- $$$ungrabTouchPoints[overload1]$$$ungrabTouchPoints -->
<h3 class="fn" id="ungrabTouchPoints"><a name="ungrabTouchPoints"></a><span class="type">void</span> QQuickItem::<span class="name">ungrabTouchPoints</span>()</h3>
<p>取消抓取该项拥有的触摸点。</p>
<p><b>注意：</b>几乎没有任何理由调用这个函数。仅当项不想接收任何进一步的事件时才应调用它，因此调用此函数后不会传递任何移动或释放事件。</p><p><b>See also </b><a href="qquickitem.html#grabTouchPoints">grabTouchPoints</a>().</p>
<!-- @@@ungrabTouchPoints -->
<!-- $$$unsetCursor[overload1]$$$unsetCursor -->
<h3 class="fn" id="unsetCursor"><a name="unsetCursor"></a><span class="type">void</span> QQuickItem::<span class="name">unsetCursor</span>()</h3>
<p>清除此项的光标形状。</p>
<p><b>请参考 </b><a href="qquickitem.html#cursor">cursor</a>() 和 <a href="qquickitem.html#setCursor">setCursor</a>()。</p>
<!-- @@@unsetCursor -->
<!-- $$$update[overload1]$$$update -->
<h3 class="fn" id="update"><a name="update"></a><code>[slot] </code><span class="type">void</span> QQuickItem::<span class="name">update</span>()</h3>
<p>为此项安排对<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#updatePaintNode">updatePaintNode</a> ()的调用。</p>
<p>如果项显示在<a href="qquickwindow.html">QQuickWindow</a>中，调用<a href="qquickitem.html#updatePaintNode">QQuickItem::updatePaintNode</a>()将始终发生。</p>
<p>只有指定<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#Flag-enum">QQuickItem::ItemHasContents</a>的项才允许调用 QQuickItem::update()。</p>
<!-- @@@update -->
<!-- $$$updateInputMethod[overload1]$$$updateInputMethodQt::InputMethodQueries -->
<h3 class="fn" id="updateInputMethod"><a name="updateInputMethod"></a><code>[protected] </code><span class="type">void</span> QQuickItem::<span class="name">updateInputMethod</span>(<span class="type"><a href="../qtcore/qt.html#InputMethodQuery-enum">Qt::InputMethodQueries</a></span> <i>queries</i> = Qt::ImQueryInput)</h3>
<p>如果需要，通知输入法更新查询值。<i>queries</i>指示更改的属性。</p>
<!-- @@@updateInputMethod -->
<!-- $$$updatePaintNode[overload1]$$$updatePaintNodeQSGNode*QQuickItem::UpdatePaintNodeData* -->
<h3 class="fn" id="updatePaintNode"><a name="updatePaintNode"></a><code>[virtual protected] </code><span class="type"><a href="qsgnode.html">QSGNode</a></span> *QQuickItem::<span class="name">updatePaintNode</span>(<span class="type"><a href="qsgnode.html">QSGNode</a></span> *<i>oldNode</i>, <span class="type"><a href="qquickitem-updatepaintnodedata.html">QQuickItem::UpdatePaintNodeData</a></span> *<i>updatePaintNodeData</i>)</h3>
<p>当需要将项的状态与场景图同步时在渲染线程上调用。</p>
<p>如果用户在项上设置了<a href="qquickitem.html#Flag-enum">QQuickItem::ItemHasContents</a>标志，该函数将作为<a href="qquickitem.html#update">QQuickItem::update</a>()的结果被调用。</p>
<p>该函数应返回此项的场景图子树的根。大多数实现将返回一个<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qsggeometrynode.html">QSGGeometryNode</a>包含该项的可视化表示。<i>oldNode</i>是最后一次调用函数时返回的节点。<i>updatePaintNodeData</i>提供指向与此<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qsgtransformnode.html">QQuickItem</a>关联的<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html">QSGTransformNode</a>的指针。</p>
<pre class="cpp">

  <span class="type"><a href="qsgnode.html">QSGNode</a></span> <span class="operator">*</span>MyItem<span class="operator">::</span>updatePaintNode(<span class="type"><a href="qsgnode.html">QSGNode</a></span> <span class="operator">*</span>node<span class="operator">,</span> UpdatePaintNodeData <span class="operator">*</span>)
  {
      <span class="type"><a href="qsgsimplerectnode.html">QSGSimpleRectNode</a></span> <span class="operator">*</span>n <span class="operator">=</span> <span class="keyword">static_cast</span><span class="operator">&lt;</span><span class="type"><a href="qsgsimplerectnode.html">QSGSimpleRectNode</a></span> <span class="operator">*</span><span class="operator">&gt;</span>(node);
      <span class="keyword">if</span> (<span class="operator">!</span>n) {
          n <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qsgsimplerectnode.html">QSGSimpleRectNode</a></span>();
          n<span class="operator">-</span><span class="operator">&gt;</span>setColor(<span class="type">Qt</span><span class="operator">::</span>red);
      }
      n<span class="operator">-</span><span class="operator">&gt;</span>setRect(boundingRect());
      <span class="keyword">return</span> n;
  }

</pre>
<p>执行此函数时主线程被阻塞，因此从主线程中的<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html">QQuickItem</a>实例和其他对象中读取值是安全的。</p>
<p>如果没有调用 QQuickItem::updatePaintNode() 导致实际的场景图更改，例如<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qsgnode.html#markDirty">QSGNode::markDirty</a> () 或添加和删除节点，那么底层实现可能会决定不再渲染场景，因为视觉结果是相同的。</p>
<p><b>警告：</b> OpenGL 操作和与场景图的交互仅发生在渲染线程上是至关重要的，主要是在 QQuickItem::updatePaintNode() 调用期间。最好的经验法则是只在 QQuickItem::updatePaintNode() 函数中使用带有“QSG”前缀的类。</p>
<p><b>警告：</b>此函数在渲染线程上调用。这意味着创建的任何 QObjects 或线程本地存储都将与渲染线程有关联，因此在此函数中执行除渲染之外的任何操作时要小心。与信号类似，这些将在渲染线程上发出，因此通常通过排队连接传递。</p>
<p><b>注意：</b>所有带有 QSG 前缀的类都应该只在场景图的渲染线程上使用。有关详细信息，请参阅<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qtquick-visualcanvas-scenegraph.html#scene-graph-and-rendering">场景图和渲染</a>。</p><p>
	<b>请参考 </b><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qsgmaterial.html">QSGMaterial</a>、<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qsgsimplematerial.html">QSGSimpleMaterial</a>、<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qsggeometrynode.html">QSGGeometryNode</a>、<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qsggeometry.html">QSGGeometry</a>、<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qsgflatcolormaterial.html">QSGFlatColorMaterial</a>、<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qsgtexturematerial.html">QSGTextureMaterial</a>、<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qsgnode.html#markDirty">QSGNode::markDirty</a> () 和<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#graphics-resource-handling">图形资源处理</a>。</p>
<!-- @@@updatePaintNode -->
<!-- $$$updatePolish[overload1]$$$updatePolish -->
<h3 class="fn" id="updatePolish"><a name="updatePolish"></a><code>[virtual protected] </code><span class="type">void</span> QQuickItem::<span class="name">updatePolish</span>()</h3>
<p>此功能应执行此项所需的任何布局。</p>
<p>当调用<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#polish">polish</a> () 时，场景图会为此项安排一个波兰事件。当场景图准备好渲染此项时，它会调用 updatePolish() 以在渲染下一帧之前根据需要进行任何项布局。</p>
<!-- @@@updatePolish -->
<!-- $$$wheelEvent[overload1]$$$wheelEventQWheelEvent* -->
<h3 class="fn" id="wheelEvent"><a name="wheelEvent"></a><code>[virtual protected] </code><span class="type">void</span> QQuickItem::<span class="name">wheelEvent</span>(<span class="type"><a href="../qtgui/qwheelevent.html">QWheelEvent</a></span> *<i>event</i>)</h3>
<p>此事件处理程序可以在子类中重新实现，以接收项的轮子事件。事件信息由<i>event</i>参数提供。</p>
<p>默认情况下接受该事件，因此如果您重新实现此功能，则无需显式接受该事件。如果您不接受该事件，请调用<code>event-&gt;ignore()</code>。</p>
<!-- @@@wheelEvent -->
<!-- $$$widthValid[overload1]$$$widthValid -->
<h3 class="fn" id="widthValid"><a name="widthValid"></a><code>[protected] </code><span class="type">bool</span> QQuickItem::<span class="name">widthValid</span>() const</h3>
<p>返回是否明确设置了 width 属性。</p>
<!-- @@@widthValid -->
<!-- $$$window[overload1]$$$window -->
<h3 class="fn" id="window"><a name="window"></a><span class="type"><a href="qquickwindow.html">QQuickWindow</a></span> *QQuickItem::<span class="name">window</span>() const</h3>
<p>返回呈现此项的窗口。</p>
<p>该项在分配到场景之前没有窗口。windowChanged () 信号在项进入场景和从场景中移除时提供通知<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtquick/qquickitem.html#windowChanged">。</a></p>
<!-- @@@window -->
<!-- $$$windowChanged[overload1]$$$windowChangedQQuickWindow* -->
<h3 class="fn" id="windowChanged"><a name="windowChanged"></a><code>[signal] </code><span class="type">void</span> QQuickItem::<span class="name">windowChanged</span>(<span class="type"><a href="qquickwindow.html">QQuickWindow</a></span> *<i>window</i>)</h3>
<p>当项的<i>window</i> 发生变化时，将发出此信号。</p>
<!-- @@@windowChanged -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2019 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
