<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<!-- qwidget.cpp -->
  <title>QWidget Class | Qt Widgets 5.12.3</title>
  <link rel="stylesheet" type="text/css" href="style/offline-simple.css" />
  <script type="text/javascript">
    document.getElementsByTagName("link").item(0).setAttribute("href", "style/offline.css");
    // loading style sheet breaks anchors that were jumped to before
    // so force jumping to anchor again
    setTimeout(function() {
        var anchor = location.hash;
        // need to jump to different anchor first (e.g. none)
        location.hash = "#";
        setTimeout(function() {
            location.hash = anchor;
        }, 0);
    }, 0);
  </script>
</head>
<body>
<div class="header" id="qtdocheader">
  <div class="main">
    <div class="main-rounded">
      <div class="navigationbar">
        <table><tr>
<td ><a href="../qtdoc/index.html">Qt 5.12</a></td><td ><a href="qtwidgets-index.html">Qt Widgets</a></td><td ><a href="qtwidgets-module.html">C++ Classes</a></td><td >QWidget</td></tr></table><table class="buildversion"><tr>
<td id="buildversion" width="100%" align="right"><a href="qtwidgets-index.html">
Qt 5.12.3 <span lang="zh-cn">参考指南</span></a></td>
        </tr></table>
      </div>
    </div>
<div class="content">
<div class="line">
<div class="content mainContent">
<div class="sidebar">
<div class="toc">
<h3><span lang="zh-cn">目录</span></h3>
<ul>
<li class="level1"><a href="#public-types"><span lang="zh-cn">功用类型</span></a></li>
<li class="level1"><a href="#properties"><span lang="zh-cn">属性</span></a></li>
<li class="level1"><a href="#public-functions"><span lang="zh-cn">公用函数</span></a></li>
<li class="level1"><a href="#reimplemented-public-functions"><span lang="zh-cn">
重新实现的功用函数</span></a></li>
<li class="level1"><a href="#public-slots"><span lang="zh-cn">公用槽</span></a></li>
<li class="level1"><a href="#signals"><span lang="zh-cn">信号</span></a></li>
<li class="level1"><a href="#static-public-members"><span lang="zh-cn">静态共用成员</span></a></li>
<li class="level1"><a href="#protected-functions"><span lang="zh-cn">保护函数</span></a></li>
<li class="level1"><a href="#reimplemented-protected-functions">
<span lang="zh-cn">重新实现的保护函数</span></a></li>
<li class="level1"><a href="#protected-slots"><span lang="zh-cn">保护槽</span></a></li>
<li class="level1"><a href="#macros"><span lang="zh-cn">宏</span></a></li>
<li class="level1"><a href="#details"><span lang="zh-cn">详细信息</span></a></li>
<li class="level2"><a href="#top-level-and-child-widgets"><span lang="zh-cn">
顶级组件和子组件</span></a></li>
<li class="level2"><a href="#composite-widgets"><span lang="zh-cn">组合组件</span></a></li>
<li class="level2"><a href="#custom-widgets-and-painting">自定义<span lang="zh-cn">组件</span>和<span lang="zh-cn">绘制</span></a></li>
<li class="level2"><a href="#size-hints-and-size-policies">大小提示和大小策略</a></li>
<li class="level2"><a href="#events"><span lang="zh-cn">事件</span></a></li>
<li class="level2"><a href="#groups-of-functions-and-properties">函数和属性组</a></li>
<li class="level2"><a href="#widget-style-sheets"><span lang="zh-cn">组件样式表</span></a></li>
<li class="level2"><a href="#transparency-and-double-buffering">透明和双重缓冲</a></li>
<li class="level2"><a href="#creating-translucent-windows">创建半透明的窗口</a></li>
<li class="level2"><a href="#native-widgets-vs-alien-widgets">本地组件<span lang="zh-cn">vs</span>外来组件</a></li>
</ul>
</div>
<div class="sidebar-content" id="sidebar-content"></div></div>
<h1 class="title">QWidget <span lang="zh-cn">类</span></h1>
<!-- $$$QWidget-brief -->
<p><a href="qwidget.html">QWidget</a>类是所有用户界面对象的基类。 <a href="#details">
<span lang="zh-cn">更多</span>...</a></p>
<!-- @@@QWidget -->
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> <span lang="zh-cn">头文件</span>:</td><td class="memItemRight bottomAlign">   <span class="preprocessor">#include &lt;QWidget&gt;</span>
</td></tr><tr><td class="memItemLeft rightAlign topAlign"> qmake:</td><td class="memItemRight bottomAlign"> QT += widgets</td></tr><tr><td class="memItemLeft rightAlign topAlign"> 
	<span lang="zh-cn">继承自</span>:</td><td class="memItemRight bottomAlign"> <a href="../qtcore/qobject.html">QObject</a> 
	<span lang="zh-cn">和 </span><a href="../qtgui/qpaintdevice.html">QPaintDevice</a></td></tr><tr><td class="memItemLeft rightAlign topAlign"> 
		<span lang="zh-cn">被继承</span>:</td><td class="memItemRight bottomAlign"> <p><a href="qabstractbutton.html">QAbstractButton</a>, <a href="qabstractslider.html">QAbstractSlider</a>, <a href="qabstractspinbox.html">QAbstractSpinBox</a>, <a href="qcalendarwidget.html">QCalendarWidget</a>, <a href="qcombobox.html">QComboBox</a>, <a href="qdesktopwidget.html" class="obsolete">QDesktopWidget</a>, <a href="qdialog.html">QDialog</a>, <a href="qdialogbuttonbox.html">QDialogButtonBox</a>, <a href="qdockwidget.html">QDockWidget</a>, <a href="qfocusframe.html">QFocusFrame</a>, <a href="qframe.html">QFrame</a>, <a href="qgroupbox.html">QGroupBox</a>, <a href="qkeysequenceedit.html">QKeySequenceEdit</a>, <a href="qlineedit.html">QLineEdit</a>, <a href="qmainwindow.html">QMainWindow</a>, <a href="qmdisubwindow.html">QMdiSubWindow</a>, <a href="qmenu.html">QMenu</a>, <a href="qmenubar.html">QMenuBar</a>, <a href="qopenglwidget.html">QOpenGLWidget</a>, <a href="qprogressbar.html">QProgressBar</a>, <a href="qrubberband.html">QRubberBand</a>, <a href="qsizegrip.html">QSizeGrip</a>, <a href="qsplashscreen.html">QSplashScreen</a>, <a href="qsplitterhandle.html">QSplitterHandle</a>, <a href="qstatusbar.html">QStatusBar</a>, <a href="qtabbar.html">QTabBar</a>, <a href="qtabwidget.html">QTabWidget</a>, <a href="qtoolbar.html">QToolBar</a>, and <a href="qwizardpage.html">QWizardPage</a></p>
</td></tr></table></div><ul>
<li><a href="qwidget-members.html">所有成员的列表，包括继承成员</a></li>
<li><a href="qwidget-obsolete.html"><span lang="zh-cn">废弃</span>的成员</a></li>
</ul>
<a name="public-types"></a>
<h2 id="public-types"><span lang="zh-cn">功用类型</span></h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> enum </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#RenderFlag-enum">RenderFlag</a></b> { DrawWindowBackground, DrawChildren, IgnoreMask }</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> flags </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#RenderFlag-enum">RenderFlags</a></b></td></tr>
</table></div>
<a name="properties"></a>
<h2 id="properties"><span lang="zh-cn">属性</span></h2>
<div class="table"><table class="propsummary">
<tr><td class="topAlign"><ul>
<li class="fn"><b><a href="qwidget.html#acceptDrops-prop">acceptDrops</a></b> : bool</li>
<li class="fn"><b><a href="qwidget.html#accessibleDescription-prop">accessibleDescription</a></b> : QString</li>
<li class="fn"><b><a href="qwidget.html#accessibleName-prop">accessibleName</a></b> : QString</li>
<li class="fn"><b><a href="qwidget.html#autoFillBackground-prop">autoFillBackground</a></b> : bool</li>
<li class="fn"><b><a href="qwidget.html#baseSize-prop">baseSize</a></b> : QSize</li>
<li class="fn"><b><a href="qwidget.html#childrenRect-prop">childrenRect</a></b> : const QRect</li>
<li class="fn"><b><a href="qwidget.html#childrenRegion-prop">childrenRegion</a></b> : const QRegion</li>
<li class="fn"><b><a href="qwidget.html#contextMenuPolicy-prop">contextMenuPolicy</a></b> : Qt::ContextMenuPolicy</li>
<li class="fn"><b><a href="qwidget.html#cursor-prop">cursor</a></b> : QCursor</li>
<li class="fn"><b><a href="qwidget.html#enabled-prop">enabled</a></b> : bool</li>
<li class="fn"><b><a href="qwidget.html#focus-prop">focus</a></b> : const bool</li>
<li class="fn"><b><a href="qwidget.html#focusPolicy-prop">focusPolicy</a></b> : Qt::FocusPolicy</li>
<li class="fn"><b><a href="qwidget.html#font-prop">font</a></b> : QFont</li>
<li class="fn"><b><a href="qwidget.html#frameGeometry-prop">frameGeometry</a></b> : const QRect</li>
<li class="fn"><b><a href="qwidget.html#frameSize-prop">frameSize</a></b> : const QSize</li>
<li class="fn"><b><a href="qwidget.html#fullScreen-prop">fullScreen</a></b> : const bool</li>
<li class="fn"><b><a href="qwidget.html#geometry-prop">geometry</a></b> : QRect</li>
<li class="fn"><b><a href="qwidget.html#height-prop">height</a></b> : const int</li>
<li class="fn"><b><a href="qwidget.html#inputMethodHints-prop">inputMethodHints</a></b> : Qt::InputMethodHints</li>
<li class="fn"><b><a href="qwidget.html#isActiveWindow-prop">isActiveWindow</a></b> : const bool</li>
<li class="fn"><b><a href="qwidget.html#layoutDirection-prop">layoutDirection</a></b> : Qt::LayoutDirection</li>
<li class="fn"><b><a href="qwidget.html#locale-prop">locale</a></b> : QLocale</li>
<li class="fn"><b><a href="qwidget.html#maximized-prop">maximized</a></b> : const bool</li>
<li class="fn"><b><a href="qwidget.html#maximumHeight-prop">maximumHeight</a></b> : int</li>
<li class="fn"><b><a href="qwidget.html#maximumSize-prop">maximumSize</a></b> : QSize</li>
<li class="fn"><b><a href="qwidget.html#maximumWidth-prop">maximumWidth</a></b> : int</li>
<li class="fn"><b><a href="qwidget.html#minimized-prop">minimized</a></b> : const bool</li>
<li class="fn"><b><a href="qwidget.html#minimumHeight-prop">minimumHeight</a></b> : int</li>
<li class="fn"><b><a href="qwidget.html#minimumSize-prop">minimumSize</a></b> : QSize</li>
<li class="fn"><b><a href="qwidget.html#minimumSizeHint-prop">minimumSizeHint</a></b> : const QSize</li>
</ul></td><td class="topAlign"><ul>
<li class="fn"><b><a href="qwidget.html#minimumWidth-prop">minimumWidth</a></b> : int</li>
<li class="fn"><b><a href="qwidget.html#modal-prop">modal</a></b> : const bool</li>
<li class="fn"><b><a href="qwidget.html#mouseTracking-prop">mouseTracking</a></b> : bool</li>
<li class="fn"><b><a href="qwidget.html#normalGeometry-prop">normalGeometry</a></b> : const QRect</li>
<li class="fn"><b><a href="qwidget.html#palette-prop">palette</a></b> : QPalette</li>
<li class="fn"><b><a href="qwidget.html#pos-prop">pos</a></b> : QPoint</li>
<li class="fn"><b><a href="qwidget.html#rect-prop">rect</a></b> : const QRect</li>
<li class="fn"><b><a href="qwidget.html#size-prop">size</a></b> : QSize</li>
<li class="fn"><b><a href="qwidget.html#sizeHint-prop">sizeHint</a></b> : const QSize</li>
<li class="fn"><b><a href="qwidget.html#sizeIncrement-prop">sizeIncrement</a></b> : QSize</li>
<li class="fn"><b><a href="qwidget.html#sizePolicy-prop">sizePolicy</a></b> : QSizePolicy</li>
<li class="fn"><b><a href="qwidget.html#statusTip-prop">statusTip</a></b> : QString</li>
<li class="fn"><b><a href="qwidget.html#styleSheet-prop">styleSheet</a></b> : QString</li>
<li class="fn"><b><a href="qwidget.html#tabletTracking-prop">tabletTracking</a></b> : bool</li>
<li class="fn"><b><a href="qwidget.html#toolTip-prop">toolTip</a></b> : QString</li>
<li class="fn"><b><a href="qwidget.html#toolTipDuration-prop">toolTipDuration</a></b> : int</li>
<li class="fn"><b><a href="qwidget.html#updatesEnabled-prop">updatesEnabled</a></b> : bool</li>
<li class="fn"><b><a href="qwidget.html#visible-prop">visible</a></b> : bool</li>
<li class="fn"><b><a href="qwidget.html#whatsThis-prop">whatsThis</a></b> : QString</li>
<li class="fn"><b><a href="qwidget.html#width-prop">width</a></b> : const int</li>
<li class="fn"><b><a href="qwidget.html#windowFilePath-prop">windowFilePath</a></b> : QString</li>
<li class="fn"><b><a href="qwidget.html#windowFlags-prop">windowFlags</a></b> : Qt::WindowFlags</li>
<li class="fn"><b><a href="qwidget.html#windowIcon-prop">windowIcon</a></b> : QIcon</li>
<li class="fn"><b><a href="qwidget.html#windowModality-prop">windowModality</a></b> : Qt::WindowModality</li>
<li class="fn"><b><a href="qwidget.html#windowModified-prop">windowModified</a></b> : bool</li>
<li class="fn"><b><a href="qwidget.html#windowOpacity-prop">windowOpacity</a></b> : double</li>
<li class="fn"><b><a href="qwidget.html#windowTitle-prop">windowTitle</a></b> : QString</li>
<li class="fn"><b><a href="qwidget.html#x-prop">x</a></b> : const int</li>
<li class="fn"><b><a href="qwidget.html#y-prop">y</a></b> : const int</li>
</ul>
</td></tr>
</table></div>
<ul>
<li class="fn">1 property inherited from <a href="../qtcore/qobject.html#properties">QObject</a></li>
</ul>
<a name="public-functions"></a>
<h2 id="public-functions"><span lang="zh-cn">公用函数</span></h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#QWidget">QWidget</a></b>(QWidget *<i>parent</i> = nullptr, Qt::WindowFlags <i>f</i> = ...)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#dtor.QWidget">~QWidget</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#acceptDrops-prop">acceptDrops</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#accessibleDescription-prop">accessibleDescription</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#accessibleName-prop">accessibleName</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QList&lt;QAction *&gt; </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#actions">actions</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#activateWindow">activateWindow</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#addAction">addAction</a></b>(QAction *<i>action</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#addActions">addActions</a></b>(QList&lt;QAction *&gt; <i>actions</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#adjustSize">adjustSize</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#autoFillBackground-prop">autoFillBackground</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPalette::ColorRole </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#backgroundRole">backgroundRole</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QBackingStore *</td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#backingStore">backingStore</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSize </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#baseSize-prop">baseSize</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QWidget *</td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#childAt">childAt</a></b>(int <i>x</i>, int <i>y</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QWidget *</td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#childAt-1">childAt</a></b>(const QPoint &amp;<i>p</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRect </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#childrenRect-prop">childrenRect</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRegion </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#childrenRegion-prop">childrenRegion</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#clearFocus">clearFocus</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#clearMask">clearMask</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QMargins </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#contentsMargins">contentsMargins</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRect </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#contentsRect">contentsRect</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Qt::ContextMenuPolicy </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#contextMenuPolicy-prop">contextMenuPolicy</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QCursor </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#cursor-prop">cursor</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> WId </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#effectiveWinId">effectiveWinId</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#ensurePolished">ensurePolished</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Qt::FocusPolicy </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#focusPolicy-prop">focusPolicy</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QWidget *</td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#focusProxy">focusProxy</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QWidget *</td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#focusWidget">focusWidget</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QFont &amp;</td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#font-prop">font</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QFontInfo </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#fontInfo">fontInfo</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QFontMetrics </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#fontMetrics">fontMetrics</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPalette::ColorRole </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#foregroundRole">foregroundRole</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRect </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#frameGeometry-prop">frameGeometry</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSize </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#frameSize-prop">frameSize</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QRect &amp;</td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#geometry-prop">geometry</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#getContentsMargins">getContentsMargins</a></b>(int *<i>left</i>, int *<i>top</i>, int *<i>right</i>, int *<i>bottom</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPixmap </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#grab">grab</a></b>(const QRect &amp;<i>rectangle</i> = QRect(QPoint(0, 0), QSize(-1, -1)))</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#grabGesture">grabGesture</a></b>(Qt::GestureType <i>gesture</i>, Qt::GestureFlags <i>flags</i> = ...)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#grabKeyboard">grabKeyboard</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#grabMouse">grabMouse</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#grabMouse-1">grabMouse</a></b>(const QCursor &amp;<i>cursor</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#grabShortcut">grabShortcut</a></b>(const QKeySequence &amp;<i>key</i>, Qt::ShortcutContext <i>context</i> = Qt::WindowShortcut)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QGraphicsEffect *</td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#graphicsEffect">graphicsEffect</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QGraphicsProxyWidget *</td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#graphicsProxyWidget">graphicsProxyWidget</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#hasEditFocus">hasEditFocus</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#focus-prop">hasFocus</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#hasHeightForWidth">hasHeightForWidth</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#mouseTracking-prop">hasMouseTracking</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#tabletTracking-prop">hasTabletTracking</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#height-prop">height</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual int </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#heightForWidth">heightForWidth</a></b>(int <i>w</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Qt::InputMethodHints </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#inputMethodHints-prop">inputMethodHints</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QVariant </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#inputMethodQuery">inputMethodQuery</a></b>(Qt::InputMethodQuery <i>query</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#insertAction">insertAction</a></b>(QAction *<i>before</i>, QAction *<i>action</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#insertActions">insertActions</a></b>(QAction *<i>before</i>, QList&lt;QAction *&gt; <i>actions</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#isActiveWindow-prop">isActiveWindow</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#isAncestorOf">isAncestorOf</a></b>(const QWidget *<i>child</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#enabled-prop">isEnabled</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#isEnabledTo">isEnabledTo</a></b>(const QWidget *<i>ancestor</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#fullScreen-prop">isFullScreen</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#isHidden">isHidden</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#maximized-prop">isMaximized</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#minimized-prop">isMinimized</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#modal-prop">isModal</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#visible-prop">isVisible</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#isVisibleTo">isVisibleTo</a></b>(const QWidget *<i>ancestor</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#isWindow">isWindow</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#windowModified-prop">isWindowModified</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QLayout *</td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#layout">layout</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Qt::LayoutDirection </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#layoutDirection-prop">layoutDirection</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QLocale </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#locale-prop">locale</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPoint </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#mapFrom">mapFrom</a></b>(const QWidget *<i>parent</i>, const QPoint &amp;<i>pos</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPoint </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#mapFromGlobal">mapFromGlobal</a></b>(const QPoint &amp;<i>pos</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPoint </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#mapFromParent">mapFromParent</a></b>(const QPoint &amp;<i>pos</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPoint </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#mapTo">mapTo</a></b>(const QWidget *<i>parent</i>, const QPoint &amp;<i>pos</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPoint </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#mapToGlobal">mapToGlobal</a></b>(const QPoint &amp;<i>pos</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPoint </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#mapToParent">mapToParent</a></b>(const QPoint &amp;<i>pos</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRegion </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#mask">mask</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#maximumHeight-prop">maximumHeight</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSize </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#maximumSize-prop">maximumSize</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#maximumWidth-prop">maximumWidth</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#minimumHeight-prop">minimumHeight</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSize </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#minimumSize-prop">minimumSize</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QSize </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#minimumSizeHint-prop">minimumSizeHint</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#minimumWidth-prop">minimumWidth</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#pos-prop">move</a></b>(<i>const QPoint &amp;</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#move-1">move</a></b>(int <i>x</i>, int <i>y</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QWidget *</td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#nativeParentWidget">nativeParentWidget</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QWidget *</td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#nextInFocusChain">nextInFocusChain</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRect </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#normalGeometry-prop">normalGeometry</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#overrideWindowFlags">overrideWindowFlags</a></b>(Qt::WindowFlags <i>flags</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QPalette &amp;</td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#palette-prop">palette</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QWidget *</td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#parentWidget">parentWidget</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QPoint </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#pos-prop">pos</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QWidget *</td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#previousInFocusChain">previousInFocusChain</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRect </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#rect-prop">rect</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#releaseKeyboard">releaseKeyboard</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#releaseMouse">releaseMouse</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#releaseShortcut">releaseShortcut</a></b>(int <i>id</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#removeAction">removeAction</a></b>(QAction *<i>action</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#render">render</a></b>(QPaintDevice *<i>target</i>, const QPoint &amp;<i>targetOffset</i> = QPoint(), const QRegion &amp;<i>sourceRegion</i> = QRegion(), QWidget::RenderFlags <i>renderFlags</i> = ...)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#render-1">render</a></b>(QPainter *<i>painter</i>, const QPoint &amp;<i>targetOffset</i> = QPoint(), const QRegion &amp;<i>sourceRegion</i> = QRegion(), QWidget::RenderFlags <i>renderFlags</i> = ...)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#repaint-1">repaint</a></b>(int <i>x</i>, int <i>y</i>, int <i>w</i>, int <i>h</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#repaint-2">repaint</a></b>(const QRect &amp;<i>rect</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#repaint-3">repaint</a></b>(const QRegion &amp;<i>rgn</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#size-prop">resize</a></b>(<i>const QSize &amp;</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#resize-1">resize</a></b>(int <i>w</i>, int <i>h</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#restoreGeometry">restoreGeometry</a></b>(const QByteArray &amp;<i>geometry</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QByteArray </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#saveGeometry">saveGeometry</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#scroll">scroll</a></b>(int <i>dx</i>, int <i>dy</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#scroll-1">scroll</a></b>(int <i>dx</i>, int <i>dy</i>, const QRect &amp;<i>r</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#acceptDrops-prop">setAcceptDrops</a></b>(bool <i>on</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#accessibleDescription-prop">setAccessibleDescription</a></b>(const QString &amp;<i>description</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#accessibleName-prop">setAccessibleName</a></b>(const QString &amp;<i>name</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#setAttribute">setAttribute</a></b>(Qt::WidgetAttribute <i>attribute</i>, bool <i>on</i> = true)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#autoFillBackground-prop">setAutoFillBackground</a></b>(bool <i>enabled</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#setBackgroundRole">setBackgroundRole</a></b>(QPalette::ColorRole <i>role</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#baseSize-prop">setBaseSize</a></b>(<i>const QSize &amp;</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#setBaseSize-1">setBaseSize</a></b>(int <i>basew</i>, int <i>baseh</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#setContentsMargins">setContentsMargins</a></b>(int <i>left</i>, int <i>top</i>, int <i>right</i>, int <i>bottom</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#setContentsMargins-1">setContentsMargins</a></b>(const QMargins &amp;<i>margins</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#contextMenuPolicy-prop">setContextMenuPolicy</a></b>(Qt::ContextMenuPolicy <i>policy</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#cursor-prop">setCursor</a></b>(<i>const QCursor &amp;</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#setEditFocus">setEditFocus</a></b>(bool <i>enable</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#setFixedHeight">setFixedHeight</a></b>(int <i>h</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#setFixedSize">setFixedSize</a></b>(const QSize &amp;<i>s</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#setFixedSize-1">setFixedSize</a></b>(int <i>w</i>, int <i>h</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#setFixedWidth">setFixedWidth</a></b>(int <i>w</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#setFocus">setFocus</a></b>(Qt::FocusReason <i>reason</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#focusPolicy-prop">setFocusPolicy</a></b>(Qt::FocusPolicy <i>policy</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#setFocusProxy">setFocusProxy</a></b>(QWidget *<i>w</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#font-prop">setFont</a></b>(<i>const QFont &amp;</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#setForegroundRole">setForegroundRole</a></b>(QPalette::ColorRole <i>role</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#geometry-prop">setGeometry</a></b>(<i>const QRect &amp;</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#setGeometry-1">setGeometry</a></b>(int <i>x</i>, int <i>y</i>, int <i>w</i>, int <i>h</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#setGraphicsEffect">setGraphicsEffect</a></b>(QGraphicsEffect *<i>effect</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#inputMethodHints-prop">setInputMethodHints</a></b>(Qt::InputMethodHints <i>hints</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#setLayout">setLayout</a></b>(QLayout *<i>layout</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#layoutDirection-prop">setLayoutDirection</a></b>(Qt::LayoutDirection <i>direction</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#locale-prop">setLocale</a></b>(const QLocale &amp;<i>locale</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#setMask">setMask</a></b>(const QBitmap &amp;<i>bitmap</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#setMask-1">setMask</a></b>(const QRegion &amp;<i>region</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#maximumHeight-prop">setMaximumHeight</a></b>(int <i>maxh</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#maximumSize-prop">setMaximumSize</a></b>(<i>const QSize &amp;</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#setMaximumSize-1">setMaximumSize</a></b>(int <i>maxw</i>, int <i>maxh</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#maximumWidth-prop">setMaximumWidth</a></b>(int <i>maxw</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#minimumHeight-prop">setMinimumHeight</a></b>(int <i>minh</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#minimumSize-prop">setMinimumSize</a></b>(<i>const QSize &amp;</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#setMinimumSize-1">setMinimumSize</a></b>(int <i>minw</i>, int <i>minh</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#minimumWidth-prop">setMinimumWidth</a></b>(int <i>minw</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#mouseTracking-prop">setMouseTracking</a></b>(bool <i>enable</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#palette-prop">setPalette</a></b>(<i>const QPalette &amp;</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#setParent">setParent</a></b>(QWidget *<i>parent</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#setParent-1">setParent</a></b>(QWidget *<i>parent</i>, Qt::WindowFlags <i>f</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#setShortcutAutoRepeat">setShortcutAutoRepeat</a></b>(int <i>id</i>, bool <i>enable</i> = true)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#setShortcutEnabled">setShortcutEnabled</a></b>(int <i>id</i>, bool <i>enable</i> = true)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#sizeIncrement-prop">setSizeIncrement</a></b>(<i>const QSize &amp;</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#setSizeIncrement-1">setSizeIncrement</a></b>(int <i>w</i>, int <i>h</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#sizePolicy-prop">setSizePolicy</a></b>(<i>QSizePolicy</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#setSizePolicy-1">setSizePolicy</a></b>(QSizePolicy::Policy <i>horizontal</i>, QSizePolicy::Policy <i>vertical</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#statusTip-prop">setStatusTip</a></b>(<i>const QString &amp;</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#setStyle">setStyle</a></b>(QStyle *<i>style</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#tabletTracking-prop">setTabletTracking</a></b>(bool <i>enable</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#toolTip-prop">setToolTip</a></b>(<i>const QString &amp;</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#toolTipDuration-prop">setToolTipDuration</a></b>(int <i>msec</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#updatesEnabled-prop">setUpdatesEnabled</a></b>(bool <i>enable</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#whatsThis-prop">setWhatsThis</a></b>(<i>const QString &amp;</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#windowFilePath-prop">setWindowFilePath</a></b>(const QString &amp;<i>filePath</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#setWindowFlag">setWindowFlag</a></b>(Qt::WindowType <i>flag</i>, bool <i>on</i> = true)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#windowFlags-prop">setWindowFlags</a></b>(Qt::WindowFlags <i>type</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#windowIcon-prop">setWindowIcon</a></b>(const QIcon &amp;<i>icon</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#windowModality-prop">setWindowModality</a></b>(Qt::WindowModality <i>windowModality</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#windowOpacity-prop">setWindowOpacity</a></b>(qreal <i>level</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#setWindowRole">setWindowRole</a></b>(const QString &amp;<i>role</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#setWindowState">setWindowState</a></b>(Qt::WindowStates <i>windowState</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#setupUi">setupUi</a></b>(QWidget *<i>widget</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSize </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#size-prop">size</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual QSize </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#sizeHint-prop">sizeHint</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSize </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#sizeIncrement-prop">sizeIncrement</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QSizePolicy </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#sizePolicy-prop">sizePolicy</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#stackUnder">stackUnder</a></b>(QWidget *<i>w</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#statusTip-prop">statusTip</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QStyle *</td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#style">style</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#styleSheet-prop">styleSheet</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#testAttribute">testAttribute</a></b>(Qt::WidgetAttribute <i>attribute</i>) const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#toolTip-prop">toolTip</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#toolTipDuration-prop">toolTipDuration</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#underMouse">underMouse</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#ungrabGesture">ungrabGesture</a></b>(Qt::GestureType <i>gesture</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#cursor-prop">unsetCursor</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#layoutDirection-prop">unsetLayoutDirection</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#locale-prop">unsetLocale</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#update-1">update</a></b>(int <i>x</i>, int <i>y</i>, int <i>w</i>, int <i>h</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#update-2">update</a></b>(const QRect &amp;<i>rect</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#update-3">update</a></b>(const QRegion &amp;<i>rgn</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#updateGeometry">updateGeometry</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#updatesEnabled-prop">updatesEnabled</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QRegion </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#visibleRegion">visibleRegion</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#whatsThis-prop">whatsThis</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#width-prop">width</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> WId </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#winId">winId</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QWidget *</td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#window">window</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#windowFilePath-prop">windowFilePath</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Qt::WindowFlags </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#windowFlags-prop">windowFlags</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QWindow *</td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#windowHandle">windowHandle</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QIcon </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#windowIcon-prop">windowIcon</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Qt::WindowModality </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#windowModality-prop">windowModality</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> qreal </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#windowOpacity-prop">windowOpacity</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#windowRole">windowRole</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Qt::WindowStates </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#windowState">windowState</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QString </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#windowTitle-prop">windowTitle</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> Qt::WindowType </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#windowType">windowType</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#x-prop">x</a></b>() const</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> int </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#y-prop">y</a></b>() const</td></tr>
</table></div>
<a name="reimplemented-public-functions"></a>
<h2 id="reimplemented-public-functions"><span lang="zh-cn">重新实现的功用函数</span></h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> virtual QPaintEngine *</td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#paintEngine">paintEngine</a></b>() const override</td></tr>
</table></div>
<ul>
<li class="fn">31 <span lang="zh-cn">公用函数继承自</span> <a href="../qtcore/qobject.html#public-functions">QObject</a></li>
<li class="fn">14 <span lang="zh-cn">功用函数</span> <a href="../qtgui/qpaintdevice.html#public-functions">QPaintDevice</a></li>
</ul>
<a name="public-slots"></a>
<h2 id="public-slots"><span lang="zh-cn">功用槽</span></h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#close">close</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#hide">hide</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#lower">lower</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#raise">raise</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#repaint">repaint</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#setDisabled">setDisabled</a></b>(bool <i>disable</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#enabled-prop">setEnabled</a></b>(<i>bool</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#setFocus-1">setFocus</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#setHidden">setHidden</a></b>(bool <i>hidden</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#styleSheet-prop">setStyleSheet</a></b>(const QString &amp;<i>styleSheet</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#visible-prop">setVisible</a></b>(bool <i>visible</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#windowModified-prop">setWindowModified</a></b>(<i>bool</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#windowTitle-prop">setWindowTitle</a></b>(<i>const QString &amp;</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#show">show</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#showFullScreen">showFullScreen</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#showMaximized">showMaximized</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#showMinimized">showMinimized</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#showNormal">showNormal</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#update">update</a></b>()</td></tr>
</table></div>
<ul>
<li class="fn">1 <span lang="zh-cn">功用槽继承自</span> <a href="../qtcore/qobject.html#public-slots">QObject</a></li>
</ul>
<a name="signals"></a>
<h2 id="signals"><span lang="zh-cn">信号</span></h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#customContextMenuRequested">customContextMenuRequested</a></b>(const QPoint &amp;<i>pos</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#windowIconChanged">windowIconChanged</a></b>(const QIcon &amp;<i>icon</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#windowTitleChanged">windowTitleChanged</a></b>(const QString &amp;<i>title</i>)</td></tr>
</table></div>
<ul>
<li class="fn">2 <span lang="zh-cn">信号继承自</span> <a href="../qtcore/qobject.html#signals">QObject</a></li>
</ul>
<a name="static-public-members"></a>
<h2 id="static-public-members"><span lang="zh-cn">静态功用成员</span></h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> QWidget *</td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#createWindowContainer">createWindowContainer</a></b>(QWindow *<i>window</i>, QWidget *<i>parent</i> = nullptr, Qt::WindowFlags <i>flags</i> = ...)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QWidget *</td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#find">find</a></b>(WId <i>id</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QWidget *</td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#keyboardGrabber">keyboardGrabber</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> QWidget *</td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#mouseGrabber">mouseGrabber</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#setTabOrder">setTabOrder</a></b>(QWidget *<i>first</i>, QWidget *<i>second</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> const QMetaObject </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#staticMetaObject-var">staticMetaObject</a></b></td></tr>
</table></div>
<ul>
<li class="fn">9 <span lang="zh-cn">静态公用成员</span> <a href="../qtcore/qobject.html#static-public-members">QObject</a></li>
</ul>
<a name="protected-functions"></a>
<h2 id="protected-functions"><span lang="zh-cn">保护函数</span></h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#actionEvent">actionEvent</a></b>(QActionEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#changeEvent">changeEvent</a></b>(QEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#closeEvent">closeEvent</a></b>(QCloseEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#contextMenuEvent">contextMenuEvent</a></b>(QContextMenuEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#create">create</a></b>(WId <i>window</i> = 0, bool <i>initializeWindow</i> = true, bool <i>destroyOldWindow</i> = true)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#destroy">destroy</a></b>(bool <i>destroyWindow</i> = true, bool <i>destroySubWindows</i> = true)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#dragEnterEvent">dragEnterEvent</a></b>(QDragEnterEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#dragLeaveEvent">dragLeaveEvent</a></b>(QDragLeaveEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#dragMoveEvent">dragMoveEvent</a></b>(QDragMoveEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#dropEvent">dropEvent</a></b>(QDropEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#enterEvent">enterEvent</a></b>(QEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#focusInEvent">focusInEvent</a></b>(QFocusEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#focusNextChild">focusNextChild</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#focusNextPrevChild">focusNextPrevChild</a></b>(bool <i>next</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#focusOutEvent">focusOutEvent</a></b>(QFocusEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> bool </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#focusPreviousChild">focusPreviousChild</a></b>()</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#hideEvent">hideEvent</a></b>(QHideEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#inputMethodEvent">inputMethodEvent</a></b>(QInputMethodEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#keyPressEvent">keyPressEvent</a></b>(QKeyEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#keyReleaseEvent">keyReleaseEvent</a></b>(QKeyEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#leaveEvent">leaveEvent</a></b>(QEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#mouseDoubleClickEvent">mouseDoubleClickEvent</a></b>(QMouseEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#mouseMoveEvent">mouseMoveEvent</a></b>(QMouseEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#mousePressEvent">mousePressEvent</a></b>(QMouseEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#mouseReleaseEvent">mouseReleaseEvent</a></b>(QMouseEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#moveEvent">moveEvent</a></b>(QMoveEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#nativeEvent">nativeEvent</a></b>(const QByteArray &amp;<i>eventType</i>, void *<i>message</i>, long *<i>result</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#paintEvent">paintEvent</a></b>(QPaintEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#resizeEvent">resizeEvent</a></b>(QResizeEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#showEvent">showEvent</a></b>(QShowEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#tabletEvent">tabletEvent</a></b>(QTabletEvent *<i>event</i>)</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#wheelEvent">wheelEvent</a></b>(QWheelEvent *<i>event</i>)</td></tr>
</table></div>
<a name="reimplemented-protected-functions"></a>
<h2 id="reimplemented-protected-functions"><span lang="zh-cn">重新实现的保护函数</span></h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> virtual bool </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#event">event</a></b>(QEvent *<i>event</i>) override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#initPainter">initPainter</a></b>(QPainter *<i>painter</i>) const override</td></tr>
<tr><td class="memItemLeft rightAlign topAlign"> virtual int </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#metric">metric</a></b>(QPaintDevice::PaintDeviceMetric <i>m</i>) const override</td></tr>
</table></div>
<ul>
<li class="fn">9 protected functions inherited from <a href="../qtcore/qobject.html#protected-functions">QObject</a></li>
<li class="fn">1 protected function inherited from <a href="../qtgui/qpaintdevice.html#protected-functions">QPaintDevice</a></li>
</ul>
<a name="protected-slots"></a>
<h2 id="protected-slots"><span lang="zh-cn">公用槽</span></h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> void </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#updateMicroFocus">updateMicroFocus</a></b>()</td></tr>
</table></div>
<a name="macros"></a>
<h2 id="macros"><span lang="zh-cn">宏</span></h2>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft rightAlign topAlign"> </td><td class="memItemRight bottomAlign"><b><a href="qwidget.html#QWIDGETSIZE_MAX">QWIDGETSIZE_MAX</a></b></td></tr>
</table></div>
<a name="details"></a>
<!-- $$$QWidget-description -->
<div class="descr">
<h2 id="details"><span lang="zh-cn">详细信息</span></h2>
<p>&nbsp;<a href="qwidget.html">QWidget</a>类是所有用户界面对象的基类。</p>
<p>
组件是用户界面的原子（最小组成）:它接收来自窗口系统的鼠标、键盘和其他事件，并在屏幕上绘制自己的样子。每个组件都是矩形的，它们按照z轴顺序排序。一个组件被它的父组件和它前面的小组件剪裁。</p>
<p>没有嵌入到父组件中的组件称为窗口。通常，窗口有框架和标题栏，尽管也可以使用合适的<a href="../qtcore/qt.html#WindowType-enum">窗口标志</a>创建没有这种装饰的窗口)。在Qt中，<a href="qmainwindow.html">QMainWindow</a>和<a href="qdialog.html">QDialog</a>的各种子类是最常见的窗口类型。</p>
<p>每个组件的构造函数都接受一个或两个标准参数:</p>
<ol class="1" type="1"><li>&nbsp;<code>QWidget *parent = 0</code>是新组件的父组件。如果它是0(默认值)，则新小组件将是一个窗口。如果不是，它将是父节点的子节点，并受父节点几何形状的约束(除非指定<a href="../qtcore/qt.html#WindowType-enum">Qt::Window</a>为窗口标志)。</li>
<li><code>Qt::WindowFlags f = 0</code> <span lang="zh-cn">&nbsp;</span>(在可用的地方)设置窗口标志;默认值适用于几乎所有的组件，但是要获得没有窗口系统框架的窗口，必须使用特殊的标志。</li>
</ol>
<p>&nbsp;<a href="qwidget.html">QWidget</a>有很多成员函数，但其中一些没有直接的功能;例如，<a href="qwidget.html">QWidget</a>有一个字体属性，但它本身从不使用。有许多子类提供了真正的功能，如<a href="qlabel.html">QLabel</a>、<a href="qpushbutton.html">QPushButton</a>、<a href="qpushbutton.html">QPushButton</a>和<a href="qpushbutton.html">QPushButton</a>。</p>
<a name="top-level-and-child-widgets"></a>
<h3 ><span lang="zh-cn">顶级组件和子组件</span></h3>
<p>没有父组件的组件总是一个独立的窗口(顶级组件)。对于这些组件，<a href="qwidget.html#windowTitle-prop">setWindowTitle</a>()和<a href="qwidget.html#windowIcon-prop">setWindowIcon</a>()分别设置标题栏和图标。</p>
<p>非窗口组件是子组件，显示在它们的父组件中。Qt中的大多数组件主要用作子组件。例如，可以将按钮显示为顶级窗口，但大多数人更喜欢将按钮放在其他组件中，如<a href="qdialog.html">QDialog</a>。</p>
<p class="centerAlign"><img src="images/parent-child-widgets.png" alt="A parent widget containing various child widgets." /></p><p>
	上图显示了<a href="qgroupbox.html">QGroupBox</a><span lang="zh-cn">组件</span>用于在<a href="qgridlayout.html">QGridLayout</a>提供的布局中保存各种子组件。<span lang="zh-cn">这里用外边框标示了</span><a href="qlabel.html">QLabel</a>子组件，以表明它们的完整大小。</p>
<p>如果您想使用<a href="qwidget.html">QWidget</a>来容纳子组件，那么通常需要向父<a href="qwidget.html">QWidget</a>添加一个布局。有关更多信息，请参见<a href="layout.html">布局管理</a>。</p>
<a name="composite-widgets"></a>
<h3 ><span lang="zh-cn">组合组件</span></h3>
<p>当一个组件被用作容器来对多个组件件进行分组时，它被称为组合组件。这可以通过构建一个具有所需可视属性的组件(例如<a href="qframe.html">QFrame</a>)并向其添加子组件来创建，通常由布局管理。上面的图表显示了使用Qt 
Designer创建的组合组件。</p>
<p>组合组件也可以通过子类化标准组件(如<a href="qwidget.html">QWidget</a>或<a href="qframe.html">QFrame</a>)，并在子类的构造函数中添加必要的布局和子组件来创建。<a href="examples-widgets.html">Qt提供的许多示例</a>都使用这种方法，在Qt<a href="qtwidgets-index.html#tutorials">教程</a>中也有介绍。</p>
<h3 >自定义组件和<span lang="zh-cn">绘制</span></h3>
<p>由于<a href="qwidget.html">QWidget</a>是<a href="../qtgui/qpaintdevice.html">QPaintDevice</a>的子类，子类可用于显示使用一系列绘画操作与<a href="../qtgui/qpainter.html">QPainter</a>类的实例组成的自定义内容。这种方法与图形视图框架(<a href="graphicsview.html"><span lang="zh-cn">框架</span></a>)使用的画布风格方法不同，在后者中，项目由应用程序添加到场景中，并由框架本身渲染。</p>
<p>每个组件在其<a href="qwidget.html#paintEvent">paintEvent</a>()函数中执行所有绘制操作。每当组件需要重绘时(无论是由于外部更改还是应用程序请求)，都会调用这个函数。</p>
<p><span lang="zh-cn">8</span><a href="qtwidgets-widgets-analogclock-example.html">模拟时钟示例</a>展示了一个简单的组件如何处理绘制事件。</p>
<h3 >大小提示和大小策略</h3>
<p>当实现一个新的组件时，重新实现<a href="qwidget.html#sizeHint-prop">sizeHint</a>()为组件提供一个合理的默认大小并使用<a href="qwidget.html#sizePolicy-prop">setSizePolicy</a>()设置正确的大小策略几乎总是很有用的。</p>
<p>默认情况下，不提供大小提示的组合组件将根据其子组件的空间需求来调整大小。</p>
<p>
大小策略允许您为布局管理系统提供良好的默认行为，以便其他组件可以轻松地包含和管理您的布局。默认大小策略表示大小提示表示组件的首选大小，这对于许多组件来说通常已经足够了。</p>
<p><b>注意:</b>顶级组件的大小限制在桌面高度和宽度的2/3。<br>如果这些边界不充分，您可以<span lang="zh-cn">使用<a href="qwidget.html#size-prop">resize</a>()</span>手动调整组件的大小。</p><a name="events"></a>
<h3 ><span lang="zh-cn">事件</span></h3>
<p>组件响应通常由用户操作引起的事件。<br>Qt通过调用带有包含每个事件信息的<a href="../qtcore/qevent.html">QEvent</a>子类实例的特定事件处理程序函数，将事件交付给组件。</p>
<p>如果组件只包含子组件，则可能不需要实现任何事件处理程序。如果您想要检测子组件中的鼠标点击，请在组件的<a href="qwidget.html#mousePressEvent">mousePressEvent</a>()中调用子组件的<a href="qwidget.html#underMouse">underMouse</a>()函数。</p>
<p><a href="qtwidgets-widgets-scribble-example.html">Scribble示例</a>实现了更广泛的事件集，以处理鼠标移动、按钮按下和窗口大小调整。</p>
<p>你需要为你自己的组件提供行为和内容，但这里有一个与<a href="qwidget.html">QWidget</a>相关的事件的简要概述，从最常见的开始:</p>
<ul>
<li>每当组件需要重新绘制时，就会调用<a href="qwidget.html#paintEvent">paintEvent</a>()。每个显示自定义内容的组件都必须实现它。使用<a href="../qtgui/qpainter.html">QPainter</a>进行绘制只能在<a href="qwidget.html#paintEvent">paintEvent</a>()或由<a href="qwidget.html#paintEvent">paintEvent</a>()调用的函数中进行。</li>
<li><a href="qwidget.html#resizeEvent">resizeEvent</a>()在组件被调整大小时调用。</li>
<li>当鼠标光标在组件内部时按下鼠标按钮，或者当组件使用<a href="qwidget.html#grabMouse">grabMouse</a>()抓取鼠标时，将调用<a href="qwidget.html#mousePressEvent">mousePressEvent</a>()。<br>
按下鼠标而不释放它实际上与调用<a href="qwidget.html#grabMouse">grabMouse</a>()相同。</li>
<li>当鼠标按钮被释放时调用<a href="qwidget.html#mouseReleaseEvent">mouseReleaseEvent</a>()。当组件接收到相应的鼠标按下事件时，它将接收到鼠标释放事件。这意味着，如果用户在组件内按下鼠标，然后在释放鼠标按钮之前将鼠标拖动到其他地方，组件就会收到释放事件。有一个例外:如果鼠标按下时弹出菜单出现，这个弹出会立即窃取鼠标事件。</li>
<li>当用户在组件中双击时调用<a href="qwidget.html#mouseDoubleClickEvent">mouseDoubleClickEvent</a>()。如果用户双击，组件将收到一个鼠标按下事件、一个鼠标释放事件、(一个鼠标单击事件)、第二个鼠标按下事件、这个事件，最后是第二个鼠标释放事件。(如果在此操作期间鼠标没有保持稳定，也可能会收到一些鼠标移动事件。)在第二次单击到达之前，不可能区分单击和双击。(这就是为什么大多数GUI书籍都建议将双击作为单击的扩展，而不是触发不同的操作。)</li>
</ul>
<p>接受键盘输入的组件需要重新实现一些事件处理程序:</p>
<ul>
<li>每当键被按下时，就会调用<a href="qwidget.html#keyPressEvent">keyPressEvent</a>()，当键被按下的时间长到足以自动重复时，也会再次调用。如果焦点转换机制不使用<b>Tab</b>和<b>Shift+Tab</b>键，它们只会传递给组件。要强制组件处理这些键，必须重新实现<a href="qwidget.html#event">QWidget::event</a>()。</li>
<li>当组件获得键盘焦点时，将调用<a href="qwidget.html#focusInEvent">focusInEvent</a>()(假设您已经调用了<a href="qwidget.html#focusPolicy-prop">setFocusPolicy</a>())。行为良好的组件以一种清晰而谨慎的方式表明它们拥有键盘焦点。</li>
<li>当组件失去键盘焦点时调用<a href="qwidget.html#focusOutEvent">focusOutEvent</a>()。</li>
</ul>
<p>您可能还需要重新实现一些不太常见的事件处理程序:</p>
<ul>
<li>&nbsp;当按住鼠标按钮而鼠标移动时，将调用<a href="qwidget.html#mouseMoveEvent">mouseMoveEvent</a>()。这在拖放操作期间非常有用。如果调用<a href="qwidget.html#mouseTracking-prop">setMouseTracking</a>(true)，即使没有按下按钮，也会得到鼠标移动事件。(请参见<a href="graphicsview.html#drag-and-drop">拖放指南</a>。)</li>
<li><a href="qwidget.html#keyReleaseEvent">keyReleaseEvent</a>()在键被释放和按下时被调用(如果键是自动重复的)。在这种情况下，组件将为每次重复接收一对键释放和键按事件。如果焦点转换机制不使用<b>Tab</b> 
和<b>Shift+Tab</b>键，它们只会传递给组件。要强制组件处理这些键，必须重新实现<a href="qwidget.html#event">QWidget::event</a>()。</li>
<li>用户在组件有焦点时转动鼠标滚轮时，就会调用<a href="qwidget.html#wheelEvent">wheelEvent</a>()。</li>
<li>当鼠标进入组件的屏幕空间时调用<a href="qwidget.html#enterEvent">enterEvent</a>()。(这排除了组件的任何子组件所拥有的屏幕空间。)</li>
<li>当鼠标离开组件的屏幕空间时调用<a href="qwidget.html#leaveEvent">leaveEvent</a>()。如果鼠标进入一个子组件，它将不会引起<a href="qwidget.html#leaveEvent">leaveEvent</a>()。</li>
<li>当组件相对于其父组件移动时，将调用<a href="qwidget.html#moveEvent">moveEvent</a>()。</li>
<li>当用户关闭组件时(或当调用<a href="qwidget.html#close">close</a>()时)调用<a href="qwidget.html#closeEvent">closeEvent</a>()。</li>
</ul>
<p>在<a href="../qtcore/qevent.html#Type-enum">QEvent::Type</a>的文档中还描述了一些相当模糊的事件。要处理这些事件，需要直接重新实现<a href="qwidget.html#event">eve<span lang="zh-cn">nt</span></a>()。</p>
<p>event()的默认实现处理<b>Tab</b> 和<b>Shift+Tab</b> 
(移动键盘焦点)，并将大多数其他事件传递给上面的一个更专门的处理程序。</p>
<p>事件和用于交付它们的机制将在<a href="../qtcore/eventsandfilters.html">事件系统</a>中介绍。</p>
<a name="groups-of-functions-and-properties"></a>
<h3 >函数和属性组</h3>
<div class="table"><table class="generic">
 <thead><tr class="qt-style"><th >上下文</th><th ><span lang="zh-cn">函数</span>和属性</th></tr></thead>
<tr valign="top" class="odd"><td >窗口函数</td><td ><a href="qwidget.html#show">show</a>(), <a href="qwidget.html#hide">hide</a>(), <a href="qwidget.html#raise">raise</a>(), <a href="qwidget.html#lower">lower</a>(), <a href="qwidget.html#close">close</a>()<span lang="zh-cn">。</span></td></tr>
<tr valign="top" class="even"><td >顶层窗口</td><td ><a href="qwidget.html#windowModified-prop">windowModified</a>, <a href="qwidget.html#windowTitle-prop">windowTitle</a>, <a href="qwidget.html#windowIcon-prop">windowIcon</a>, <a href="qwidget.html#isActiveWindow-prop">isActiveWindow</a>, <a href="qwidget.html#activateWindow">activateWindow</a>(), <a href="qwidget.html#minimized-prop">minimized</a>, <a href="qwidget.html#showMinimized">showMinimized</a>(), <a href="qwidget.html#maximized-prop">maximized</a>, <a href="qwidget.html#showMaximized">showMaximized</a>(), <a href="qwidget.html#fullScreen-prop">fullScreen</a>, <a href="qwidget.html#showFullScreen">showFullScreen</a>(), <a href="qwidget.html#showNormal">showNormal</a>()<span lang="zh-cn">。</span></td></tr>
<tr valign="top" class="odd"><td >窗口内容</td><td ><a href="qwidget.html#update">update</a>(), <a href="qwidget.html#repaint">repaint</a>(), <a href="qwidget.html#scroll">scroll</a>()<span lang="zh-cn">。</span></td></tr>
<tr valign="top" class="even"><td >几何</td><td ><a href="qwidget.html#pos-prop">pos</a>, <a href="qwidget.html#x-prop">x</a>(), <a href="qwidget.html#y-prop">y</a>(), <a href="qwidget.html#rect-prop">rect</a>, <a href="qwidget.html#size-prop">size</a>, <a href="qwidget.html#width-prop">width</a>(), <a href="qwidget.html#height-prop">height</a>(), <a href="qwidget.html#pos-prop">move</a>(), <a href="qwidget.html#size-prop">resize</a>(), <a href="qwidget.html#sizePolicy-prop">sizePolicy</a>, <a href="qwidget.html#sizeHint-prop">sizeHint</a>(), <a href="qwidget.html#minimumSizeHint-prop">minimumSizeHint</a>(), <a href="qwidget.html#updateGeometry">updateGeometry</a>(), <a href="qwidget.html#layout">layout</a>(), <a href="qwidget.html#frameGeometry-prop">frameGeometry</a>, <a href="qwidget.html#geometry-prop">geometry</a>, <a href="qwidget.html#childrenRect-prop">childrenRect</a>, <a href="qwidget.html#childrenRegion-prop">childrenRegion</a>, <a href="qwidget.html#adjustSize">adjustSize</a>(), <a href="qwidget.html#mapFromGlobal">mapFromGlobal</a>(), <a href="qwidget.html#mapToGlobal">mapToGlobal</a>(), <a href="qwidget.html#mapFromParent">mapFromParent</a>(), <a href="qwidget.html#mapToParent">mapToParent</a>(), <a href="qwidget.html#maximumSize-prop">maximumSize</a>, <a href="qwidget.html#minimumSize-prop">minimumSize</a>, <a href="qwidget.html#sizeIncrement-prop">sizeIncrement</a>, <a href="qwidget.html#baseSize-prop">baseSize</a>, <a href="qwidget.html#setFixedSize">setFixedSize</a>()</td></tr>
<tr valign="top" class="odd"><td >模式</td><td ><a href="qwidget.html#visible-prop">visible</a>, <a href="qwidget.html#isVisibleTo">isVisibleTo</a>(), <a href="qwidget.html#enabled-prop">enabled</a>, <a href="qwidget.html#isEnabledTo">isEnabledTo</a>(), <a href="qwidget.html#modal-prop">modal</a>, <a href="qwidget.html#isWindow">isWindow</a>(), <a href="qwidget.html#mouseTracking-prop">mouseTracking</a>, <a href="qwidget.html#updatesEnabled-prop">updatesEnabled</a>, <a href="qwidget.html#visibleRegion">visibleRegion</a>()<span lang="zh-cn">。</span></td></tr>
<tr valign="top" class="even"><td >外观和感觉</td><td ><a href="qwidget.html#style">style</a>(), <a href="qwidget.html#setStyle">setStyle</a>(), <a href="stylesheet.html">styleSheet</a>, <a href="qwidget.html#cursor-prop">cursor</a>, <a href="stylesheet-reference.html#font">font</a>, <a href="qwidget.html#palette-prop">palette</a>, <a href="qwidget.html#backgroundRole">backgroundRole</a>(), <a href="qwidget.html#setBackgroundRole">setBackgroundRole</a>(), <a href="qwidget.html#fontInfo">fontInfo</a>(), <a href="qwidget.html#fontMetrics">fontMetrics</a>()<span lang="zh-cn">。</span></td></tr>
<tr valign="top" class="odd"><td >键盘焦点功能</td><td ><a href="qwidget.html#focus-prop">focus</a>, <a href="qwidget.html#focusPolicy-prop">focusPolicy</a>, <a href="qwidget.html#setFocus-1">setFocus</a>(), <a href="qwidget.html#clearFocus">clearFocus</a>(), <a href="qwidget.html#setTabOrder">setTabOrder</a>(), <a href="qwidget.html#setFocusProxy">setFocusProxy</a>(), <a href="qwidget.html#focusNextChild">focusNextChild</a>(), <a href="qwidget.html#focusPreviousChild">focusPreviousChild</a>()<span lang="zh-cn">。</span></td></tr>
<tr valign="top" class="even"><td >鼠标和键盘抓取</td><td ><a href="qwidget.html#grabMouse">grabMouse</a>(), <a href="qwidget.html#releaseMouse">releaseMouse</a>(), <a href="qwidget.html#grabKeyboard">grabKeyboard</a>(), <a href="qwidget.html#releaseKeyboard">releaseKeyboard</a>(), <a href="qwidget.html#mouseGrabber">mouseGrabber</a>(), <a href="qwidget.html#keyboardGrabber">keyboardGrabber</a>()<span lang="zh-cn">。</span></td></tr>
<tr valign="top" class="odd"><td >事件处理程序</td><td ><a href="qwidget.html#event">event</a>(), <a href="qwidget.html#mousePressEvent">mousePressEvent</a>(), <a href="qwidget.html#mouseReleaseEvent">mouseReleaseEvent</a>(), <a href="qwidget.html#mouseDoubleClickEvent">mouseDoubleClickEvent</a>(), <a href="qwidget.html#mouseMoveEvent">mouseMoveEvent</a>(), <a href="qwidget.html#keyPressEvent">keyPressEvent</a>(), <a href="qwidget.html#keyReleaseEvent">keyReleaseEvent</a>(), <a href="qwidget.html#focusInEvent">focusInEvent</a>(), <a href="qwidget.html#focusOutEvent">focusOutEvent</a>(), <a href="qwidget.html#wheelEvent">wheelEvent</a>(), <a href="qwidget.html#enterEvent">enterEvent</a>(), <a href="qwidget.html#leaveEvent">leaveEvent</a>(), <a href="qwidget.html#paintEvent">paintEvent</a>(), <a href="qwidget.html#moveEvent">moveEvent</a>(), <a href="qwidget.html#resizeEvent">resizeEvent</a>(), <a href="qwidget.html#closeEvent">closeEvent</a>(), <a href="qwidget.html#dragEnterEvent">dragEnterEvent</a>(), <a href="qwidget.html#dragMoveEvent">dragMoveEvent</a>(), <a href="qwidget.html#dragLeaveEvent">dragLeaveEvent</a>(), <a href="qwidget.html#dropEvent">dropEvent</a>(), <a href="../qtcore/qobject.html#childEvent">childEvent</a>(), <a href="qwidget.html#showEvent">showEvent</a>(), <a href="qwidget.html#hideEvent">hideEvent</a>(), <a href="../qtcore/qobject.html#customEvent">customEvent</a>(). <a href="qwidget.html#changeEvent">changeEvent</a>(),</td></tr>
<tr valign="top" class="even"><td >系统功能</td><td ><a href="qwidget.html#parentWidget">parentWidget</a>(), <a href="qwidget.html#window">window</a>(), <a href="qwidget.html#setParent">setParent</a>(), <a href="qwidget.html#winId">winId</a>(), <a href="qwidget.html#find">find</a>(), <a href="qwidget.html#metric">metric</a>()<span lang="zh-cn">。</span></td></tr>
<tr valign="top" class="odd"><td >上下文菜单</td><td ><a href="qwidget.html#contextMenuPolicy-prop">contextMenuPolicy</a>, <a href="qwidget.html#contextMenuEvent">contextMenuEvent</a>(), <a href="qwidget.html#customContextMenuRequested">customContextMenuRequested</a>(), <a href="qwidget.html#actions">actions</a>()</td></tr>
<tr valign="top" class="even"><td >交互式帮助</td><td ><a href="qwidget.html#toolTip-prop">setToolTip</a>(), <a href="qwidget.html#whatsThis-prop">setWhatsThis</a>()</td></tr>
</table></div>
<a name="widget-style-sheets"></a>
<h3 >组件样式表</h3>
<p>除了每个平台的标准组件样式外，还可以根据<a href="stylesheet.html">样式表</a>中指定的规则设置组件的样式。该特性使您能够自定义特定组件的外观，以向用户提供有关其用途的可视化提示。例如，可以以特定的方式设置按钮样式，以表明它执行破坏性操作。</p>
<p>组件样式表的使用在<a href="stylesheet.html">Qt样式表</a>文档中有更详细的描述。</p>
<h3 >透明和双重缓冲</h3>
<p>自Qt 4.0以来，<a href="qwidget.html">QWidget</a>自动双缓冲它的绘制，所以不需要在<a href="qwidget.html#paintEvent">paintEvent</a>()中编写双缓冲代码来避免闪烁。</p>
<p>从Qt 4.1开始，<a href="../qtcore/qt.html#WidgetAttribute-enum">Qt::WA_ContentsPropagated</a>组件属性已弃用。相反，只要没有设置<a href="../qtcore/qt.html#WidgetAttribute-enum">Qt::WA_PaintOnScreen</a>，默认情况下父组件的内容就会传递给它们的每个子组件。自定义组件可以通过更新不规则区域(创建非矩形子组件)或使用alpha组件不完整的颜色绘制来利用这个特性。下图显示了如何对自定义组件的属性和属性进行微调以达到不同的效果。</p>
<p class="centerAlign"><img src="images/propagation-custom.png" alt="" /></p>
	<p>在上面的图中，构造了一个带有移除区域的半透明矩形子组件，并将其添加到父组件(显示像素地图的<a href="qlabel.html">QLabel</a>)。然后，设置不同的属性和组件属性来实现不同的效果:</p>
<ul>
<li>左侧组件没有附加属性或组件属性设置。这种默认状态适合大多数使用透明、形状不规则或不使用不透明笔刷覆盖整个区域的自定义组件。</li>
<li>中心组件设置了<a href="qwidget.html#autoFillBackground-prop">autoFillBackground</a>属性。此属性用于自定义组件，这些组件依赖于该组件提供默认背景，并且不使用不透明的笔刷在其整个区域上绘制。</li>
<li>右边的组件设置了<a href="../qtcore/qt.html#WidgetAttribute-enum">Qt::WA_OpaquePaintEvent</a>组件属性。这表示组件将用不透明的颜色覆盖整个区域。组件的区域最初是未初始化的，在图中用一个红色的对角网格图案表示，它照亮了覆盖的区域。WA_OpaquePaintArea属性对于需要快速绘制自己的专用内容且不需要默认填充背景的组件很有用。</li>
</ul>
<p>快速更新与简单的背景颜色定制组件,比如实时绘制或图形组件,最好是定义一个合适的背景颜色(使用<a href="qwidget.html#setBackgroundRole">setBackgroundRole</a>()
<span lang="zh-cn">函数并使用</span><a href="../qtgui/qpalette.html#ColorRole-enum">QPalette::Window</a><span lang="zh-cn">参数</span>),设置<a href="qwidget.html#autoFillBackground-prop">autoFillBackground</a>属性,只有实现必要的绘图功能组件的<a href="qwidget.html#paintEvent">paintEvent</a>()。</p>
<p>为了快速更新自定义组件，这些组件经常用不透明的内容覆盖整个区域，例如视频流组件，最好设置组件的<a href="../qtcore/qt.html#WidgetAttribute-enum">Qt::WA_OpaquePaintEvent</a>，避免任何与重新绘制组件背景相关的不必要开销。</p>
<p>如果一个组件同时具有<a href="../qtcore/qt.html#WidgetAttribute-enum">Qt::WA_OpaquePaintEvent</a>组件属性和设置的<a href="qwidget.html#autoFillBackground-prop">autoFillBackground</a>属性，则<a href="../qtcore/qt.html#WidgetAttribute-enum">Qt::WA_OpaquePaintEvent</a>属性优先。根据您的需求，您应该选择其中之一。</p>
<p>从Qt 4.1开始，父组件的内容也传递到标准Qt组件。如果父组件以非标准的方式装饰，这可能会导致一些意想不到的结果，如下图所示。</p>
<p class="centerAlign"><img src="images/propagation-standard.png" alt="" /></p><p>
	在不使用子类化的情况下，定制标准Qt组件的绘制行为的范围略小于定制组件的范围。通常，标准组件的理想外观可以通过设置其<a href="qwidget.html#autoFillBackground-prop">autoFillBackground</a>属性来实现。</p>
<a name="creating-translucent-windows"></a>
<h3 >创建半透明的窗口</h3>
<p>从Qt 4.5开始，就可以在支持合成的窗口系统上创建带有半透明区域的窗口。</p>
<p>要在顶级组件中启用该特性，请使用<a href="qwidget.html#setAttribute">setAttribute</a>()设置其<a href="../qtcore/qt.html#WidgetAttribute-enum">Qt::WA_TranslucentBackground</a>属性，并确保在希望部分透明的区域中使用非不透明的颜色绘制背景。</p>
<p><span lang="zh-cn">注意平台：</span></p>
<ul>
<li>X11:该特性依赖于支持ARGB可视化和合成窗口管理器的X服务器。</li>
<li>窗口组件需要设置<a href="../qtcore/qt.html#WindowType-enum">Qt::FramelessWindowHint</a>窗口标志以使半透明工作。</li>
</ul>
<a name="native-widgets-vs-alien-widgets"></a>
<h3 >本地组件vs外来组件</h3>
<p>在Qt 4.4中引入的外来组件是窗口系统所不知道的组件。它们没有与之关联的本机窗口句柄。<br>此功能显著加快组件绘制、调整大小和消除闪烁。</p>
<p>如果您需要本机窗口的旧行为，您可以选择以下选项之一:</p>
<ol class="1" type="1"><li><span lang="zh-cn">在你的环境中使用</span> <code>QT_USE_NATIVE_WINDOWS=1</code> 
	<span lang="zh-cn">。</span></li>
<li>在应用程序中设置<a href="../qtcore/qt.html#ApplicationAttribute-enum">Qt::AA_NativeWindows</a>属性。所有组件都将是本机组件。</li>
<li>&nbsp;在组件上设置<a href="../qtcore/qt.html#WidgetAttribute-enum">Qt::WA_NativeWindow</a>属性:组件本身和它的所有祖先都将变成原生的(除非设置了<a href="../qtcore/qt.html#WidgetAttribute-enum">Qt::WA_DontCreateNativeAncestors</a>)。</li>
<li>调用<a href="qwidget.html#winId">QWidget::winId</a>来强制执行本地窗口(这意味着<span lang="zh-cn">与</span>3<span lang="zh-cn">一样</span>)。</li>
<li>设置<a href="../qtcore/qt.html#WidgetAttribute-enum">Qt::WA_PaintOnScreen</a>属性来强制执行一个本机窗口(这意味着<span lang="zh-cn">与</span>3<span lang="zh-cn">一样</span>)。</li>
</ol>
</div>
<p><b>请参考 </b><a href="../qtcore/qevent.html">QEvent</a>, <a href="../qtgui/qpainter.html">QPainter</a>, <a href="qgridlayout.html">QGridLayout</a>,
<span lang="zh-cn">和 </span><a href="qboxlayout.html">QBoxLayout</a><span lang="zh-cn">。</span></p>
<!-- @@@QWidget -->
<div class="types">
<h2><span lang="zh-cn">成员类型文档</span></h2>
<!-- $$$RenderFlag$$$DrawWindowBackground$$$DrawChildren$$$IgnoreMask -->
<h3 class="flags" id="RenderFlag-enum"><a name="RenderFlag-enum"></a>enum QWidget::<span class="name">RenderFlag</span><br/>flags QWidget::<span class="name">RenderFlags</span></h3>
<p>这个枚举描述了当调用<a href="qwidget.html#render">QWidget::render</a>()时如何<span lang="zh-cn">渲染</span>组件。</p>
<div class="table"><table class="valuelist"><tr valign="top" class="odd"><th class="tblConst">
	<span lang="zh-cn">约束</span></th><th class="tblval"><span lang="zh-cn">值</span></th><th class="tbldscr">
	<span lang="zh-cn">描述</span></th></tr>
<tr><td class="topAlign"><code>QWidget::DrawWindowBackground</code></td><td class="topAlign tblval"><code>0x1</code></td><td class="topAlign">
	如果启用这个选项，即使<a href="qwidget.html#autoFillBackground-prop">autoFillBackground</a>没有设置，组件的背景也会渲染到目标中。<br>
	默认情况下，该选项是启用的。</td></tr>
<tr><td class="topAlign"><code>QWidget::DrawChildren</code></td><td class="topAlign tblval"><code>0x2</code></td><td class="topAlign">
	如果启用此选项，组件的子组件将递归渲染到目标中。<br>默认情况下，该选项是启用的。</td></tr>
<tr><td class="topAlign"><code>QWidget::IgnoreMask</code></td><td class="topAlign tblval"><code>0x4</code></td><td class="topAlign">
	如果启用此选项，在渲染到目标时，组件的<a href="qwidget.html#mask">QWidget::mask</a>()将被忽略。默认情况下，该选项是禁用的。</td></tr>
</table></div>
<p>这个<span lang="zh-cn">宏</span>在Qt 4.3中被引入或修改。</p>
<p>RenderFlags类型是<a href="../qtcore/qflags.html">QFlags</a>&lt;RenderFlag&gt;的类型定义。它存储RenderFlag值的OR组合。</p>
<!-- @@@RenderFlag -->
</div>
<div class="prop">
<h2>属性的文档</h2>
<!-- $$$acceptDrops-prop$$$acceptDrops$$$setAcceptDropsbool -->
<h3 class="fn" id="acceptDrops-prop"><a name="acceptDrops-prop"></a><span class="name">acceptDrops</span> : <span class="type">bool</span></h3>
<p>此属性保存是否为该组件启用拖放事件</p>
<p>将此属性设置为true将向系统宣布此组件可能能够接受拖放事件。</p>
<p>如果组件是桌面(<a href="qwidget.html#windowType">windowType</a>() == <a href="../qtcore/qt.html#WindowType-enum">Qt::Desktop</a>)，这可能会失败，如果其他应用程序正在使用桌面;<br>
您可以调用acceptDrops()来测试是否发生这种情况。</p>
<p><b>警告:</b> 不要在拖放事件处理程序中修改此属性。</p>
<p>默认情况下，该属性为<code>false</code>。</p>
<p><b><span lang="zh-cn">访问函数</span>:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><span class="name"><b>acceptDrops</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setAcceptDrops</b></span>(bool <i>on</i>)</td></tr>
</table></div>
<p><b>请参考 </b><a href="graphicsview.html#drag-and-drop"><span lang="zh-cn">拖拽</span></a><span lang="zh-cn">。</span></p>
<!-- @@@acceptDrops -->
<!-- $$$accessibleDescription-prop$$$accessibleDescription$$$setAccessibleDescriptionconstQString& -->
<h3 class="fn" id="accessibleDescription-prop"><a name="accessibleDescription-prop"></a><span class="name">accessibleDescription</span> : <span class="type"><a href="../qtcore/qstring.html">QString</a></span></h3>
<p>此属性保存辅助技术所看到的组件描述</p>
<p>组件的可访问描述应该传达组件的功能。虽然<a href="qwidget.html#accessibleName-prop">accessibleName</a>应该是一个简短的字符串(例如<b>Save</b>)，但是描述应该给出更多的上下文，例如<b>Saves the current document</b>。</p>
<p>这个属性必须<a href="../qtdoc/internationalization.html">localized</a><span lang="zh-cn">(本地化)</span>。</p>
<p>默认情况下，此属性包含一个空字符串，Qt返回使用工具提示来提供此信息。</p>
<p><b><span lang="zh-cn">访问函数</span>:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> QString </td><td class="memItemRight bottomAlign"><span class="name"><b>accessibleDescription</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setAccessibleDescription</b></span>(const QString &amp;<i>description</i>)</td></tr>
</table></div>
<p><b>请参考 </b><a href="qwidget.html#accessibleName-prop">QWidget::accessibleName</a> 
<span lang="zh-cn">和</span> <a href="../qtgui/qaccessibleinterface.html#text">QAccessibleInterface::text</a>()<span lang="zh-cn">。</span></p>
<!-- @@@accessibleDescription -->
<!-- $$$accessibleName-prop$$$accessibleName$$$setAccessibleNameconstQString& -->
<h3 class="fn" id="accessibleName-prop"><a name="accessibleName-prop"></a><span class="name">accessibleName</span> : <span class="type"><a href="../qtcore/qstring.html">QString</a></span></h3>
<p>此属性包含辅助技术所看到的组件名称</p>
<p>这是屏幕阅读器等辅助技术宣布这个组件的主要名称。对于大多数组件，不需要设置此属性。例如，对于<a href="qpushbutton.html">QPushButton</a>，将使用按钮的文本。</p>
<p>当组件不提供任何文本时，设置此属性非常重要。例如，只包含图标的按钮需要设置此属性以使用屏幕阅读器。名称应该是简短的，并且与组件传递的视觉信息等效。</p>
<p>这个属性必须<a href="../qtdoc/internationalization.html">localized</a><span lang="zh-cn">（</span>本地化<span lang="zh-cn">）</span>。</p>
<p>默认情况下，此属性包含一个空字符串。</p>
<p><b><span lang="zh-cn">访问函数</span>:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> QString </td><td class="memItemRight bottomAlign"><span class="name"><b>accessibleName</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setAccessibleName</b></span>(const QString &amp;<i>name</i>)</td></tr>
</table></div>
<p><b>请参考 </b><a href="qwidget.html#accessibleDescription-prop">QWidget::accessibleDescription</a> 
<span lang="zh-cn">和</span> <a href="../qtgui/qaccessibleinterface.html#text">QAccessibleInterface::text</a>()<span lang="zh-cn">。</span></p>
<!-- @@@accessibleName -->
<!-- $$$autoFillBackground-prop$$$autoFillBackground$$$setAutoFillBackgroundbool -->
<h3 class="fn" id="autoFillBackground-prop"><a name="autoFillBackground-prop"></a><span class="name">autoFillBackground</span> : <span class="type">bool</span></h3>
<p>此属性用于判断组件背景是否自动填充</p>
<p>如果启用，该属性将导致Qt在调用paint事件之前填充组件的背景。使用的颜色是由组件<a href="../qtgui/qpalette.html">palette</a><span lang="zh-cn">（</span>调色板<span lang="zh-cn">）</span>中的<a href="../qtgui/qpalette.html#ColorRole-enum">QPalette::Window</a>颜色角色定义的。</p>
<p>此外，Windows总是用<a href="../qtgui/qpalette.html#ColorRole-enum">QPalette::Window</a>填充，除非设置了WA_OpaquePaintEvent或WA_NoSystemBackground属性。</p>
<p>如果一个组件的父组件有一个静态的渐变背景，这个属性不能被关闭(即，设置为false)。</p>
<p><b>警告:</b> Use this property with caution in conjunction with . 在使用<a href="stylesheet.html">Qt样式表</a>时，请谨慎使用此属性。当组件的样式表具有有效的背景或边框图像时，此属性将自动禁用。</p>
<p>默认情况下，该属性为<code>false</code>。</p>
<p>这个属性在Qt 4.1中被引入。</p>
<p><b><span lang="zh-cn">访问函数</span>:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><span class="name"><b>autoFillBackground</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setAutoFillBackground</b></span>(bool <i>enabled</i>)</td></tr>
</table></div>
<p><b>请参考 </b><a href="../qtcore/qt.html#WidgetAttribute-enum">Qt::WA_OpaquePaintEvent</a>, <a href="../qtcore/qt.html#WidgetAttribute-enum">Qt::WA_NoSystemBackground</a>,
<span lang="zh-cn">和</span>
<a href="qwidget.html#transparency-and-double-buffering">透明和双重缓冲</a><span lang="zh-cn">。</span></p>
<!-- @@@autoFillBackground -->
<!-- $$$baseSize-prop$$$baseSize$$$setBaseSizeconstQSize&$$$setBaseSizeintint -->
<h3 class="fn" id="baseSize-prop"><a name="baseSize-prop"></a><span class="name">baseSize</span> : <span class="type"><a href="../qtcore/qsize.html">QSize</a></span></h3>
<p>此属性保存组件的基本大小</p>
<p>如果组件定义了<a href="qwidget.html#sizeIncrement-prop">sizeIncrement</a>()，则使用基本大小来计算适当的组件大小。</p>
<p>默认情况下，对于新创建的组件，该属性的宽度和高度为零。</p>
<p><b><span lang="zh-cn">访问函数</span>:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> QSize </td><td class="memItemRight bottomAlign"><span class="name"><b>baseSize</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setBaseSize</b></span>(<i>const QSize &amp;</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b><a href="qwidget.html#setBaseSize-1">setBaseSize</a></b></span>(int <i>basew</i>, int <i>baseh</i>)</td></tr>
</table></div>
<p><b>请参考 </b><a href="qwidget.html#sizeIncrement-prop">setSizeIncrement</a>()<span lang="zh-cn">。</span></p>
<!-- @@@baseSize -->
<!-- $$$childrenRect-prop$$$childrenRect -->
<h3 class="fn" id="childrenRect-prop"><a name="childrenRect-prop"></a><span class="name">childrenRect</span> : const <span class="type"><a href="../qtcore/qrect.html">QRect</a></span></h3>
<p>此属性保存组件的子组件的边界矩形</p>
<p>隐藏的孩子被排除在外。</p>
<p><font style="vertical-align: inherit;">况下，对于没有子项的组件，此属性包含位于原点的宽度和高度为零的矩形。</font></p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> QRect </td><td class="memItemRight bottomAlign"><span class="name"><b>childrenRect</b></span>() const</td></tr>
</table></div>
<p><b>请参考 </b><a href="qwidget.html#childrenRegion-prop">childrenRegion</a>()
<span lang="zh-cn">和</span><a href="qwidget.html#geometry-prop">geometry</a>()<span lang="zh-cn">。</span></p>
<!-- @@@childrenRect -->
<!-- $$$childrenRegion-prop$$$childrenRegion -->
<h3 class="fn" id="childrenRegion-prop"><a name="childrenRegion-prop"></a><span class="name">childrenRegion</span> : const <span class="type"><a href="../qtgui/qregion.html">QRegion</a></span></h3>
<p><font style="vertical-align: inherit;">此属性保存组件的子组件占用的组合区域</font></p>
<p><font style="vertical-align: inherit;">隐藏的孩子被排除在外。</font></p>
<p><font style="vertical-align: inherit;">默认情况下，对于没有子级的组件，此属性包含一个空区域。</font></p>
<p><b><font style="vertical-align: inherit;">访问<span lang="zh-cn">函数</span>：</font></b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> QRegion </td><td class="memItemRight bottomAlign"><span class="name"><b>childrenRegion</b></span>() const</td></tr>
</table></div>
<p><b>请参考 </b><a href="qwidget.html#childrenRect-prop">childrenRect</a>(), <a href="qwidget.html#geometry-prop">geometry</a>(),
<span lang="zh-cn">和</span> <a href="qwidget.html#mask">mask</a>()<span lang="zh-cn">。</span></p>
<!-- @@@childrenRegion -->
<!-- $$$contextMenuPolicy-prop$$$contextMenuPolicy$$$setContextMenuPolicyQt::ContextMenuPolicy -->
<h3 class="fn" id="contextMenuPolicy-prop"><a name="contextMenuPolicy-prop"></a><span class="name">contextMenuPolicy</span> : <span class="type"><a href="../qtcore/qt.html#ContextMenuPolicy-enum">Qt::ContextMenuPolicy</a></span></h3>
<p>how the widget shows a context menu</p>
<p><font style="vertical-align: inherit;">这个属性的默认值是</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtcore/qt.html#ContextMenuPolicy-enum"><font style="vertical-align: inherit;">Qt::DefaultContextMenu</font></a><font style="vertical-align: inherit;">，这意味着</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#contextMenuEvent"><font style="vertical-align: inherit;">contextMenuEvent</font></a><font style="vertical-align: inherit;"> () 处理程序被调用。其他值<span lang="zh-cn">还有</span></font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtcore/qt.html#ContextMenuPolicy-enum"><font style="vertical-align: inherit;">Qt::NoContextMenu</font></a><font style="vertical-align: inherit;">、</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtcore/qt.html#ContextMenuPolicy-enum"><font style="vertical-align: inherit;">Qt::PreventContextMenu</font></a><font style="vertical-align: inherit;">、</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtcore/qt.html#ContextMenuPolicy-enum"><font style="vertical-align: inherit;">Qt::ActionsContextMenu</font></a><font style="vertical-align: inherit;">和</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtcore/qt.html#ContextMenuPolicy-enum"><font style="vertical-align: inherit;">Qt::CustomContextMenu</font></a><font style="vertical-align: inherit;">。使用</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtcore/qt.html#ContextMenuPolicy-enum"><font style="vertical-align: inherit;">Qt::CustomContextMenu</font></a><font style="vertical-align: inherit;">，<span lang="zh-cn">将</span>发出信号</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#customContextMenuRequested"><font style="vertical-align: inherit;">customContextMenuRequested</font></a><font style="vertical-align: inherit;"> () 。</font></p>
<p><b><font style="vertical-align: inherit;">访问<span lang="zh-cn">函数</span>：</font></b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> Qt::ContextMenuPolicy </td><td class="memItemRight bottomAlign"><span class="name"><b>contextMenuPolicy</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setContextMenuPolicy</b></span>(Qt::ContextMenuPolicy <i>policy</i>)</td></tr>
</table></div>
<p><b>请参考 </b><a href="qwidget.html#contextMenuEvent">contextMenuEvent</a>(), <a href="qwidget.html#customContextMenuRequested">customContextMenuRequested</a>(),
<span lang="zh-cn">和 </span><a href="qwidget.html#actions">actions</a>()<span lang="zh-cn">。</span></p>
<!-- @@@contextMenuPolicy -->
<!-- $$$cursor-prop$$$cursor$$$setCursorconstQCursor&$$$unsetCursor -->
<h3 class="fn" id="cursor-prop"><a name="cursor-prop"></a><span class="name">cursor</span> : <span class="type"><a href="../qtgui/qcursor.html">QCursor</a></span></h3>
<p><font style="vertical-align: inherit;">此属性保存此组件的光标形状</font></p>
<p><font style="vertical-align: inherit;">当鼠标光标位于此组件上方时，它将渲染此形状。有关一系列有用的形状，请参阅</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtcore/qt.html#CursorShape-enum"><font style="vertical-align: inherit;">预定义的光标对象列表</font></a><font style="vertical-align: inherit;">。</font></p>
<p><font style="vertical-align: inherit;">编辑器组件可能会使用 I 型光标：</font></p>
<pre class="cpp">

  setCursor(<span class="type">Qt</span><span class="operator">::</span>IBeamCursor);

</pre>
<p><font style="vertical-align: inherit;">如果没有设置<span lang="zh-cn">光标</span>，或者在调用 
unsetCursor() 之后，则使用父<span lang="zh-cn">光标</span>。</font></p>
<p><font style="vertical-align: inherit;">默认情况下，该属性包含一个具有</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtcore/qt.html#CursorShape-enum"><font style="vertical-align: inherit;">Qt::ArrowCursor</font></a><font style="vertical-align: inherit;">形状的光标。</font></p>
<p>一些底层的窗口实现会在光标离开组件时重置光标，即使鼠标已经被捕获。如果您想为所有组件设置游标，即使是在窗口之外，请考虑<a href="../qtgui/qguiapplication.html#setOverrideCursor">QApplication::setOverrideCursor</a>()。</p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> QCursor </td><td class="memItemRight bottomAlign"><span class="name"><b>cursor</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setCursor</b></span>(<i>const QCursor &amp;</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>unsetCursor</b></span>()</td></tr>
</table></div>
<p><b>请参考 </b><a href="../qtgui/qguiapplication.html#setOverrideCursor">QApplication::setOverrideCursor</a>()<span lang="zh-cn">。</span></p>
<!-- @@@cursor -->
<!-- $$$enabled-prop$$$isEnabled$$$setEnabledbool -->
<h3 class="fn" id="enabled-prop"><a name="enabled-prop"></a><span class="name">enabled</span> : <span class="type">bool</span></h3>
<p><font style="vertical-align: inherit;">此属性保存是否启用组件</font></p>
<p><font style="vertical-align: inherit;">通常，启用的组件处理键盘和鼠标事件；禁用的组件不会。</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qabstractbutton.html"><font style="vertical-align: inherit;">QAbstractButton</font></a><font style="vertical-align: inherit;">例外。</font></p>
<p><font style="vertical-align: inherit;">某些组件在禁用时会以不同方式显示。例如，按钮可能会将其标签绘制为灰色。如果您的组件需要知道<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtcore/qevent.html#Type-enum">何时启</a>用或禁用，您可以使用<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtcore/qevent.html#Type-enum">QEvent::EnabledChange</a>类型的</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#changeEvent"><font style="vertical-align: inherit;">changeEvent</font></a><font style="vertical-align: inherit;"> () 。</font></p>
<p><font style="vertical-align: inherit;">禁用组件会隐式禁用其所有子组件。启用分别启用所有子组件，除非它们已被明确禁用。<span lang="zh-cn">当一个组件的</span>父组件仍处于禁用状态<span lang="zh-cn">时，</span>无法显式启用不是窗口的子组件。</font></p>
<p><font style="vertical-align: inherit;">默认情况下，此属性为</font><code>true</code><font style="vertical-align: inherit;">。</font></p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><span class="name"><b>isEnabled</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setEnabled</b></span>(<i>bool</i>)</td></tr>
</table></div>
<p><b>请参考 </b><a href="qwidget.html#isEnabledTo">isEnabledTo</a>(), <a href="../qtgui/qkeyevent.html">QKeyEvent</a>, <a href="../qtgui/qmouseevent.html">QMouseEvent</a>,
<span lang="zh-cn">和 </span><a href="qwidget.html#changeEvent">changeEvent</a>()<span lang="zh-cn">。</span></p>
<!-- @@@enabled -->
<!-- $$$focus-prop$$$hasFocus -->
<h3 class="fn" id="focus-prop"><a name="focus-prop"></a><span class="name">focus</span> : const <span class="type">bool</span></h3>
<p><font style="vertical-align: inherit;">此属性保存此组件（或其焦点代理）是否具有键盘输入焦点</font></p>
<p><font style="vertical-align: inherit;">默认情况下，此属性为</font><code>false</code><font style="vertical-align: inherit;">。</font></p>
<p><b><font style="vertical-align: inherit;">注意：</font></b><font style="vertical-align: inherit;">获取一个<span lang="zh-cn">组件</span>的这个属性的值相当于检查</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qapplication.html#focusWidget"><font style="vertical-align: inherit;">QApplication::focusWidget</font></a><font style="vertical-align: inherit;"> ()是否引用了这个<span lang="zh-cn">组件</span>。</font></p><p><b><font style="vertical-align: inherit;">
	访问<span lang="zh-cn">函数</span>：</font></b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><span class="name"><b>hasFocus</b></span>() const</td></tr>
</table></div>
<p><b>请参考 </b><a href="qwidget.html#setFocus-1">setFocus</a>(), <a href="qwidget.html#clearFocus">clearFocus</a>(), <a href="qwidget.html#focusPolicy-prop">setFocusPolicy</a>(),
<span lang="zh-cn">和 </span><a href="qapplication.html#focusWidget">QApplication::focusWidget</a>()<span lang="zh-cn">。</span></p>
<!-- @@@focus -->
<!-- $$$focusPolicy-prop$$$focusPolicy$$$setFocusPolicyQt::FocusPolicy -->
<h3 class="fn" id="focusPolicy-prop"><a name="focusPolicy-prop"></a><span class="name">focusPolicy</span> : <span class="type"><a href="../qtcore/qt.html#FocusPolicy-enum">Qt::FocusPolicy</a></span></h3>
<p><font style="vertical-align: inherit;">此属性保存组件接受键盘焦点的方式</font></p>
<p><font style="vertical-align: inherit;"><span lang="zh-cn">如果</span>策略是</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtcore/qt.html#FocusPolicy-enum"><font style="vertical-align: inherit;">Qt::TabFocus</font></a><span lang="zh-cn">，</span><font style="vertical-align: inherit;"><span lang="zh-cn">则</span>组件通过 Tab 键接受键盘焦点，</font><span lang="zh-cn">如果策略是</span><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtcore/qt.html#FocusPolicy-enum"><font style="vertical-align: inherit;">Qt::ClickFocus</font></a><span lang="zh-cn">，则</span><font style="vertical-align: inherit;">组件通过点击接受焦点，<span lang="zh-cn">如果策略是</span></font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtcore/qt.html#FocusPolicy-enum"><font style="vertical-align: inherit;">Qt::StrongFocus</font></a><span lang="zh-cn">，</span><font style="vertical-align: inherit;"><span lang="zh-cn">则</span>同时接受<span lang="zh-cn">点击和Tab</span>，<span lang="zh-cn">如果策略是</span></font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtcore/qt.html#FocusPolicy-enum"><font style="vertical-align: inherit;">Qt::NoFocus</font></a><font style="vertical-align: inherit;">（默认）<span lang="zh-cn">，则</span>它不接受<span lang="zh-cn">任何</span>焦点。</font></p>
<p><font style="vertical-align: inherit;">如果组件处理键盘事件，则必须为组件启用键盘焦点。这通常是通过组件的构造函数完成的。例如，</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qlineedit.html"><font style="vertical-align: inherit;">QLineEdit</font></a><font style="vertical-align: inherit;">构造函数调用 setFocusPolicy( </font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtcore/qt.html#FocusPolicy-enum"><font style="vertical-align: inherit;">Qt::StrongFocus</font></a><font style="vertical-align: inherit;"> )。</font></p>
<p><font style="vertical-align: inherit;">如果组件具有焦点代理，则焦点策略将传递到它。</font></p>
<p><b><font style="vertical-align: inherit;">访问<span lang="zh-cn">函数</span>：</font></b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> Qt::FocusPolicy </td><td class="memItemRight bottomAlign"><span class="name"><b>focusPolicy</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setFocusPolicy</b></span>(Qt::FocusPolicy <i>policy</i>)</td></tr>
</table></div>
<p><b>请参考 </b><a href="qwidget.html#focusInEvent">focusInEvent</a>(), <a href="qwidget.html#focusOutEvent">focusOutEvent</a>(), <a href="qwidget.html#keyPressEvent">keyPressEvent</a>(), <a href="qwidget.html#keyReleaseEvent">keyReleaseEvent</a>(),
<span lang="zh-cn">和</span><a href="qwidget.html#enabled-prop">enabled</a><span lang="zh-cn">。</span></p>
<!-- @@@focusPolicy -->
<!-- $$$font-prop$$$font$$$setFontconstQFont& -->
<h3 class="fn" id="font-prop"><a name="font-prop"></a><span class="name">font</span> : <span class="type"><a href="../qtgui/qfont.html">QFont</a></span></h3>
<p><font style="vertical-align: inherit;">此属性保存当前为组件设置的字体</font></p>
<p><font style="vertical-align: inherit;">描述组件请求的字体。该字体在渲染标准组件时由组件的样式使用，并且可用作确保自定义组件可以与本机平台的外观和感觉保持一致的一种方式。不同的平台或不同的样式为应用程序定义不同的字体是很常见的。</font></p>
<p><font style="vertical-align: inherit;">当您为组件分配新字体时，该字体的属性将与组件的默认字体组合以形成组件的最终字体。您可以调用</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#fontInfo"><font style="vertical-align: inherit;">fontInfo</font></a><font style="vertical-align: inherit;"> () 来获取组件最终字体的副本。最后的字体也用于初始化</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtgui/qpainter.html"><font style="vertical-align: inherit;">QPainter</font></a><font style="vertical-align: inherit;">的字体。</font></p>
<p>默认值取决于系统环境。<br>QApplication维护一个系统/主题字体，它作为所有组件的默认字体。<br>
对于某些类型的组件，可能还有特殊的默认字体。<br>您还可以通过将自定义字体和组件名称传递给QApplication::setFont()来为组件定义默认字体。<br>
最后，将字体与Qt的字体数据库进行匹配，以找到最佳匹配。</p>
<p><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html"><font style="vertical-align: inherit;">QWidget</font></a><font style="vertical-align: inherit;">将显式字体属性从父级传递到子级。如果您更改字体的特定属性并将该字体分配给组件，该属性将传递到组件的所有子项，覆盖该属性的任何系统默认值。请注意，除非启用了<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtcore/qt.html#WidgetAttribute-enum">Qt::WA_WindowPropagation</a>属性，否则默认情况下字体不会传递到窗口（请参阅</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#isWindow"><font style="vertical-align: inherit;">isWindow</font></a><font style="vertical-align: inherit;"> ()）。</font></p>
<p><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html"><font style="vertical-align: inherit;">QWidget</font></a><font style="vertical-align: inherit;">的字体传递类似于它的调色板传递。</font></p>
<p>
当前样式用于渲染所有标准Qt组件的内容，可以自由选择使用组件字体，或者在某些情况下，忽略它(部分或全部)。特别是，某些样式(如GTK样式、Mac样式和Windows 
Vista样式)会对组件字体进行特殊修改，以匹配平台的本机外观和感觉。因此，将属性赋给组件的字体并不一定会改变组件的外观。相反，您可以选择应用<a href="stylesheet.html">样式表</a>.</p>
<p><b><font style="vertical-align: inherit;">注意：</font></b><font style="vertical-align: inherit;">如果<span lang="zh-cn">同时使用</span>setFont() 
<span lang="zh-cn">和</span></font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtwidgets/stylesheet.html"><font style="vertical-align: inherit;">Qt 样式表，</font></a><font style="vertical-align: inherit;"><span lang="zh-cn">并且</span>设置冲突，<span lang="zh-cn">则有限使用</span>样式表。</font></p><p><b><font style="vertical-align: inherit;">
	访问<span lang="zh-cn">函数</span>：</font></b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> const QFont &amp;</td><td class="memItemRight bottomAlign"><span class="name"><b>font</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setFont</b></span>(<i>const QFont &amp;</i>)</td></tr>
</table></div>
<p><b>请参考 </b><a href="qwidget.html#fontInfo">fontInfo</a>() <span lang="zh-cn">
和</span> <a href="qwidget.html#fontMetrics">fontMetrics</a>()<span lang="zh-cn">。</span></p>
<!-- @@@font -->
<!-- $$$frameGeometry-prop$$$frameGeometry -->
<h3 class="fn" id="frameGeometry-prop"><a name="frameGeometry-prop"></a><span class="name">frameGeometry</span> : const <span class="type"><a href="../qtcore/qrect.html">QRect</a></span></h3>
<p><font style="vertical-align: inherit;">组件相对于其父级的几何形状，包括任何窗口框架</font></p>
<p><font style="vertical-align: inherit;">有关</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtwidgets/application-windows.html#window-geometry"><font style="vertical-align: inherit;">窗口几何</font></a><font style="vertical-align: inherit;">问题的概述，请参阅<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtwidgets/application-windows.html#window-geometry">窗口几何</a>文档。</font></p>
<p><font style="vertical-align: inherit;">默认情况下，此属性包含一个取决于用户平台和屏幕几何形状的值。</font></p>
<p><b><font style="vertical-align: inherit;">访问<span lang="zh-cn">函数</span>：</font></b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> QRect </td><td class="memItemRight bottomAlign"><span class="name"><b>frameGeometry</b></span>() const</td></tr>
</table></div>
<p><b>请参考 </b><a href="qwidget.html#geometry-prop">geometry</a>(), <a href="qwidget.html#x-prop">x</a>(), <a href="qwidget.html#y-prop">y</a>(),
<span lang="zh-cn">和</span> <a href="qwidget.html#pos-prop">pos</a>()<span lang="zh-cn">。</span></p>
<!-- @@@frameGeometry -->
<!-- $$$frameSize-prop$$$frameSize -->
<h3 class="fn" id="frameSize-prop"><a name="frameSize-prop"></a><span class="name">frameSize</span> : const <span class="type"><a href="../qtcore/qsize.html">QSize</a></span></h3>
<p><font style="vertical-align: inherit;">此属性保存组件的大小，包括任何窗口框架</font></p>
<p><font style="vertical-align: inherit;">默认情况下，此属性包含一个取决于用户平台和屏幕几何形状的值。</font></p>
<p><b><font style="vertical-align: inherit;">访问<span lang="zh-cn">函数</span>：</font></b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> QSize </td><td class="memItemRight bottomAlign"><span class="name"><b>frameSize</b></span>() const</td></tr>
</table></div>
<!-- @@@frameSize -->
<!-- $$$fullScreen-prop$$$isFullScreen -->
<h3 class="fn" id="fullScreen-prop"><a name="fullScreen-prop"></a><span class="name">fullScreen</span> : const <span class="type">bool</span></h3>
<p><font style="vertical-align: inherit;">此属性保存组件是否以全屏模式显示</font></p>
<p><font style="vertical-align: inherit;">全屏模式下的组件占据整个屏幕区域，并且不显示窗口装饰，例如标题栏。</font></p>
<p><font style="vertical-align: inherit;">默认情况下，此属性为</font><code>false</code><font style="vertical-align: inherit;">。</font></p>
<p><b><font style="vertical-align: inherit;">访问<span lang="zh-cn">函数</span>：</font></b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><span class="name"><b>isFullScreen</b></span>() const</td></tr>
</table></div>
<p><b>请参考 </b><a href="qwidget.html#windowState">windowState</a>(), <a href="qwidget.html#minimized-prop">minimized</a>,
<span lang="zh-cn">和 </span><a href="qwidget.html#maximized-prop">maximized</a><span lang="zh-cn">。</span></p>
<!-- @@@fullScreen -->
<!-- $$$geometry-prop$$$geometry$$$setGeometryintintintint$$$setGeometryconstQRect& -->
<h3 class="fn" id="geometry-prop"><a name="geometry-prop"></a><span class="name">geometry</span> : <span class="type"><a href="../qtcore/qrect.html">QRect</a></span></h3>
<p><font style="vertical-align: inherit;">此属性保存组件相对于其父级的几何形状，不包括窗口框架</font></p>
<p><font style="vertical-align: inherit;">更改几何图形时，组件（如果可见）会立即接收移动事件（</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#moveEvent"><font style="vertical-align: inherit;">moveEvent</font></a><font style="vertical-align: inherit;"> ()）和/或调整大小事件（</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#resizeEvent"><font style="vertical-align: inherit;">resizeEvent</font></a><font style="vertical-align: inherit;"> ()）。如果组件当前不可见，则保证在显示之前接收适当的事件。</font></p>
<p><font style="vertical-align: inherit;">如果大小组件位于由</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#minimumSize-prop"><font style="vertical-align: inherit;">minimumSize</font></a><font style="vertical-align: inherit;"> () 和</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#maximumSize-prop"><font style="vertical-align: inherit;">maximumSize</font></a><font style="vertical-align: inherit;"> ()定义的范围之外，则会对其进行调整。</font></p>
<p><b><font style="vertical-align: inherit;">警告：</font></b><font style="vertical-align: inherit;">在</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#resizeEvent"><font style="vertical-align: inherit;">resizeEvent</font></a><font style="vertical-align: inherit;"> () 或</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#moveEvent"><font style="vertical-align: inherit;">moveEvent</font></a><font style="vertical-align: inherit;"> () 中调用 setGeometry( ) 会导致无限递归。</font></p>
<p><font style="vertical-align: inherit;">有关</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtwidgets/application-windows.html#window-geometry"><font style="vertical-align: inherit;">窗口几何</font></a><font style="vertical-align: inherit;">问题的概述，请参阅<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtwidgets/application-windows.html#window-geometry">窗口几何</a>文档。</font></p>
<p><font style="vertical-align: inherit;">默认情况下，此属性包含一个取决于用户平台和屏幕几何形状的值。</font></p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> const QRect &amp;</td><td class="memItemRight bottomAlign"><span class="name"><b>geometry</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b><a href="qwidget.html#setGeometry-1">setGeometry</a></b></span>(int <i>x</i>, int <i>y</i>, int <i>w</i>, int <i>h</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setGeometry</b></span>(<i>const QRect &amp;</i>)</td></tr>
</table></div>
<p><b><font style="vertical-align: inherit;">请参考</font></b><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#frameGeometry-prop"><font style="vertical-align: inherit;">frameGeometry</font></a><font style="vertical-align: inherit;"> ()、</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#rect-prop"><font style="vertical-align: inherit;">rect</font></a><font style="vertical-align: inherit;"> ()、</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#pos-prop"><font style="vertical-align: inherit;">move</font></a><font style="vertical-align: inherit;"> ()、</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#size-prop"><font style="vertical-align: inherit;">resize</font></a><font style="vertical-align: inherit;"> ()、</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#moveEvent"><font style="vertical-align: inherit;">moveEvent</font></a><font style="vertical-align: inherit;"> ()、</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#resizeEvent"><font style="vertical-align: inherit;">resizeEvent</font></a><font style="vertical-align: inherit;"> ()、</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#minimumSize-prop"><font style="vertical-align: inherit;">minimumSize</font></a><font style="vertical-align: inherit;"> ()和</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#maximumSize-prop"><font style="vertical-align: inherit;">maximumSize</font></a><font style="vertical-align: inherit;"> ()。</font></p>
<!-- @@@geometry -->
<!-- $$$height-prop$$$height -->
<h3 class="fn" id="height-prop"><a name="height-prop"></a><span class="name">height</span> : const <span class="type">int</span></h3>
<p><font style="vertical-align: inherit;">此属性保存组件的高度，不包括任何窗口框架</font></p>
<p><font style="vertical-align: inherit;">有关</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtwidgets/application-windows.html#window-geometry"><font style="vertical-align: inherit;">窗口几何</font></a><font style="vertical-align: inherit;">问题的概述，请参阅<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtwidgets/application-windows.html#window-geometry">窗口几何</a>文档。</font></p>
<p><b><font style="vertical-align: inherit;">注意：</font></b><font style="vertical-align: inherit;">请勿使用此功能在</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qdesktopwidget.html"><font style="vertical-align: inherit;">多屏桌面</font></a><font style="vertical-align: inherit;">上查找屏幕高度。有关详细信息，请阅读</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qdesktopwidget.html#screen-geometry"><font style="vertical-align: inherit;">此注<span lang="zh-cn">解</span>释</font></a><font style="vertical-align: inherit;">。</font></p><p><font style="vertical-align: inherit;">默认情况下，此属性包含一个取决于用户平台和屏幕几何形状的值。</font></p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> int </td><td class="memItemRight bottomAlign"><span class="name"><b>height</b></span>() const</td></tr>
</table></div>
<p><b>请参考 </b><a href="qwidget.html#geometry-prop">geometry</a>, <a href="qwidget.html#width-prop">width</a>,
<span lang="zh-cn">和 </span><a href="qwidget.html#size-prop">size</a><span lang="zh-cn">。</span></p>
<!-- @@@height -->
<!-- $$$inputMethodHints-prop$$$inputMethodHints$$$setInputMethodHintsQt::InputMethodHints -->
<h3 class="fn" id="inputMethodHints-prop"><a name="inputMethodHints-prop"></a><span class="name">inputMethodHints</span> : <span class="type"><a href="../qtcore/qt.html#InputMethodHint-enum">Qt::InputMethodHints</a></span></h3>
<p><font style="vertical-align: inherit;">组件具有什么<span lang="zh-cn">特定1</span>输入法提示。</font></p>
<p><font style="vertical-align: inherit;">这仅与输入组件相关。输入法使用它来检索有关输入法应如何操作的提示。例如，如果设置了</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtcore/qt.html#InputMethodHint-enum"><font style="vertical-align: inherit;">Qt::ImhFormattedNumbersOnly</font></a><font style="vertical-align: inherit;">标志，则输入法可能会更改其视觉组件以反映只能输入数字。</font></p>
<p><b><font style="vertical-align: inherit;">警告：</font></b><font style="vertical-align: inherit;">某些组件需要某些标志才能按预期工作。要设置标志，请执行</font><code>w-&gt;setInputMethodHints(w-&gt;inputMethodHints()|f)</code><font style="vertical-align: inherit;">而不是</font><code>w-&gt;setInputMethodHints(f)</code><font style="vertical-align: inherit;">。</font></p>
<p><b><font style="vertical-align: inherit;">注意：</font></b><font style="vertical-align: inherit;">标志只是提示，因此特定的输入法实现可以随意忽略它们。如果要确保输入某种<span lang="zh-cn">格式</span>的字符，还应该在组件上设置</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtgui/qvalidator.html"><font style="vertical-align: inherit;">QValidator</font></a><font style="vertical-align: inherit;">。</font></p><p><font style="vertical-align: inherit;">默认值为</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtcore/qt.html#InputMethodHint-enum"><font style="vertical-align: inherit;">Qt::ImhNone</font></a><font style="vertical-align: inherit;">。</font></p>
<p><font style="vertical-align: inherit;">这个属性是在 Qt 4.6 中引入的。</font></p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> Qt::InputMethodHints </td><td class="memItemRight bottomAlign"><span class="name"><b>inputMethodHints</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setInputMethodHints</b></span>(Qt::InputMethodHints <i>hints</i>)</td></tr>
</table></div>
<p><b>请参考 </b><a href="qwidget.html#inputMethodQuery">inputMethodQuery</a>()<span lang="zh-cn">。</span></p>
<!-- @@@inputMethodHints -->
<!-- $$$isActiveWindow-prop$$$isActiveWindow -->
<h3 class="fn" id="isActiveWindow-prop"><a name="isActiveWindow-prop"></a><span class="name">isActiveWindow</span> : const <span class="type">bool</span></h3>
<p><font style="vertical-align: inherit;">此属性保存此组件的窗口是否为活动窗口</font></p>
<p><font style="vertical-align: inherit;">活动窗口是包含具有键盘焦点的组件的窗口（如果窗口没有组件或没有任何组件接受键盘焦点，则该窗口可能仍具有焦点）。</font></p>
<p><font style="vertical-align: inherit;">当弹出窗口可见时，此属性</font><code>true</code><font style="vertical-align: inherit;">适用于活动窗口</font><i><font style="vertical-align: inherit;">和</font></i><font style="vertical-align: inherit;">弹出窗口。</font></p>
<p><font style="vertical-align: inherit;">默认情况下，此属性为</font><code>false</code><font style="vertical-align: inherit;">。</font></p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><span class="name"><b>isActiveWindow</b></span>() const</td></tr>
</table></div>
<p><b>请参考 </b><a href="qwidget.html#activateWindow">activateWindow</a>()
<span lang="zh-cn">和 </span><a href="qapplication.html#activeWindow">QApplication::activeWindow</a>()<span lang="zh-cn">。</span></p>
<!-- @@@isActiveWindow -->
<!-- $$$layoutDirection-prop$$$layoutDirection$$$setLayoutDirectionQt::LayoutDirection$$$unsetLayoutDirection -->
<h3 class="fn" id="layoutDirection-prop"><a name="layoutDirection-prop"></a><span class="name">layoutDirection</span> : <span class="type"><a href="../qtcore/qt.html#LayoutDirection-enum">Qt::LayoutDirection</a></span></h3>
<p>此属性保存此组件的布局方向</p>
<p><font style="vertical-align: inherit;">默认情况下，此属性<span lang="zh-cn">被</span>设置为</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtcore/qt.html#LayoutDirection-enum"><font style="vertical-align: inherit;">Qt::LeftToRight</font></a><font style="vertical-align: inherit;">。</font></p>
<p><font style="vertical-align: inherit;">当在组件上设置布局方向时，它将传播到组件的子级，但不会传播到作为窗口的子级，也不会传播到已显式调用 setLayoutDirection() 的子级。此外，在为父级调用 setLayoutDirection()</font><i><font style="vertical-align: inherit;">之后</font></i><font style="vertical-align: inherit;">添加的子组件不会继承父级的布局方向。</font></p>
<p><font style="vertical-align: inherit;">自 Qt 4.7 起，此方法不再影响文本布局方向。</font></p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> Qt::LayoutDirection </td><td class="memItemRight bottomAlign"><span class="name"><b>layoutDirection</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setLayoutDirection</b></span>(Qt::LayoutDirection <i>direction</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>unsetLayoutDirection</b></span>()</td></tr>
</table></div>
<p><b>请参考 </b><a href="../qtgui/qguiapplication.html#layoutDirection-prop">QApplication::layoutDirection</a><span lang="zh-cn">。</span></p>
<!-- @@@layoutDirection -->
<!-- $$$locale-prop$$$locale$$$setLocaleconstQLocale&$$$unsetLocale -->
<h3 class="fn" id="locale-prop"><a name="locale-prop"></a><span class="name">locale</span> : <span class="type"><a href="../qtcore/qlocale.html">QLocale</a></span></h3>
<p><font style="vertical-align: inherit;">此属性保存组件的语言环境</font></p>
<p><font style="vertical-align: inherit;">只要没有设置特殊语言环境，<span lang="zh-cn">可能继承</span>父语言环境或（如果此组件是顶级组件）<span lang="zh-cn">使用</span>默认语言环境。</font></p>
<p><font style="vertical-align: inherit;">如果组件显示日期或数字，则应使用组件的区域设置对其进行格式化。</font></p>
<p><font style="vertical-align: inherit;">这个属性是在 Qt 4.3 中引入的。</font></p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> QLocale </td><td class="memItemRight bottomAlign"><span class="name"><b>locale</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setLocale</b></span>(const QLocale &amp;<i>locale</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>unsetLocale</b></span>()</td></tr>
</table></div>
<p><b>请参考 </b><a href="../qtcore/qlocale.html">QLocale</a> and <a href="../qtcore/qlocale.html#setDefault">QLocale::setDefault</a>()<span lang="zh-cn">。</span></p>
<!-- @@@locale -->
<!-- $$$maximized-prop$$$isMaximized -->
<h3 class="fn" id="maximized-prop"><a name="maximized-prop"></a><span class="name">maximized</span> : const <span class="type">bool</span></h3>
<p><font style="vertical-align: inherit;">属性保存此组件是否最大化</font></p>
<p><font style="vertical-align: inherit;">此属性仅与窗口相关。</font></p>
<p><b><font style="vertical-align: inherit;">：</font></b><font style="vertical-align: inherit;">由于某些窗口系统的限制，这并不<span lang="zh-cn">会得到</span>预期的结果（例如，如果 X11 上的用户通过窗口管理器最大化窗口，Qt 无法将其与任何其他调整大小区分开来）。随着窗口管理器协议的发展，这有望得到改善。</font></p><p><font style="vertical-align: inherit;">默认情况下，此属性为</font><code>false</code><font style="vertical-align: inherit;">。</font></p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><span class="name"><b>isMaximized</b></span>() const</td></tr>
</table></div>
<p><b>请参考 </b><a href="qwidget.html#windowState">windowState</a>(), <a href="qwidget.html#showMaximized">showMaximized</a>(), <a href="qwidget.html#visible-prop">visible</a>, <a href="qwidget.html#show">show</a>(), <a href="qwidget.html#hide">hide</a>(), <a href="qwidget.html#showNormal">showNormal</a>(),
<span lang="zh-cn">和</span> <a href="qwidget.html#minimized-prop">minimized</a><span lang="zh-cn">。</span></p>
<!-- @@@maximized -->
<!-- $$$maximumHeight-prop$$$maximumHeight$$$setMaximumHeightint -->
<h3 class="fn" id="maximumHeight-prop"><a name="maximumHeight-prop"></a><span class="name">maximumHeight</span> : <span class="type">int</span></h3>
<p><font style="vertical-align: inherit;">此属性保存组件的最大高度（以像素为单位）</font></p>
<p><font style="vertical-align: inherit;">此属性对应于</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#maximumSize-prop"><font style="vertical-align: inherit;">maximumSize</font></a><font style="vertical-align: inherit;">属性所保持的高度。</font></p>
<p><font style="vertical-align: inherit;">默认情况下，此属性包含值 16777215。</font></p>
<p><b><font style="vertical-align: inherit;">注意：</font></b><code>QWIDGETSIZE_MAX</code><font style="vertical-align: inherit;">宏的定义限制了组件的最大尺寸。</font></p><p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> int </td><td class="memItemRight bottomAlign"><span class="name"><b>maximumHeight</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setMaximumHeight</b></span>(int <i>maxh</i>)</td></tr>
</table></div>
<p><b>请参考 </b><a href="qwidget.html#maximumSize-prop">maximumSize</a> 
<span lang="zh-cn">和 </span><a href="qwidget.html#maximumWidth-prop">maximumWidth</a><span lang="zh-cn">。</span></p>
<!-- @@@maximumHeight -->
<!-- $$$maximumSize-prop$$$maximumSize$$$setMaximumSizeconstQSize&$$$setMaximumSizeintint -->
<h3 class="fn" id="maximumSize-prop"><a name="maximumSize-prop"></a><span class="name">maximumSize</span> : <span class="type"><a href="../qtcore/qsize.html">QSize</a></span></h3>
<p><font style="vertical-align: inherit;">此属性保存组件的最大尺寸（以像素为单位）</font></p>
<p><font style="vertical-align: inherit;">组件的大小不能调整为比最大组件尺寸更大的尺寸。</font></p>
<p><font style="vertical-align: inherit;">默认情况下，此属性包含一个大小，其中宽度和高度的值为 16777215。</font></p>
<p><b><font style="vertical-align: inherit;">注意：</font></b><code>QWIDGETSIZE_MAX</code><font style="vertical-align: inherit;">宏的定义限制了组件的最大尺寸。</font></p><p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> QSize </td><td class="memItemRight bottomAlign"><span class="name"><b>maximumSize</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setMaximumSize</b></span>(<i>const QSize &amp;</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b><a href="qwidget.html#setMaximumSize-1">setMaximumSize</a></b></span>(int <i>maxw</i>, int <i>maxh</i>)</td></tr>
</table></div>
<p><b>请参考 </b><a href="qwidget.html#maximumWidth-prop">maximumWidth</a>, <a href="qwidget.html#maximumHeight-prop">maximumHeight</a>, <a href="qwidget.html#minimumSize-prop">minimumSize</a>,
<span lang="zh-cn">和 </span><a href="qwidget.html#sizeIncrement-prop">sizeIncrement</a><span lang="zh-cn">。</span></p>
<!-- @@@maximumSize -->
<!-- $$$maximumWidth-prop$$$maximumWidth$$$setMaximumWidthint -->
<h3 class="fn" id="maximumWidth-prop"><a name="maximumWidth-prop"></a><span class="name">maximumWidth</span> : <span class="type">int</span></h3>
<p><font style="vertical-align: inherit;">此属性保存组件的最大宽度（以像素为单位）</font></p>
<p><font style="vertical-align: inherit;">此属性对应于</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#maximumSize-prop"><font style="vertical-align: inherit;">maximumSize</font></a><font style="vertical-align: inherit;">属性所保持的宽度。</font></p>
<p><font style="vertical-align: inherit;">默认情况下，此属性包含值 16777215。</font></p>
<p><b><font style="vertical-align: inherit;">注意：</font></b><code>QWIDGETSIZE_MAX</code><font style="vertical-align: inherit;">宏的定义限制了组件的最大尺寸。</font></p><p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> int </td><td class="memItemRight bottomAlign"><span class="name"><b>maximumWidth</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setMaximumWidth</b></span>(int <i>maxw</i>)</td></tr>
</table></div>
<p><b>请参考 </b><a href="qwidget.html#maximumSize-prop">maximumSize</a> 
<span lang="zh-cn">和 </span><a href="qwidget.html#maximumHeight-prop">maximumHeight</a><span lang="zh-cn">。</span></p>
<!-- @@@maximumWidth -->
<!-- $$$minimized-prop$$$isMinimized -->
<h3 class="fn" id="minimized-prop"><a name="minimized-prop"></a><span class="name">minimized</span> : const <span class="type">bool</span></h3>
<p>此属性表示该组件是否最小化(图标化)。</p>
<p><font style="vertical-align: inherit;">此属性仅与窗口相关。</font></p>
<p><font style="vertical-align: inherit;">默认情况下，此属性为</font><code>false</code><font style="vertical-align: inherit;">。</font></p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><span class="name"><b>isMinimized</b></span>() const</td></tr>
</table></div>
<p><b>请参考 </b><a href="qwidget.html#showMinimized">showMinimized</a>(), <a href="qwidget.html#visible-prop">visible</a>, <a href="qwidget.html#show">show</a>(), <a href="qwidget.html#hide">hide</a>(), <a href="qwidget.html#showNormal">showNormal</a>(),
<span lang="zh-cn">和 </span><a href="qwidget.html#maximized-prop">maximized</a><span lang="zh-cn">。</span></p>
<!-- @@@minimized -->
<!-- $$$minimumHeight-prop$$$minimumHeight$$$setMinimumHeightint -->
<h3 class="fn" id="minimumHeight-prop"><a name="minimumHeight-prop"></a><span class="name">minimumHeight</span> : <span class="type">int</span></h3>
<p><font style="vertical-align: inherit;">此属性保存组件的最小高度（以像素为单位）</font></p>
<p>T<font style="vertical-align: inherit;">此属性对应于</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#minimumSize-prop"><font style="vertical-align: inherit;">minimumSize</font></a><font style="vertical-align: inherit;">属性所保持的高度。</font></p>
<p><font style="vertical-align: inherit;">默认情况下，此属性的值为 0。</font></p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> int </td><td class="memItemRight bottomAlign"><span class="name"><b>minimumHeight</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setMinimumHeight</b></span>(int <i>minh</i>)</td></tr>
</table></div>
<p><b>请参考 </b><a href="qwidget.html#minimumSize-prop">minimumSize</a> 
<span lang="zh-cn">和 </span><a href="qwidget.html#minimumWidth-prop">minimumWidth</a><span lang="zh-cn">。</span></p>
<!-- @@@minimumHeight -->
<!-- $$$minimumSize-prop$$$minimumSize$$$setMinimumSizeconstQSize&$$$setMinimumSizeintint -->
<h3 class="fn" id="minimumSize-prop"><a name="minimumSize-prop"></a><span class="name">minimumSize</span> : <span class="type"><a href="../qtcore/qsize.html">QSize</a></span></h3>
<p><font style="vertical-align: inherit;">此属性保存组件的最小尺寸</font></p>
<p><font style="vertical-align: inherit;">组件的大小不能调整为比最小组件尺寸更小的尺寸。如果当前尺寸较小，则组件的尺寸将被强制为最小尺寸。</font></p>
<p><font style="vertical-align: inherit;">此函数设置的最小尺寸将覆盖</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qlayout.html"><font style="vertical-align: inherit;">QLayout</font></a><font style="vertical-align: inherit;">定义的最小尺寸。要取消设置最小尺寸，请使用 值</font><code>QSize(0, 0)</code><font style="vertical-align: inherit;">。</font></p>
<p><font style="vertical-align: inherit;">默认情况下，此属性包含宽度和高度为零的大小。</font></p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> QSize </td><td class="memItemRight bottomAlign"><span class="name"><b>minimumSize</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setMinimumSize</b></span>(<i>const QSize &amp;</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b><a href="qwidget.html#setMinimumSize-1">setMinimumSize</a></b></span>(int <i>minw</i>, int <i>minh</i>)</td></tr>
</table></div>
<p><b>请参考 </b><a href="qwidget.html#minimumWidth-prop">minimumWidth</a>, <a href="qwidget.html#minimumHeight-prop">minimumHeight</a>, <a href="qwidget.html#maximumSize-prop">maximumSize</a>,
<span lang="zh-cn">和 </span><a href="qwidget.html#sizeIncrement-prop">sizeIncrement</a><span lang="zh-cn">。</span></p>
<!-- @@@minimumSize -->
<!-- $$$minimumSizeHint-prop$$$minimumSizeHint -->
<h3 class="fn" id="minimumSizeHint-prop"><a name="minimumSizeHint-prop"></a><span class="name">minimumSizeHint</span> : const <span class="type"><a href="../qtcore/qsize.html">QSize</a></span></h3>
<p><font style="vertical-align: inherit;">此属性保存组件的推荐最小尺寸</font></p>
<p>I<font style="vertical-align: inherit;">如果此属性的值是无效大小，则<span lang="zh-cn">不包含推荐的</span>最小大小。</font></p>
<p><font style="vertical-align: inherit;">如果此组件没有布局，则 minimumSizeHint() 的默认实现将返回无效大小，否则返回布局的最小大小。大多数内置组件重新实现了 minimumSizeHint()。</font></p>
<p><font style="vertical-align: inherit;">除非设置了</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#minimumSize-prop"><font style="vertical-align: inherit;">minimumSize</font></a><font style="vertical-align: inherit;"> () 或将大小策略设置为 QSizePolicy::Ignore，否则<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qlayout.html">QLayout</a>永远不会将组件的大小调整为小于最小大小提示的大小。如果设置了</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#minimumSize-prop"><font style="vertical-align: inherit;">minimumSize</font></a><font style="vertical-align: inherit;"> ()，最小尺寸提示将被忽略。</font></p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> virtual QSize </td><td class="memItemRight bottomAlign"><span class="name"><b>minimumSizeHint</b></span>() const</td></tr>
</table></div>
<p><b>请参考 </b><a href="../qtcore/qsize.html#isValid">QSize::isValid</a>(), <a href="qwidget.html#size-prop">resize</a>(), <a href="qwidget.html#minimumSize-prop">setMinimumSize</a>(),
<span lang="zh-cn">和 </span><a href="qwidget.html#sizePolicy-prop">sizePolicy</a>()<span lang="zh-cn">。</span></p>
<!-- @@@minimumSizeHint -->
<!-- $$$minimumWidth-prop$$$minimumWidth$$$setMinimumWidthint -->
<h3 class="fn" id="minimumWidth-prop"><a name="minimumWidth-prop"></a><span class="name">minimumWidth</span> : <span class="type">int</span></h3>
<p><font style="vertical-align: inherit;">此属性保存组件的最小宽度（以像素为单位）</font></p>
<p><font style="vertical-align: inherit;">此属性对应于</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#minimumSize-prop"><font style="vertical-align: inherit;">minimumSize</font></a><font style="vertical-align: inherit;">属性所保持的宽度。</font></p>
<p><font style="vertical-align: inherit;">默认情况下，此属性的值为 0。</font></p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> int </td><td class="memItemRight bottomAlign"><span class="name"><b>minimumWidth</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setMinimumWidth</b></span>(int <i>minw</i>)</td></tr>
</table></div>
<p><b>请参考 </b><a href="qwidget.html#minimumSize-prop">minimumSize</a> 
<span lang="zh-cn">和 </span><a href="qwidget.html#minimumHeight-prop">minimumHeight</a><span lang="zh-cn">。</span></p>
<!-- @@@minimumWidth -->
<!-- $$$modal-prop$$$isModal -->
<h3 class="fn" id="modal-prop"><a name="modal-prop"></a><span class="name">modal</span> : const <span class="type">bool</span></h3>
<p><font style="vertical-align: inherit;">此属性保存组件是否为模态组件</font></p>
<p><font style="vertical-align: inherit;">这个属性只对windows有意义。模态组件可防止所有其他窗口中的组件获得任何输入。</font></p>
<p><font style="vertical-align: inherit;">默认情况下，此属性为</font><code>false</code><font style="vertical-align: inherit;">。</font></p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><span class="name"><b>isModal</b></span>() const</td></tr>
</table></div>
<p><b>请参考 </b><a href="qwidget.html#isWindow">isWindow</a>(), <a href="qwidget.html#windowModality-prop">windowModality</a>,
<span lang="zh-cn">和 </span><a href="qdialog.html">QDialog</a><span lang="zh-cn">。</span></p>
<!-- @@@modal -->
<!-- $$$mouseTracking-prop$$$hasMouseTracking$$$setMouseTrackingbool -->
<h3 class="fn" id="mouseTracking-prop"><a name="mouseTracking-prop"></a><span class="name">mouseTracking</span> : <span class="type">bool</span></h3>
<p><font style="vertical-align: inherit;">此属性保存是否为组件启用鼠标跟踪</font></p>
<p><font style="vertical-align: inherit;">如果禁用鼠标跟踪（默认设置），则组件仅在移动鼠标时至少按下一个鼠标按钮时才会接收鼠标移动事件。</font></p>
<p><font style="vertical-align: inherit;">如果启用鼠标跟踪，即使没有按下任何按钮，组件也会收到鼠标移动事件。</font></p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><span class="name"><b>hasMouseTracking</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setMouseTracking</b></span>(bool <i>enable</i>)</td></tr>
</table></div>
<p><b>请参考 </b><a href="qwidget.html#mouseMoveEvent">mouseMoveEvent</a>()<span lang="zh-cn">。</span></p>
<!-- @@@mouseTracking -->
<!-- $$$normalGeometry-prop$$$normalGeometry -->
<h3 class="fn" id="normalGeometry-prop"><a name="normalGeometry-prop"></a><span class="name">normalGeometry</span> : const <span class="type"><a href="../qtcore/qrect.html">QRect</a></span></h3>
<p><font style="vertical-align: inherit;">此属性保存组件的几何形状，<span lang="zh-cn">当</span>它在<span lang="zh-cn">作为顶级组件时显示正常大小时(</span>非最大化或全屏）<span lang="zh-cn">为该值。</span></font></p>
<p><font style="vertical-align: inherit;">对于子组件，此属性始终包含一个空矩形。</font></p>
<p><font style="vertical-align: inherit;">默认情况下，此属性包含一个空矩形。</font></p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> QRect </td><td class="memItemRight bottomAlign"><span class="name"><b>normalGeometry</b></span>() const</td></tr>
</table></div>
<p><b>请参考 </b><a href="qwidget.html#windowState">QWidget::windowState</a>()
<span lang="zh-cn">和 </span><a href="qwidget.html#geometry-prop">QWidget::geometry</a><span lang="zh-cn">。</span></p>
<!-- @@@normalGeometry -->
<!-- $$$palette-prop$$$palette$$$setPaletteconstQPalette& -->
<h3 class="fn" id="palette-prop"><a name="palette-prop"></a><span class="name">palette</span> : <span class="type"><a href="../qtgui/qpalette.html">QPalette</a></span></h3>
<p><font style="vertical-align: inherit;">此属性保存组件的调色板</font></p>
<p><font style="vertical-align: inherit;">此属性描述组件的调色板。调色板在渲染标准组件时由组件的样式使用，可用作确保自定义组件可以与本机平台的外观和感觉保持一致的一种方式。不同的平台或不同的风格有不同的调色板是很常见的。</font></p>
<p><font style="vertical-align: inherit;">当您将新调色板分配给组件时，此调色板中的颜色角色将与组件的默认调色板组合以形成组件的最终调色板。组件背景角色的调色板条目用于填充组件的背景（参见</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#autoFillBackground-prop"><font style="vertical-align: inherit;">QWidget::autoFillBackground</font></a><font style="vertical-align: inherit;">），前景角色初始化</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtgui/qpainter.html"><font style="vertical-align: inherit;">QPainter</font></a><font style="vertical-align: inherit;">的画笔。</font></p>
<p><font style="vertical-align: inherit;">默认值取决于系统环境。</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qapplication.html"><font style="vertical-align: inherit;">QApplication</font></a><font style="vertical-align: inherit;">维护一个系统/主题调色板，作为所有组件的默认设置。某些类型的组件也可能有特殊的调色板默认值（例如，在 Windows Vista 上，所有从</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qmenubar.html"><font style="vertical-align: inherit;">QMenuBar</font></a><font style="vertical-align: inherit;">派生的类都有一个特殊的默认调色板）。您还可以通过将自定义调色板和组件的名称传递给</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qapplication.html#setPalette"><font style="vertical-align: inherit;">QApplication::setPalette</font></a><font style="vertical-align: inherit;"> ()来自己定义组件的默认调色板。最后，样式始终可以选择在指定时抛光调色板（请参阅</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qstyle.html#polish"><font style="vertical-align: inherit;">QStyle::polish</font></a><font style="vertical-align: inherit;"> ()）。</font></p>
<p><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html"><font style="vertical-align: inherit;">QWidget</font></a><font style="vertical-align: inherit;">将显式调色板角色从父级传播到子级。如果您将画笔或颜色分配给调色板上的特定角色并将该调色板分配给组件，则该角色将传播到组件的所有子项，覆盖该角色的任何系统默认值。请注意，除非启用了<a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtcore/qt.html#WidgetAttribute-enum">Qt::WA_WindowPropagation</a>属性，否则默认情况下调色板不会传播到窗口（请参阅</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#isWindow"><font style="vertical-align: inherit;">isWindow</font></a><font style="vertical-align: inherit;"> ()）。</font></p>
<p><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html"><font style="vertical-align: inherit;">QWidget</font></a><font style="vertical-align: inherit;">的调色板传播类似于其字体传播。</font></p>
<p><font style="vertical-align: inherit;">当前样式用于渲染所有标准 Qt 组件的内容，可以从组件调色板中自由选择颜色和画笔，或者在某些情况下，忽略调色板（部分或完全）。特别是某些样式，如 
GTK 样式、Mac 样式和 Windows Vista 样式，依赖第三方 API 来渲染组件的内容，并且这些样式通常不遵循调色板。因此，不能保证为组件的调色板分配角色会改变组件的外观。相反，您可以选择应用</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/stylesheet.html"><font style="vertical-align: inherit;">styleSheet</font></a><font style="vertical-align: inherit;">。</font></p>
<p><b>警告</b>不要将此函数与<a href="stylesheet.html">Qt样式表</a>一起使用。当使用样式表时，可以使用&quot;color&quot;， 
&quot;background-color&quot;， &quot;selection-color&quot;， 
&quot;selection-background-color&quot;和&quot;alternate-background-color&quot;来定制组件的调色板。</p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> const QPalette &amp;</td><td class="memItemRight bottomAlign"><span class="name"><b>palette</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setPalette</b></span>(<i>const QPalette &amp;</i>)</td></tr>
</table></div>
<p><b>请参考 </b><a href="qapplication.html#palette">QApplication::palette</a>(), <a href="qwidget.html#font-prop">QWidget::font</a>(),
<span lang="zh-cn">和 </span><a href="stylesheet.html">Qt Style Sheets</a><span lang="zh-cn">。</span></p>
<!-- @@@palette -->
<!-- $$$pos-prop$$$pos$$$moveintint$$$moveconstQPoint& -->
<h3 class="fn" id="pos-prop"><a name="pos-prop"></a><span class="name">pos</span> : <span class="type"><a href="../qtcore/qpoint.html">QPoint</a></span></h3>
<p><font style="vertical-align: inherit;">此属性保存组件在其父组件中的位置</font></p>
<p><font style="vertical-align: inherit;">如果组件是窗口，则位置是组件在桌面上的位置，包括其框架。</font></p>
<p><font style="vertical-align: inherit;">更改位置时，组件（如果可见）会立即接收移动事件（</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#moveEvent"><font style="vertical-align: inherit;">moveEvent</font></a><font style="vertical-align: inherit;"> ()）。如果组件当前不可见，则保证在显示之前收到一个事件。</font></p>
<p><font style="vertical-align: inherit;">默认情况下，此属性包含引用原点的位置。</font></p>
<p><b><font style="vertical-align: inherit;">警告：</font></b><font style="vertical-align: inherit;"><span lang="zh-cn">在</span></font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#moveEvent"><font style="vertical-align: inherit;">moveEvent</font></a><font style="vertical-align: inherit;">（）<span lang="zh-cn">内调用move（）或<a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#geometry-prop">setGeometry</a>（）</span>会导致无限递归。</font></p>
<p><font style="vertical-align: inherit;">有关</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/application-windows.html#window-geometry"><font style="vertical-align: inherit;">窗口几何</font></a><font style="vertical-align: inherit;">问题的概述，请参阅<a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/application-windows.html#window-geometry">窗口几何</a>文档。</font></p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> QPoint </td><td class="memItemRight bottomAlign"><span class="name"><b>pos</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b><a href="qwidget.html#move-1">move</a></b></span>(int <i>x</i>, int <i>y</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>move</b></span>(<i>const QPoint &amp;</i>)</td></tr>
</table></div>
<p><b>请参考 </b><a href="qwidget.html#frameGeometry-prop">frameGeometry</a>, <a href="qwidget.html#size-prop">size</a>, <a href="qwidget.html#x-prop">x</a>(),
<span lang="zh-cn">和 </span><a href="qwidget.html#y-prop">y</a>()<span lang="zh-cn">。</span></p>
<!-- @@@pos -->
<!-- $$$rect-prop$$$rect -->
<h3 class="fn" id="rect-prop"><a name="rect-prop"></a><span class="name">rect</span> : const <span class="type"><a href="../qtcore/qrect.html">QRect</a></span></h3>
<p><font style="vertical-align: inherit;">属性包含组件的内部几何形状，不包括任何窗口框架</font></p>
<p><font style="vertical-align: inherit;">rect 属性等于</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtcore/qrect.html"><font style="vertical-align: inherit;">QRect</font></a><font style="vertical-align: inherit;"> (0, 0, </font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#width-prop"><font style="vertical-align: inherit;">width</font></a><font style="vertical-align: inherit;"> (), </font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#height-prop"><font style="vertical-align: inherit;">height</font></a><font style="vertical-align: inherit;"> ())。</font></p>
<p><font style="vertical-align: inherit;">有关</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/application-windows.html#window-geometry"><font style="vertical-align: inherit;">窗口几何</font></a><font style="vertical-align: inherit;">问题的概述，请参阅<a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/application-windows.html#window-geometry">窗口几何</a>文档。</font></p>
<p><font style="vertical-align: inherit;">默认情况下，此属性包含一个取决于用户平台和屏幕几何形状的值。</font></p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> QRect </td><td class="memItemRight bottomAlign"><span class="name"><b>rect</b></span>() const</td></tr>
</table></div>
<p><b>请参考 </b><a href="qwidget.html#size-prop">size</a><span lang="zh-cn">。</span></p>
<!-- @@@rect -->
<!-- $$$size-prop$$$size$$$resizeintint$$$resizeconstQSize& -->
<h3 class="fn" id="size-prop"><a name="size-prop"></a><span class="name">size</span> : <span class="type"><a href="../qtcore/qsize.html">QSize</a></span></h3>
<p><font style="vertical-align: inherit;">此属性保存组件的大小，不包括任何窗口框架</font></p>
<p><font style="vertical-align: inherit;">如果组件在调整大小时可见，它会立即收到一个调整大小事件（</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#resizeEvent"><font style="vertical-align: inherit;">resizeEvent</font></a><font style="vertical-align: inherit;"> ()）。如果组件当前不可见，则保证在显示之前收到一个事件。</font></p>
<p><font style="vertical-align: inherit;">如果大小超出由</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#minimumSize-prop"><font style="vertical-align: inherit;">minimumSize</font></a><font style="vertical-align: inherit;"> () 和</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#maximumSize-prop"><font style="vertical-align: inherit;">maximumSize</font></a><font style="vertical-align: inherit;"> ()定义的范围，则调整大小。</font></p>
<p><font style="vertical-align: inherit;">默认情况下，此属性包含一个取决于用户平台和屏幕几何形状的值。</font></p>
<p><b><font style="vertical-align: inherit;">警告：</font></b><font style="vertical-align: inherit;">在</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#geometry-prop"><font style="vertical-align: inherit;">resizeEvent</font></a><font style="vertical-align: inherit;"> () 内部调用 resize() 或</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#resizeEvent"><font style="vertical-align: inherit;">setGeometry</font></a><font style="vertical-align: inherit;"> () 会导致无限递归。</font></p>
<p><b><font style="vertical-align: inherit;">注意：</font></b><font style="vertical-align: inherit;">将大小设置为</font><code>QSize(0, 0)</code><font style="vertical-align: inherit;">将导致组件不会出现在屏幕上。这也适用于窗户。</font></p><p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> QSize </td><td class="memItemRight bottomAlign"><span class="name"><b>size</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b><a href="qwidget.html#resize-1">resize</a></b></span>(int <i>w</i>, int <i>h</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>resize</b></span>(<i>const QSize &amp;</i>)</td></tr>
</table></div>
<p><b>请参考 </b><a href="qwidget.html#pos-prop">pos</a>, <a href="qwidget.html#geometry-prop">geometry</a>, <a href="qwidget.html#minimumSize-prop">minimumSize</a>, <a href="qwidget.html#maximumSize-prop">maximumSize</a>, <a href="qwidget.html#resizeEvent">resizeEvent</a>(),
<span lang="zh-cn">和 </span><a href="qwidget.html#adjustSize">adjustSize</a>()<span lang="zh-cn">。</span></p>
<!-- @@@size -->
<!-- $$$sizeHint-prop$$$sizeHint -->
<h3 class="fn" id="sizeHint-prop"><a name="sizeHint-prop"></a><span class="name">sizeHint</span> : const <span class="type"><a href="../qtcore/qsize.html">QSize</a></span></h3>
<p><font style="vertical-align: inherit;">此属性保存组件的推荐大小</font></p>
<p><font style="vertical-align: inherit;">如果此属性的值是无效大小，则<span lang="zh-cn">没有推荐的</span>大小</font></p>
<p><font style="vertical-align: inherit;">如果此组件没有布局，则 sizeHint() 的默认实现将返回无效大小，否则返回布局的首选大小。</font></p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> virtual QSize </td><td class="memItemRight bottomAlign"><span class="name"><b>sizeHint</b></span>() const</td></tr>
</table></div>
<p><b>请参考 </b><a href="../qtcore/qsize.html#isValid">QSize::isValid</a>(), <a href="qwidget.html#minimumSizeHint-prop">minimumSizeHint</a>(), <a href="qwidget.html#sizePolicy-prop">sizePolicy</a>(), <a href="qwidget.html#minimumSize-prop">setMinimumSize</a>(),
<span lang="zh-cn">和 </span><a href="qwidget.html#updateGeometry">updateGeometry</a>()<span lang="zh-cn">。</span></p>
<!-- @@@sizeHint -->
<!-- $$$sizeIncrement-prop$$$sizeIncrement$$$setSizeIncrementconstQSize&$$$setSizeIncrementintint -->
<h3 class="fn" id="sizeIncrement-prop"><a name="sizeIncrement-prop"></a><span class="name">sizeIncrement</span> : <span class="type"><a href="../qtcore/qsize.html">QSize</a></span></h3>
<p><font style="vertical-align: inherit;">此属性保存组件的大小增量</font></p>
<p><font style="vertical-align: inherit;">用户调整窗口大小时，大小将按 sizeIncrement() 的步骤移动。</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#width-prop"><font style="vertical-align: inherit;">width</font></a><font style="vertical-align: inherit;"> () 像素水平和 sizeIncrement。</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#height-prop"><font style="vertical-align: inherit;">height</font></a><font style="vertical-align: inherit;"> () 垂直像素，以</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#baseSize-prop"><font style="vertical-align: inherit;">baseSize</font></a><font style="vertical-align: inherit;"> () 为基础。首选组件大小适用于非负整数</font><i><font style="vertical-align: inherit;">i</font></i><font style="vertical-align: inherit;">和</font><i><font style="vertical-align: inherit;">j</font></i><font style="vertical-align: inherit;">：</font></p>
<pre class="cpp">

  width <span class="operator">=</span> baseSize()<span class="operator">.</span>width() <span class="operator">+</span> i <span class="operator">*</span> sizeIncrement()<span class="operator">.</span>width();
  height <span class="operator">=</span> baseSize()<span class="operator">.</span>height() <span class="operator">+</span> j <span class="operator">*</span> sizeIncrement()<span class="operator">.</span>height();

</pre>
<p>N<font style="vertical-align: inherit;">请注意，虽然您可以为所有组件设置大小增量，但它仅<span lang="zh-cn">对窗口有效</span>。</font></p>
<p><font style="vertical-align: inherit;">默认情况下，此属性包含宽度和高度为零的大小。</font></p>
<p><b><font style="vertical-align: inherit;">警告：</font></b><font style="vertical-align: inherit;">大小增量在 Windows 下无效，在 X11 上可能会被窗口管理器忽略。</font></p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> QSize </td><td class="memItemRight bottomAlign"><span class="name"><b>sizeIncrement</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setSizeIncrement</b></span>(<i>const QSize &amp;</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b><a href="qwidget.html#setSizeIncrement-1">setSizeIncrement</a></b></span>(int <i>w</i>, int <i>h</i>)</td></tr>
</table></div>
<p><b>请参考 </b><a href="qwidget.html#size-prop">size</a>, <a href="qwidget.html#minimumSize-prop">minimumSize</a>,
<span lang="zh-cn">和 </span><a href="qwidget.html#maximumSize-prop">maximumSize</a><span lang="zh-cn">。</span></p>
<!-- @@@sizeIncrement -->
<!-- $$$sizePolicy-prop$$$sizePolicy$$$setSizePolicyQSizePolicy$$$setSizePolicyQSizePolicy::PolicyQSizePolicy::Policy -->
<h3 class="fn" id="sizePolicy-prop"><a name="sizePolicy-prop"></a><span class="name">sizePolicy</span> : <span class="type"><a href="qsizepolicy.html">QSizePolicy</a></span></h3>
<p><font style="vertical-align: inherit;">默认情况下，此属性包含宽度和高度为零的大小。</font></p>
<p><font style="vertical-align: inherit;">如果有一个</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qlayout.html"><font style="vertical-align: inherit;">QLayout</font></a><font style="vertical-align: inherit;">管理这个组件的子组件，则使用该布局指定的大小策略。如果没有这样的</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qlayout.html"><font style="vertical-align: inherit;">QLayout</font></a><font style="vertical-align: inherit;">，则使用此函数的结果。</font></p>
<p><font style="vertical-align: inherit;">默认策略是Preferred/Preferred，这意味着widget可以自由调整大小，但更倾向于</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#sizeHint-prop"><font style="vertical-align: inherit;">sizeHint</font></a><font style="vertical-align: inherit;"> ()返回的大小。类似按钮的组件设置大小策略以指定它们可以水平拉伸，但垂直固定。这同样适用于 lineedit 控件（例如</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qlineedit.html"><font style="vertical-align: inherit;">QLineEdit</font></a><font style="vertical-align: inherit;">、</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qspinbox.html"><font style="vertical-align: inherit;">QSpinBox</font></a><font style="vertical-align: inherit;">或可编辑的</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qcombobox.html"><font style="vertical-align: inherit;">QComboBox</font></a><font style="vertical-align: inherit;">）和其他水平方向的组件（例如</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qprogressbar.html"><font style="vertical-align: inherit;">QProgressBar</font></a><font style="vertical-align: inherit;">）。</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qtoolbutton.html"><font style="vertical-align: inherit;">QToolButton</font></a><font style="vertical-align: inherit;">通常是方形的，因此它们允许在两个方向上增长。支持不同方向的组件（如</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qslider.html"><font style="vertical-align: inherit;">QSlider</font></a><font style="vertical-align: inherit;">、</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qscrollbar.html"><font style="vertical-align: inherit;">QScrollBar</font></a><font style="vertical-align: inherit;">或 QHeader) 仅指定在相应方向上的拉伸。可以提供滚动条的组件（通常是</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qscrollarea.html"><font style="vertical-align: inherit;">QScrollArea 的</font></a><font style="vertical-align: inherit;">子类）倾向于指定它们可以使用额外的空间，并且它们可以使用小于</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#sizeHint-prop"><font style="vertical-align: inherit;">sizeHint</font></a><font style="vertical-align: inherit;"> () 的空间来凑合。</font></p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> QSizePolicy </td><td class="memItemRight bottomAlign"><span class="name"><b>sizePolicy</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setSizePolicy</b></span>(<i>QSizePolicy</i>)</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b><a href="qwidget.html#setSizePolicy-1">setSizePolicy</a></b></span>(QSizePolicy::Policy <i>horizontal</i>, QSizePolicy::Policy <i>vertical</i>)</td></tr>
</table></div>
<p><b>请参考 </b><a href="qwidget.html#sizeHint-prop">sizeHint</a>(), <a href="qlayout.html">QLayout</a>, <a href="qsizepolicy.html">QSizePolicy</a>,
<span lang="zh-cn">和 </span><a href="qwidget.html#updateGeometry">updateGeometry</a>()<span lang="zh-cn">。</span></p>
<!-- @@@sizePolicy -->
<!-- $$$statusTip-prop$$$statusTip$$$setStatusTipconstQString& -->
<h3 class="fn" id="statusTip-prop"><a name="statusTip-prop"></a><span class="name">statusTip</span> : <span class="type"><a href="../qtcore/qstring.html">QString</a></span></h3>
<p><font style="vertical-align: inherit;">此属性保存组件的状态提示</font></p>
<p><font style="vertical-align: inherit;">默认情况下，此属性包含一个空字符串。</font></p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> QString </td><td class="memItemRight bottomAlign"><span class="name"><b>statusTip</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setStatusTip</b></span>(<i>const QString &amp;</i>)</td></tr>
</table></div>
<p><b>请参考 </b><a href="qwidget.html#toolTip-prop">toolTip</a> <span lang="zh-cn">
和 </span><a href="qwidget.html#whatsThis-prop">whatsThis</a><span lang="zh-cn">。</span></p>
<!-- @@@statusTip -->
<!-- $$$styleSheet-prop$$$styleSheet$$$setStyleSheetconstQString& -->
<h3 class="fn" id="styleSheet-prop"><a name="styleSheet-prop"></a><span class="name">styleSheet</span> : <span class="type"><a href="../qtcore/qstring.html">QString</a></span></h3>
<p><font style="vertical-align: inherit;">此属性保存组件的样式表</font></p>
<p><font style="vertical-align: inherit;">样式表包含组件样式自定义的文本描述，如</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/stylesheet.html"><font style="vertical-align: inherit;">Qt 样式表</font></a><font style="vertical-align: inherit;">文档中所述。</font></p>
<p><font style="vertical-align: inherit;">从 Qt 4.5 开始，Qt 样式表完全支持</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtdoc/internationalization.html#macos"><font style="vertical-align: inherit;">macOS</font></a><font style="vertical-align: inherit;">。</font></p>
<p><b><font style="vertical-align: inherit;">警告：</font></b><font style="vertical-align: inherit;">自定义</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qstyle.html"><font style="vertical-align: inherit;">QStyle</font></a><font style="vertical-align: inherit;">子类当前不支持 Qt 样式表。我们计划在未来的某个版本中解决这个问题。</font></p>
<p><font style="vertical-align: inherit;">这个属性是在 Qt 4.2 中引入的。</font></p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> QString </td><td class="memItemRight bottomAlign"><span class="name"><b>styleSheet</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setStyleSheet</b></span>(const QString &amp;<i>styleSheet</i>)</td></tr>
</table></div>
<p><b>请参考 </b><a href="qwidget.html#setStyle">setStyle</a>(), <a href="qapplication.html#styleSheet-prop">QApplication::styleSheet</a>,
<span lang="zh-cn">和 </span><a href="stylesheet.html">Q<span lang="zh-cn">t样式表</span></a><span lang="zh-cn">。</span></p>
<!-- @@@styleSheet -->
<!-- $$$tabletTracking-prop$$$hasTabletTracking$$$setTabletTrackingbool -->
<h3 class="fn" id="tabletTracking-prop"><a name="tabletTracking-prop"></a><span class="name">tabletTracking</span> : <span class="type">bool</span></h3>
<p><font style="vertical-align: inherit;">此属性保存是否为组件启用平板电脑跟踪</font></p>
<p><font style="vertical-align: inherit;">
果平板电脑跟踪被禁用（默认），则组件仅在触控笔与平板电脑接触时或在移动触控笔时至少按下一个触控笔按钮时才会接收平板电脑移动事件。</font></p>
<p><font style="vertical-align: inherit;">如果启用平板电脑跟踪，即使在附近悬停时，组件也会收到平板电脑移动事件。这对于监视位置以及辅助属性（例如旋转和倾斜）以及在 UI 中提供反馈很有用。</font></p>
<p><font style="vertical-align: inherit;">这个属性是在 Qt 5.9 中引入的。</font></p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><span class="name"><b>hasTabletTracking</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setTabletTracking</b></span>(bool <i>enable</i>)</td></tr>
</table></div>
<p><b>请参考 </b><a href="qwidget.html#tabletEvent">tabletEvent</a>()<span lang="zh-cn">。</span></p>
<!-- @@@tabletTracking -->
<!-- $$$toolTip-prop$$$toolTip$$$setToolTipconstQString& -->
<h3 class="fn" id="toolTip-prop"><a name="toolTip-prop"></a><span class="name">toolTip</span> : <span class="type"><a href="../qtcore/qstring.html">QString</a></span></h3>
<p><font style="vertical-align: inherit;">此属性包含组件的工具提示</font></p>
<p><font style="vertical-align: inherit;">请注意，默认情况下，工具提示仅针对作为活动窗口子项的组件显示。您可以通过在<i>window</i>上设置属性</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtcore/qt.html#WidgetAttribute-enum"><font style="vertical-align: inherit;">Qt::WA_AlwaysShowToolTips</font></a><font style="vertical-align: inherit;">来更改此行为，而不是在带有工具提示的组件上。</font></p>
<p><font style="vertical-align: inherit;">如果你想控制工具提示的行为，你可以拦截</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#event"><font style="vertical-align: inherit;">event</font></a><font style="vertical-align: inherit;"> () 函数并捕获</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtcore/qevent.html#Type-enum"><font style="vertical-align: inherit;">QEvent::ToolTip</font></a><font style="vertical-align: inherit;">事件（例如，如果你想自定义应该显示工具提示的区域）。</font></p>
<p><font style="vertical-align: inherit;">默认情况下，此属性包含一个空字符串。</font></p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> QString </td><td class="memItemRight bottomAlign"><span class="name"><b>toolTip</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setToolTip</b></span>(<i>const QString &amp;</i>)</td></tr>
</table></div>
<p><b>请参考 </b><a href="qtooltip.html">QToolTip</a>, <a href="qwidget.html#statusTip-prop">statusTip</a>,
<span lang="zh-cn">和 </span><a href="qwidget.html#whatsThis-prop">whatsThis</a><span lang="zh-cn">。</span></p>
<!-- @@@toolTip -->
<!-- $$$toolTipDuration-prop$$$toolTipDuration$$$setToolTipDurationint -->
<h3 class="fn" id="toolTipDuration-prop"><a name="toolTipDuration-prop"></a><span class="name">toolTipDuration</span> : <span class="type">int</span></h3>
<p><font style="vertical-align: inherit;">此属性保存组件的工具提示持续时间</font></p>
<p><font style="vertical-align: inherit;">指定工具提示将显示多长时间，以毫秒为单位。如果值为 -1（默认），则根据工具提示的长度计算持续时间。</font></p>
<p><font style="vertical-align: inherit;">这个属性是在 Qt 5.2 中引入的。</font></p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> int </td><td class="memItemRight bottomAlign"><span class="name"><b>toolTipDuration</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setToolTipDuration</b></span>(int <i>msec</i>)</td></tr>
</table></div>
<p><b>请参考 </b><a href="qwidget.html#toolTip-prop">toolTip</a><span lang="zh-cn">。</span></p>
<!-- @@@toolTipDuration -->
<!-- $$$updatesEnabled-prop$$$updatesEnabled$$$setUpdatesEnabledbool -->
<h3 class="fn" id="updatesEnabled-prop"><a name="updatesEnabled-prop"></a><span class="name">updatesEnabled</span> : <span class="type">bool</span></h3>
<p><font style="vertical-align: inherit;">此属性保存是否启用更新</font></p>
<p><font style="vertical-align: inherit;">启用更新的组件接收绘制事件并具有系统背景；禁用的组件不会。这也意味着如果禁用</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#update"><font style="vertical-align: inherit;">更新</font></a><font style="vertical-align: inherit;">，则调用<a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#update">update</a> () 和</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#repaint"><font style="vertical-align: inherit;">repaint</font></a><font style="vertical-align: inherit;"> () 无效。</font></p>
<p><font style="vertical-align: inherit;">默认情况下，此属性为</font><code>true</code><font style="vertical-align: inherit;">。</font></p>
<p><font style="vertical-align: inherit;">setUpdatesEnabled() 通常用于在短时间内禁用更新，例如避免在大更改期间屏幕闪烁。在 Qt 中，组件通常不会产生屏幕闪烁，但在 X11 上，当组件在被其他组件替换之前被隐藏时，服务器可能会擦除屏幕上的区域。禁用更新可以解决这个问题。</font></p>
<p><font style="vertical-align: inherit;">例<span lang="zh-cn">如</span>：</font></p>
<pre class="cpp">

  setUpdatesEnabled(<span class="keyword">false</span>);
  bigVisualChanges();
  setUpdatesEnabled(<span class="keyword">true</span>);

</pre>
<p><font style="vertical-align: inherit;">禁用组件会隐式禁用其所有子组件。启用组件会启用</font><i><font style="vertical-align: inherit;">除</font></i><font style="vertical-align: inherit;">顶级组件或已明确禁用的组件<i>之外的</i>所有子组件。重新启用更新隐式调用组件上的</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#update"><font style="vertical-align: inherit;">update</font></a><font style="vertical-align: inherit;"> ()。</font></p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><span class="name"><b>updatesEnabled</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setUpdatesEnabled</b></span>(bool <i>enable</i>)</td></tr>
</table></div>
<p><b>请参考 </b><a href="qwidget.html#paintEvent">paintEvent</a>()<span lang="zh-cn">。</span></p>
<!-- @@@updatesEnabled -->
<!-- $$$visible-prop$$$isVisible$$$setVisiblebool -->
<h3 class="fn" id="visible-prop"><a name="visible-prop"></a><span class="name">visible</span> : <span class="type">bool</span></h3>
<p><font style="vertical-align: inherit;">此属性保存组件是否可见</font></p>
<p><font style="vertical-align: inherit;">如果窗口之前的所有父组件都可见，则调用 setVisible(true) 或</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#show"><font style="vertical-align: inherit;">show</font></a><font style="vertical-align: inherit;"> () 将组件设置为可见状态。如果祖先不可见，则在显示其所有祖先之前，组件不会变得可见。如果它的大小或位置发生了变化，Qt 保证一个组件在它显示之前获得移动和调整大小事件。如果组件尚未调整大小，Qt 将使用</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#adjustSize"><font style="vertical-align: inherit;">adjustSize</font></a><font style="vertical-align: inherit;"> ()将组件的大小调整为有用的默认值。</font></p>
<p><font style="vertical-align: inherit;">调用 setVisible(false) 或</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#hide"><font style="vertical-align: inherit;">hide</font></a><font style="vertical-align: inherit;"> () 会显式隐藏组件。一个显式隐藏的组件永远不会变得可见，即使它的所有祖先都变得可见，除非你显示它。</font></p>
<p><font style="vertical-align: inherit;">组件在其可见性状态更改时接收显示和隐藏事件。在隐藏和显示事件之间，无需浪费 CPU 周期来准备或向用户显示信息。例如，视频应用程序可能只是停止生成新帧。</font></p>
<p><font style="vertical-align: inherit;"><span lang="zh-cn">当组件</span>碰巧被屏幕上的其他窗口遮挡<span lang="zh-cn">时，也是被认为</span>是可见的。这同样适用于图标化窗口和存在于另一个虚拟桌面上的窗口（在支持此概念的平台上）。当窗口系统改变其映射状态时，组件接收自发显示和隐藏事件，例如，当用户最小化窗口时自发隐藏事件，以及当窗口再次恢复时自发显示事件。</font></p>
<p><font style="vertical-align: inherit;">您几乎不需要重新实现 setVisible() 函数。如果您需要在显示组件之前更改某些设置，请改用</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#showEvent"><font style="vertical-align: inherit;">showEvent</font></a><font style="vertical-align: inherit;"> ()。如果您需要进行一些延迟初始化，请使用传递给</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#event"><font style="vertical-align: inherit;">event</font></a><font style="vertical-align: inherit;"> () 函数的<span lang="zh-cn">Polish</span>事件。</font></p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><span class="name"><b>isVisible</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> virtual void </td><td class="memItemRight bottomAlign"><span class="name"><b>setVisible</b></span>(bool <i>visible</i>)</td></tr>
</table></div>
<p><b>请参考 </b><a href="qwidget.html#show">show</a>(), <a href="qwidget.html#hide">hide</a>(), <a href="qwidget.html#isHidden">isHidden</a>(), <a href="qwidget.html#isVisibleTo">isVisibleTo</a>(), <a href="qwidget.html#minimized-prop">isMinimized</a>(), <a href="qwidget.html#showEvent">showEvent</a>(),
<span lang="zh-cn">和 </span><a href="qwidget.html#hideEvent">hideEvent</a>()<span lang="zh-cn">。</span></p>
<!-- @@@visible -->
<!-- $$$whatsThis-prop$$$whatsThis$$$setWhatsThisconstQString& -->
<h3 class="fn" id="whatsThis-prop"><a name="whatsThis-prop"></a><span class="name">whatsThis</span> : <span class="type"><a href="../qtcore/qstring.html">QString</a></span></h3>
<p><font style="vertical-align: inherit;">此属性包含组件的“这是什么”帮助文本。</font></p>
<p><font style="vertical-align: inherit;">默认情况下，此属性包含一个空字符串。</font></p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> QString </td><td class="memItemRight bottomAlign"><span class="name"><b>whatsThis</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setWhatsThis</b></span>(<i>const QString &amp;</i>)</td></tr>
</table></div>
<p><b>请参考 </b><a href="qwhatsthis.html">QWhatsThis</a>, <a href="qwidget.html#toolTip-prop">QWidget::toolTip</a>,
<span lang="zh-cn">和 </span><a href="qwidget.html#statusTip-prop">QWidget::statusTip</a><span lang="zh-cn">。</span></p>
<!-- @@@whatsThis -->
<!-- $$$width-prop$$$width -->
<h3 class="fn" id="width-prop"><a name="width-prop"></a><span class="name">width</span> : const <span class="type">int</span></h3>
<p><font style="vertical-align: inherit;">此属性保存组件的宽度，不包括任何窗口框架</font></p>
<p><font style="vertical-align: inherit;">有关</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtwidgets/application-windows.html#window-geometry"><font style="vertical-align: inherit;">窗口几何</font></a><font style="vertical-align: inherit;">问题的概述，请参阅<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtwidgets/application-windows.html#window-geometry">窗口几何</a>文档。</font></p>
<p><b><font style="vertical-align: inherit;">注意：</font></b><font style="vertical-align: inherit;">不要使用此功能在</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qdesktopwidget.html"><font style="vertical-align: inherit;">多屏桌面</font></a><font style="vertical-align: inherit;">上查找屏幕的宽度。有关详细信息，请阅读</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qdesktopwidget.html#screen-geometry"><font style="vertical-align: inherit;">此注释</font></a><font style="vertical-align: inherit;">。</font></p><p><font style="vertical-align: inherit;">默认情况下，此属性包含一个取决于用户平台和屏幕几何形状的值。</font></p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> int </td><td class="memItemRight bottomAlign"><span class="name"><b>width</b></span>() const</td></tr>
</table></div>
<p><b>请参考 </b><a href="qwidget.html#geometry-prop">geometry</a>, <a href="qwidget.html#height-prop">height</a>,
<span lang="zh-cn">和 </span><a href="qwidget.html#size-prop">size</a><span lang="zh-cn">。</span></p>
<!-- @@@width -->
<!-- $$$windowFilePath-prop$$$windowFilePath$$$setWindowFilePathconstQString& -->
<h3 class="fn" id="windowFilePath-prop"><a name="windowFilePath-prop"></a><span class="name">windowFilePath</span> : <span class="type"><a href="../qtcore/qstring.html">QString</a></span></h3>
<p><font style="vertical-align: inherit;">此属性保存与组件关联的文件路径</font></p>
<p><font style="vertical-align: inherit;">这个属性只对windows有意义。它将文件路径与窗口相关联。如果你设置了文件路径，但没有设置窗口标题，Qt将窗口标题设置为指定路径的文件名，使用</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtcore/qfileinfo.html#fileName"><font style="vertical-align: inherit;">QFileInfo::fileName</font></a><font style="vertical-align: inherit;"> ()获取。</font></p>
<p><font style="vertical-align: inherit;">如果在任何时候设置了窗口标题，则窗口标题优先并且将显示而不是文件路径字符串。</font></p>
<p><font style="vertical-align: inherit;">此外，在</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtdoc/internationalization.html#macos"><font style="vertical-align: inherit;">macOS 上</font></a><font style="vertical-align: inherit;">，这有一个额外的好处，它为窗口设置</font><a href="http://developer.apple.com/documentation/UserExperience/Conceptual/OSXHIGuidelines/XHIGWindows/chapter_17_section_3.html"><font style="vertical-align: inherit;">代理图标</font></a><font style="vertical-align: inherit;">，假设文件路径存在。</font></p>
<p><font style="vertical-align: inherit;">如果未设置文件路径，则此属性包含一个空字符串。</font></p>
<p><font style="vertical-align: inherit;">默认情况下，此属性包含一个空字符串。</font></p>
<p><font style="vertical-align: inherit;">这个属性是在 Qt 4.4 中引入的。</font></p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> QString </td><td class="memItemRight bottomAlign"><span class="name"><b>windowFilePath</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setWindowFilePath</b></span>(const QString &amp;<i>filePath</i>)</td></tr>
</table></div>
<p><b>请参考 </b><a href="qwidget.html#windowTitle-prop">windowTitle</a> 
<span lang="zh-cn">和 </span><a href="qwidget.html#windowIcon-prop">windowIcon</a><span lang="zh-cn">。</span></p>
<!-- @@@windowFilePath -->
<!-- $$$windowFlags-prop$$$windowFlags$$$setWindowFlagsQt::WindowFlags -->
<h3 class="fn" id="windowFlags-prop"><a name="windowFlags-prop"></a><span class="name">windowFlags</span> : <span class="type"><a href="../qtcore/qt.html#WindowType-enum">Qt::WindowFlags</a></span></h3>
<p><font style="vertical-align: inherit;">窗口标志是一个类型（例如</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtcore/qt.html#WindowType-enum"><font style="vertical-align: inherit;">Qt::Dialog</font></a><font style="vertical-align: inherit;">）和零个或多个窗口系统提示（例</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtcore/qt.html#WindowType-enum"><font style="vertical-align: inherit;">Qt::FramelessWindowHint</font></a><font style="vertical-align: inherit;">）的组合。</font></p>
<p><font style="vertical-align: inherit;">如果组件的类型为</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtcore/qt.html#WindowType-enum"><font style="vertical-align: inherit;">Qt::Widget</font></a><font style="vertical-align: inherit;">或</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtcore/qt.html#WindowType-enum"><font style="vertical-align: inherit;">Qt::SubWindow</font></a><font style="vertical-align: inherit;">并成为窗口（</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtcore/qt.html#WindowType-enum"><font style="vertical-align: inherit;">Qt::Window</font></a><font style="vertical-align: inherit;">、</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtcore/qt.html#WindowType-enum"><font style="vertical-align: inherit;">Qt::Dialog</font></a><font style="vertical-align: inherit;">等），则将其放置在桌面上的位置 (0, 0)。如果组件是一个窗口并成为</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtcore/qt.html#WindowType-enum"><font style="vertical-align: inherit;">Qt::Widget</font></a><font style="vertical-align: inherit;">或</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtcore/qt.html#WindowType-enum"><font style="vertical-align: inherit;">Qt::SubWindow</font></a><font style="vertical-align: inherit;">，则它被放置在相对于其父组件的位置 (0, 0)。</font></p>
<p><b><font style="vertical-align: inherit;">注意：</font></b><font style="vertical-align: inherit;">此函数在更改窗口的标志时调用</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#setParent"><font style="vertical-align: inherit;">setParent</font></a><font style="vertical-align: inherit;"> ()，导致组件被隐藏。您必须调用</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#show"><font style="vertical-align: inherit;">show</font></a><font style="vertical-align: inherit;"> () 使组件再次可见<span lang="zh-cn">。</span></font></p><p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> Qt::WindowFlags </td><td class="memItemRight bottomAlign"><span class="name"><b>windowFlags</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setWindowFlags</b></span>(Qt::WindowFlags <i>type</i>)</td></tr>
</table></div>
<p><b>请参考 </b><a href="qwidget.html#windowType">windowType</a>(), <a href="qwidget.html#setWindowFlag">setWindowFlag</a>(),
<span lang="zh-cn">和</span> <a href="qtwidgets-widgets-windowflags-example.html">
<span lang="zh-cn">窗口标志示例</span></a><span lang="zh-cn">。</span></p>
<!-- @@@windowFlags -->
<!-- $$$windowIcon-prop$$$windowIcon$$$setWindowIconconstQIcon&$$$windowIconChangedconstQIcon& -->
<h3 class="fn" id="windowIcon-prop"><a name="windowIcon-prop"></a><span class="name">windowIcon</span> : <span class="type"><a href="../qtgui/qicon.html">QIcon</a></span></h3>
<p><font style="vertical-align: inherit;">此属性包含组件的图标</font></p>
<p><font style="vertical-align: inherit;">这个属性只对窗口有意义。如果没有设置图标，windowIcon() 返回应用程序图标 ( </font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qapplication.html#windowIcon-prop"><font style="vertical-align: inherit;">QApplication::windowIcon</font></a><font style="vertical-align: inherit;"> ())。</font></p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> QIcon </td><td class="memItemRight bottomAlign"><span class="name"><b>windowIcon</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setWindowIcon</b></span>(const QIcon &amp;<i>icon</i>)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b><a href="qwidget.html#windowIconChanged">windowIconChanged</a></b></span>(const QIcon &amp;<i>icon</i>)</td></tr>
</table></div>
<p><b>请参考 </b><a href="qwidget.html#windowTitle-prop">windowTitle</a><span lang="zh-cn">。</span></p>
<!-- @@@windowIcon -->
<!-- $$$windowModality-prop$$$windowModality$$$setWindowModalityQt::WindowModality -->
<h3 class="fn" id="windowModality-prop"><a name="windowModality-prop"></a><span class="name">windowModality</span> : <span class="type"><a href="../qtcore/qt.html#WindowModality-enum">Qt::WindowModality</a></span></h3>
<p><font style="vertical-align: inherit;">此属性保存哪些窗口被模态组件<span lang="zh-cn">阻塞</span></font></p>
<p><font style="vertical-align: inherit;">这个属性只对窗口有意义。模态组件可防止其他窗口中的组件获取输入。此属性的值控制当组件可见时阻止哪些窗口。在窗口可见时更改此属性无效；您必须先</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#hide"><font style="vertical-align: inherit;">隐藏</font></a><font style="vertical-align: inherit;">() 
组件，然后再次</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#show"><font style="vertical-align: inherit;">显示</font></a><font style="vertical-align: inherit;">() 它。</font></p>
<p><font style="vertical-align: inherit;">默认情况下，此属性为</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtcore/qt.html#WindowModality-enum"><font style="vertical-align: inherit;">Qt::NonModal</font></a><font style="vertical-align: inherit;">。</font></p>
<p><font style="vertical-align: inherit;">这个属性是在 Qt 4.1 中引入的。</font></p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> Qt::WindowModality </td><td class="memItemRight bottomAlign"><span class="name"><b>windowModality</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setWindowModality</b></span>(Qt::WindowModality <i>windowModality</i>)</td></tr>
</table></div>
<p><b>请参考 </b><a href="qwidget.html#isWindow">isWindow</a>(), <a href="qwidget.html#modal-prop">QWidget::modal</a>,
<span lang="zh-cn">和 </span><a href="qdialog.html">QDialog</a><span lang="zh-cn">。</span></p>
<!-- @@@windowModality -->
<!-- $$$windowModified-prop$$$isWindowModified$$$setWindowModifiedbool -->
<h3 class="fn" id="windowModified-prop"><a name="windowModified-prop"></a><span class="name">windowModified</span> : <span class="type">bool</span></h3>
<p><font style="vertical-align: inherit;">此属性保存窗口中显示的文档是否有未保存的更改</font></p>
<p><font style="vertical-align: inherit;">修改后的窗口是内容已更改但尚未保存到磁盘的窗口。此标志将具有因平台而异的不同效果。在</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtdoc/internationalization.html#macos"><font style="vertical-align: inherit;">macOS 上</font></a><font style="vertical-align: inherit;">，关闭按钮的外观会有所修改；在其他平台上，窗口标题将带有“*”（星号）。</font></p>
<p><font style="vertical-align: inherit;">窗口标题必须包含一个“[*]”占位符，它指示“*”应该出现的位置。通常，它应该出现在文件名之后（例如，“document1.txt[*] - 文本编辑器”）。如果未修改窗口，则简单地删除占位符。</font></p>
<p><font style="vertical-align: inherit;">请注意，如果组件设置为已修改，则其所有祖先也将设置为已修改。但是，如果您调用</font><code>setWindowModified(false)</code><font style="vertical-align: inherit;">一个组件，这将不会传播到其父级，因为父级的其他子级可能已被修改。</font></p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> bool </td><td class="memItemRight bottomAlign"><span class="name"><b>isWindowModified</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setWindowModified</b></span>(<i>bool</i>)</td></tr>
</table></div>
<p><b>请参考 </b><a href="qwidget.html#windowTitle-prop">windowTitle</a>, <a href="qtwidgets-mainwindows-application-example.html">Application 
<span lang="zh-cn">示例</span></a>, <a href="qtwidgets-mainwindows-sdi-example.html">SDI 
<span lang="zh-cn">示例</span></a>, <span lang="zh-cn">和 </span>
<a href="qtwidgets-mainwindows-mdi-example.html">MDI <span lang="zh-cn">示例</span></a>.</p>
<!-- @@@windowModified -->
<!-- $$$windowOpacity-prop$$$windowOpacity$$$setWindowOpacityqreal -->
<h3 class="fn" id="windowOpacity-prop"><a name="windowOpacity-prop"></a><span class="name">windowOpacity</span> : <span class="type">double</span></h3>
<p><font style="vertical-align: inherit;">此属性保存窗口的不透明度级别。</font></p>
<p><font style="vertical-align: inherit;">明度的有效范围是从 1.0（完全不透明）到 0.0（完全透明）。</font></p>
<p><font style="vertical-align: inherit;">默认情况下，此属性的值为 1.0。</font></p>
<p><font style="vertical-align: inherit;">此功能在支持 Composite 扩展的嵌入式 Linux、</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtdoc/internationalization.html#macos"><font style="vertical-align: inherit;">macOS</font></a><font style="vertical-align: inherit;">、Windows 和 X11 平台。</font></p>
<p><b><font style="vertical-align: inherit;">注意：</font></b><font style="vertical-align: inherit;">在 X11 上，您需要运行复合管理器，并且您正在使用的窗口管理器需要支持 X11 特定的 _NET_WM_WINDOW_OPACITY 原子。</font></p><p><b><font style="vertical-align: inherit;">警告：</font></b><font style="vertical-align: inherit;">将此属性从不透明更改为透明可能会发出需要在正确显示窗口之前处理的绘制事件。这主要影响 QPixmap::grabWindow() 的使用。另请注意，半透明窗口的更新和调整大小明显慢于不透明窗口。</font></p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> qreal </td><td class="memItemRight bottomAlign"><span class="name"><b>windowOpacity</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setWindowOpacity</b></span>(qreal <i>level</i>)</td></tr>
</table></div>
<p><b>请参考 </b><a href="qwidget.html#setMask">setMask</a>()<span lang="zh-cn">。</span></p>
<!-- @@@windowOpacity -->
<!-- $$$windowTitle-prop$$$windowTitle$$$setWindowTitleconstQString&$$$windowTitleChangedconstQString& -->
<h3 class="fn" id="windowTitle-prop"><a name="windowTitle-prop"></a><span class="name">windowTitle</span> : <span class="type"><a href="../qtcore/qstring.html">QString</a></span></h3>
<p><font style="vertical-align: inherit;">此属性保存窗口标题（标题）</font></p>
<p><font style="vertical-align: inherit;">此属性仅对顶级组件有意义，例如窗口和对话框。如果未设置标题，则标题基于</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#windowFilePath-prop"><font style="vertical-align: inherit;">windowFilePath</font></a><font style="vertical-align: inherit;">。如果这些都没有设置，则标题是一个空字符串。</font></p>
<p><font style="vertical-align: inherit;">如果您使用</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#windowModified-prop"><font style="vertical-align: inherit;">windowModified</font></a><font style="vertical-align: inherit;">机制，则窗口标题必须包含一个“[*]”占位符，它指示“*”应该出现的位置。通常，它应该出现在文件名之后（例如，“document1.txt[*] - 文本编辑器”）。如果</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#windowModified-prop"><font style="vertical-align: inherit;">windowModified</font></a><font style="vertical-align: inherit;">属性是</font><code>false</code><font style="vertical-align: inherit;">（默认值），则简单地删除占位符。</font></p>
<p><font style="vertical-align: inherit;">在某些桌面平台（包括 Windows 和 Unix）上，应用程序名称（来自</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtgui/qguiapplication.html#applicationDisplayName-prop"><font style="vertical-align: inherit;">QGuiApplication::applicationDisplayName</font></a><font style="vertical-align: inherit;">）会添加到窗口标题的末尾（如果已设置）。这是由 QPA 插件完成的，因此它会显示给用户，但不是 windowTitle 字符串的一部分。</font></p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> QString </td><td class="memItemRight bottomAlign"><span class="name"><b>windowTitle</b></span>() const</td></tr>
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b>setWindowTitle</b></span>(<i>const QString &amp;</i>)</td></tr>
</table></div>
<p><b>Notifier signal:</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> void </td><td class="memItemRight bottomAlign"><span class="name"><b><a href="qwidget.html#windowTitleChanged">windowTitleChanged</a></b></span>(const QString &amp;<i>title</i>)</td></tr>
</table></div>
<p><b>请参考 </b><a href="qwidget.html#windowIcon-prop">windowIcon</a>, <a href="qwidget.html#windowModified-prop">windowModified</a>,
<span lang="zh-cn">和 </span><a href="qwidget.html#windowFilePath-prop">windowFilePath</a><span lang="zh-cn">。</span></p>
<!-- @@@windowTitle -->
<!-- $$$x-prop$$$x -->
<h3 class="fn" id="x-prop"><a name="x-prop"></a><span class="name">x</span> : const <span class="type">int</span></h3>
<p><font style="vertical-align: inherit;">此属性保存组件相对于其父级的 x 坐标，包括任何窗口框架</font></p>
<p><font style="vertical-align: inherit;">有关</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtwidgets/application-windows.html#window-geometry"><font style="vertical-align: inherit;">窗口几何</font></a><font style="vertical-align: inherit;">问题的概述，请参阅<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtwidgets/application-windows.html#window-geometry">窗口几何</a>文档。</font></p>
<p><font style="vertical-align: inherit;">默认情况下，此属性的值为 0。</font></p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> int </td><td class="memItemRight bottomAlign"><span class="name"><b>x</b></span>() const</td></tr>
</table></div>
<p><b>请参考 </b><a href="qwidget.html#frameGeometry-prop">frameGeometry</a>, <a href="qwidget.html#y-prop">y</a>,
<span lang="zh-cn">和 </span><a href="qwidget.html#pos-prop">pos</a><span lang="zh-cn">。</span></p>
<!-- @@@x -->
<!-- $$$y-prop$$$y -->
<h3 class="fn" id="y-prop"><a name="y-prop"></a><span class="name">y</span> : const <span class="type">int</span></h3>
<p><font style="vertical-align: inherit;">此属性保存组件相对于其父级的 y 坐标，包括任何窗口框架</font></p>
<p><font style="vertical-align: inherit;">有关</font><a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtwidgets/application-windows.html#window-geometry"><font style="vertical-align: inherit;">窗口几何</font></a><font style="vertical-align: inherit;">问题的概述，请参阅<a href="file:///E:/WLL/work/Qt5.12-Document-Trans-in-Chinese/qtwidgets/application-windows.html#window-geometry">窗口几何</a>文档。</font></p>
<p><font style="vertical-align: inherit;">默认情况下，此属性的值为 0。</font></p>
<p><b>访问函数：</b></p>
<div class="table"><table class="alignedsummary">
<tr><td class="memItemLeft topAlign rightAlign"> int </td><td class="memItemRight bottomAlign"><span class="name"><b>y</b></span>() const</td></tr>
</table></div>
<p><b>请参考 </b><a href="qwidget.html#frameGeometry-prop">frameGeometry</a>, <a href="qwidget.html#x-prop">x</a>,
<span lang="zh-cn">和 </span><a href="qwidget.html#pos-prop">pos</a><span lang="zh-cn">。</span></p>
<!-- @@@y -->
</div>
<div class="func">
<h2><span lang="zh-cn">成员函数文档</span></h2>
<!-- $$$QWidget[overload1]$$$QWidgetQWidget*Qt::WindowFlags -->
<h3 class="fn" id="QWidget"><a name="QWidget"></a>QWidget::<span class="name">QWidget</span>(<span class="type"><a href="qwidget.html#QWidget">QWidget</a></span> *<i>parent</i> = nullptr, <span class="type"><a href="../qtcore/qt.html#WindowType-enum">Qt::WindowFlags</a></span> <i>f</i> = ...)</h3>
<p><font style="vertical-align: inherit;">构造一个组件，它是</font><i><font style="vertical-align: inherit;">parent</font></i><font style="vertical-align: inherit;">的子组件，组件标志设置为</font><i><font style="vertical-align: inherit;">f</font></i><font style="vertical-align: inherit;">。</font></p>
<p><font style="vertical-align: inherit;">如果</font><i><font style="vertical-align: inherit;">parent</font></i><font style="vertical-align: inherit;">为 0，则新组件将成为一个窗口。如果</font><i><font style="vertical-align: inherit;">parent</font></i><font style="vertical-align: inherit;">是另一个组件，则此组件将成为</font><i><font style="vertical-align: inherit;">parent</font></i><font style="vertical-align: inherit;">内的子窗口。删除</font><i><font style="vertical-align: inherit;">其父级</font></i><font style="vertical-align: inherit;">时，新组件也将被删除。</font></p>
<p><font style="vertical-align: inherit;">组件标志参数</font><i><font style="vertical-align: inherit;">f</font></i><font style="vertical-align: inherit;">通常为 0，但可以设置它来自定义窗口的框架（即</font><i><font style="vertical-align: inherit;">父级</font></i><font style="vertical-align: inherit;">必须为 0）。要自定义框架，请使用由任何</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtcore/qt.html#WindowType-enum"><font style="vertical-align: inherit;">窗口标志</font></a><font style="vertical-align: inherit;">的按位 OR 组成的值。</font></p>
<p><font style="vertical-align: inherit;">如果将子组件添加到已经可见的组件，则必须明确显示子组件以使其可见。</font></p>
<p><font style="vertical-align: inherit;">请注意，X11 版本的 Qt 可能无法在所有系统上提供所有样式标志组合。这是因为在 X11 上，Qt 只能询问窗口管理器，而窗口管理器可以覆盖应用程序的设置。在 Windows 上，Qt 可以设置任何你想要的标志。</font></p>
<p><b>请参考 </b><a href="qwidget.html#windowFlags-prop">windowFlags</a><span lang="zh-cn">。</span></p>
<!-- @@@QWidget -->
<!-- $$$~QWidget[overload1]$$$~QWidget -->
<h3 class="fn" id="dtor.QWidget"><a name="dtor.QWidget"></a><code>[virtual] </code>QWidget::<span class="name">~QWidget</span>()</h3>
<p><font style="vertical-align: inherit;">销毁组件。</font></p>
<p><font style="vertical-align: inherit;">首先删除所有此组件的子组件。如果此组件是主组件，则应用程序退出。</font></p>
<!-- @@@~QWidget -->
<!-- $$$actionEvent[overload1]$$$actionEventQActionEvent* -->
<h3 class="fn" id="actionEvent"><a name="actionEvent"></a><code>[virtual protected] </code><span class="type">void</span> QWidget::<span class="name">actionEvent</span>(<span class="type"><a href="../qtgui/qactionevent.html">QActionEvent</a></span> *<i>event</i>)</h3>
<p><font style="vertical-align: inherit;">每当组件的<span lang="zh-cn">动作</span>发生更改时，都会使用给定的<i>event</i> 调用此事件处理程序。</font></p>
<p><b>请参考 </b><a href="qwidget.html#addAction">addAction</a>(), <a href="qwidget.html#insertAction">insertAction</a>(), <a href="qwidget.html#removeAction">removeAction</a>(), <a href="qwidget.html#actions">actions</a>(),
<span lang="zh-cn">和 </span><a href="../qtgui/qactionevent.html">QActionEvent</a><span lang="zh-cn">。</span></p>
<!-- @@@actionEvent -->
<!-- $$$actions[overload1]$$$actions -->
<h3 class="fn" id="actions"><a name="actions"></a><span class="type"><a href="../qtcore/qlist.html">QList</a></span>&lt;<span class="type"><a href="qaction.html">QAction</a></span> *&gt; QWidget::<span class="name">actions</span>() const</h3>
<p><font style="vertical-align: inherit;">返回此组件<span lang="zh-cn">动作</span>的（可能为空）列表。</font></p>
<p><b>请参考 </b><a href="qwidget.html#contextMenuPolicy-prop">contextMenuPolicy</a>, <a href="qwidget.html#insertAction">insertAction</a>(),
<span lang="zh-cn">和 </span><a href="qwidget.html#removeAction">removeAction</a>()<span lang="zh-cn">。</span></p>
<!-- @@@actions -->
<!-- $$$activateWindow[overload1]$$$activateWindow -->
<h3 class="fn" id="activateWindow"><a name="activateWindow"></a><span class="type">void</span> QWidget::<span class="name">activateWindow</span>()</h3>
<p><font style="vertical-align: inherit;">将包含此组件的顶级组件设置为活动窗口。</font></p>
<p><font style="vertical-align: inherit;">活动窗口是具有键盘输入焦点的可见顶级窗口。</font></p>
<p><font style="vertical-align: inherit;">此函数执行与在顶级窗口的标题栏上单击鼠标相同的操作。在 X11 上，结果取决于窗口管理器。如果您想确保窗口也堆叠在顶部，您还应该调用</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#raise"><font style="vertical-align: inherit;">raise</font></a><font style="vertical-align: inherit;"> ()。注意窗口必须是可见的，否则 activateWindow() 不起作用。</font></p>
<p><font style="vertical-align: inherit;">在 Windows 上，如果您在应用程序当前不是活动窗口时调用它，那么它不会使其成为活动窗口。它将更改任务栏条目的颜色以指示窗口已以某种方式更改。这是因为 Microsoft 不允许应用程序中断用户当前在另一个应用程序中执行的操作。</font></p>
<p><b>请参考 </b><a href="qwidget.html#isActiveWindow-prop">isActiveWindow</a>(), <a href="qwidget.html#window">window</a>(), <a href="qwidget.html#show">show</a>(),
<span lang="zh-cn">和 </span>
<a href="../qtplatformheaders/qwindowswindowfunctions.html#setWindowActivationBehavior">QWindowsWindowFunctions::setWindowActivationBehavior</a>()<span lang="zh-cn">。</span></p>
<!-- @@@activateWindow -->
<!-- $$$addAction[overload1]$$$addActionQAction* -->
<h3 class="fn" id="addAction"><a name="addAction"></a><span class="type">void</span> QWidget::<span class="name">addAction</span>(<span class="type"><a href="qaction.html">QAction</a></span> *<i>action</i>)</h3>
<p><font style="vertical-align: inherit;">将动作<i>action</i>附加到此组件的动作列表中。</font></p>
<p><font style="vertical-align: inherit;">&nbsp;QWidget 都有一个</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qaction.html"><font style="vertical-align: inherit;">QAction</font></a><font style="vertical-align: inherit;">列表，但是它们可以用许多不同的方式以图形方式表示。</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qaction.html"><font style="vertical-align: inherit;">QAction</font></a><font style="vertical-align: inherit;">列表（由</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#actions"><font style="vertical-align: inherit;">actions</font></a><font style="vertical-align: inherit;"> ()返回）的默认用途是创建上下文</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qmenu.html"><font style="vertical-align: inherit;">QMenu</font></a><font style="vertical-align: inherit;">。</font></p>
<p><font style="vertical-align: inherit;">一个</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html"><font style="vertical-align: inherit;">QWidget</font></a><span lang="zh-cn">只</span><font style="vertical-align: inherit;"><span lang="zh-cn">应该拥有</span>每个动作<span lang="zh-cn">的一个实例</span>，<span lang="zh-cn">而不应该有多个，避免重复动作。</span></font></p>
<p><i><font style="vertical-align: inherit;">action</font></i><font style="vertical-align: inherit;">的所有权不会转移到这个</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html"><font style="vertical-align: inherit;">QWidget</font></a><font style="vertical-align: inherit;">。</font></p>
<p><b>请参考 </b><a href="qwidget.html#removeAction">removeAction</a>(), <a href="qwidget.html#insertAction">insertAction</a>(), <a href="qwidget.html#actions">actions</a>(),
<span lang="zh-cn">和 </span><a href="qmenu.html">QMenu</a><span lang="zh-cn">。</span></p>
<!-- @@@addAction -->
<!-- $$$addActions[overload1]$$$addActionsQList<QAction*> -->
<h3 class="fn" id="addActions"><a name="addActions"></a><span class="type">void</span> QWidget::<span class="name">addActions</span>(<span class="type"><a href="../qtcore/qlist.html">QList</a></span>&lt;<span class="type"><a href="qaction.html">QAction</a></span> *&gt; <i>actions</i>)</h3>
<p><font style="vertical-align: inherit;">将操作<i>actions<span lang="zh-cn">
</span></i>附加到此组件的<span lang="zh-cn">动作</span>列表。</font></p>
<p><b>请参考 </b><a href="qwidget.html#removeAction">removeAction</a>(), <a href="qmenu.html">QMenu</a>,
<span lang="zh-cn">和 </span><a href="qwidget.html#addAction">addAction</a>()<span lang="zh-cn">。</span></p>
<!-- @@@addActions -->
<!-- $$$adjustSize[overload1]$$$adjustSize -->
<h3 class="fn" id="adjustSize"><a name="adjustSize"></a><span class="type">void</span> QWidget::<span class="name">adjustSize</span>()</h3>
<p><font style="vertical-align: inherit;">调整组件的大小以适合其内容。</font></p>
<p><font style="vertical-align: inherit;">如果有效，则此函数使用</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#sizeHint-prop"><font style="vertical-align: inherit;">sizeHint</font></a><font style="vertical-align: inherit;"> ()，即尺寸提示的宽度和高度 &gt;= 0。否则，它将大小设置为覆盖所有子组件的子矩形（所有子组件矩形的联合）。</font></p>
<p><font style="vertical-align: inherit;">对于 Windows，还考虑了屏幕尺寸。如果</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#sizeHint-prop"><font style="vertical-align: inherit;">sizeHint</font></a><font style="vertical-align: inherit;"> () 小于 (200, 100) 并且大小策略正在</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qsizepolicy.html#Policy-enum"><font style="vertical-align: inherit;"><span lang="zh-cn">expanding(扩</span>展</font></a><span lang="zh-cn">）</span><font style="vertical-align: inherit;">，则窗口将至少为 (200, 100)。窗口的最大尺寸是屏幕宽度和高度的 2/3。</font></p>
<p><b>请参考 </b><a href="qwidget.html#sizeHint-prop">sizeHint</a>()
<span lang="zh-cn">和 </span><a href="qwidget.html#childrenRect-prop">childrenRect</a>()<span lang="zh-cn">。</span></p>
<!-- @@@adjustSize -->
<!-- $$$backgroundRole[overload1]$$$backgroundRole -->
<h3 class="fn" id="backgroundRole"><a name="backgroundRole"></a><span class="type"><a href="../qtgui/qpalette.html#ColorRole-enum">QPalette::ColorRole</a></span> QWidget::<span class="name">backgroundRole</span>() const</h3>
<p><font style="vertical-align: inherit;">返回组件的背景角色。</font></p>
<p><font style="vertical-align: inherit;">背景角色定义了用于渲染背景的组件</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#palette-prop"><font style="vertical-align: inherit;">调色板</font></a><font style="vertical-align: inherit;">中的画笔。</font></p>
<p><font style="vertical-align: inherit;">背景角色定义了用于渲染背景的组件</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#palette-prop"><font style="vertical-align: inherit;">调色板</font></a><font style="vertical-align: inherit;">中的画笔。</font></p>
<p><b>请参考 </b><a href="qwidget.html#setBackgroundRole">setBackgroundRole</a>()
<span lang="zh-cn">和 </span><a href="qwidget.html#foregroundRole">foregroundRole</a>()<span lang="zh-cn">。</span></p>
<!-- @@@backgroundRole -->
<!-- $$$backingStore[overload1]$$$backingStore -->
<h3 class="fn" id="backingStore"><a name="backingStore"></a><span class="type"><a href="../qtgui/qbackingstore.html">QBackingStore</a></span> *QWidget::<span class="name">backingStore</span>() const</h3>
<p><font style="vertical-align: inherit;">返回此组件将被绘制到的</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtgui/qbackingstore.html"><font style="vertical-align: inherit;">QBackingStore</font></a><font style="vertical-align: inherit;">。</font></p>
<p><font style="vertical-align: inherit;">这个函数是在 Qt 5.0 中引入的。</font></p>
<!-- @@@backingStore -->
<!-- $$$changeEvent[overload1]$$$changeEventQEvent* -->
<h3 class="fn" id="changeEvent"><a name="changeEvent"></a><code>[virtual protected] </code><span class="type">void</span> QWidget::<span class="name">changeEvent</span>(<span class="type"><a href="../qtcore/qevent.html">QEvent</a></span> *<i>event</i>)</h3>
<p><font style="vertical-align: inherit;">可以重新实现此事件处理程序以处理状态更改。</font></p>
<p><font style="vertical-align: inherit;">可以通过提供的<i>event<span lang="zh-cn"> 检</span></i>索此事件中正在更改的状态。</font></p>
<p><font style="vertical-align: inherit;">更改事件包括：</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtcore/qevent.html#Type-enum"><font style="vertical-align: inherit;">QEvent::ToolBarChange</font></a><font style="vertical-align: inherit;">、</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtcore/qevent.html#Type-enum"><font style="vertical-align: inherit;">QEvent::ActivationChange</font></a><font style="vertical-align: inherit;">、</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtcore/qevent.html#Type-enum"><font style="vertical-align: inherit;">QEvent::EnabledChange</font></a><font style="vertical-align: inherit;">、</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtcore/qevent.html#Type-enum"><font style="vertical-align: inherit;">QEvent::FontChange</font></a><font style="vertical-align: inherit;">、</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtcore/qevent.html#Type-enum"><font style="vertical-align: inherit;">QEvent::StyleChange</font></a><font style="vertical-align: inherit;">、</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtcore/qevent.html#Type-enum"><font style="vertical-align: inherit;">QEvent::PaletteChange</font></a><font style="vertical-align: inherit;">、</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtcore/qevent.html#Type-enum"><font style="vertical-align: inherit;">QEvent::WindowTitleChange</font></a><font style="vertical-align: inherit;">、</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtcore/qevent.html#Type-enum"><font style="vertical-align: inherit;">QEvent::IconTextChange</font></a><font style="vertical-align: inherit;">、</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtcore/qevent.html#Type-enum"><font style="vertical-align: inherit;">QEvent::ModifiedChange</font></a><font style="vertical-align: inherit;">、</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtcore/qevent.html#Type-enum"><font style="vertical-align: inherit;">QEvent ::MouseTrackingChange</font></a><font style="vertical-align: inherit;">、</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtcore/qevent.html#Type-enum"><font style="vertical-align: inherit;">QEvent::ParentChange</font></a><font style="vertical-align: inherit;">、</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtcore/qevent.html#Type-enum"><font style="vertical-align: inherit;">QEvent::WindowStateChange</font></a><font style="vertical-align: inherit;">、</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtcore/qevent.html#Type-enum"><font style="vertical-align: inherit;">QEvent::LanguageChange</font></a><font style="vertical-align: inherit;">、</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtcore/qevent.html#Type-enum"><font style="vertical-align: inherit;">QEvent::LocaleChange</font></a><font style="vertical-align: inherit;">、</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtcore/qevent.html#Type-enum"><font style="vertical-align: inherit;">QEvent::LayoutDirectionChange</font></a><font style="vertical-align: inherit;">、</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtcore/qevent.html#Type-enum"><font style="vertical-align: inherit;">QEvent::ReadOnlyChange</font></a><font style="vertical-align: inherit;">。</font></p>
<!-- @@@changeEvent -->
<!-- $$$childAt[overload1]$$$childAtintint -->
<h3 class="fn" id="childAt"><a name="childAt"></a><span class="type"><a href="qwidget.html#QWidget">QWidget</a></span> *QWidget::<span class="name">childAt</span>(<span class="type">int</span> <i>x</i>, <span class="type">int</span> <i>y</i>) const</h3>
<p><font style="vertical-align: inherit;">返回组件坐标系中位置 ( </font><i><font style="vertical-align: inherit;">x</font></i><font style="vertical-align: inherit;"> , </font><i><font style="vertical-align: inherit;">y</font></i><font style="vertical-align: inherit;"> )处的可见子组件。如果指定位置没有可见的子组件，则函数返回</font><code>nullptr</code><font style="vertical-align: inherit;">。</font></p>
<!-- @@@childAt -->
<!-- $$$childAt$$$childAtconstQPoint& -->
<h3 class="fn" id="childAt-1"><a name="childAt-1"></a><span class="type"><a href="qwidget.html#QWidget">QWidget</a></span> *QWidget::<span class="name">childAt</span>(const <span class="type"><a href="../qtcore/qpoint.html">QPoint</a></span> &amp;<i>p</i>) const</h3>
<p><font style="vertical-align: inherit;">这是一个<span lang="zh-cn">重载函数</span>。</font></p>
<p><font style="vertical-align: inherit;">返回组件自己坐标系中</font><i><font style="vertical-align: inherit;">p</font></i><font style="vertical-align: inherit;">点处的可见子组件。</font></p>
<!-- @@@childAt -->
<!-- $$$clearFocus[overload1]$$$clearFocus -->
<h3 class="fn" id="clearFocus"><a name="clearFocus"></a><span class="type">void</span> QWidget::<span class="name">clearFocus</span>()</h3>
<p><font style="vertical-align: inherit;">从组件获取键盘输入焦点。</font></p>
<p><font style="vertical-align: inherit;">如果组件具有活动焦点，则向该组件发送</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#focusOutEvent"><font style="vertical-align: inherit;">焦点移出事件</font></a><font style="vertical-align: inherit;">以告知它已失去焦点。</font></p>
<p><font style="vertical-align: inherit;">这个组件必须启用焦点设置才能获得键盘输入焦点，即它必须调用</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#focusPolicy-prop"><font style="vertical-align: inherit;">setFocusPolicy</font></a><font style="vertical-align: inherit;"> ()。</font></p>
<p><b>请参考 </b><a href="qwidget.html#focus-prop">hasFocus</a>(), <a href="qwidget.html#setFocus-1">setFocus</a>(), <a href="qwidget.html#focusInEvent">focusInEvent</a>(), <a href="qwidget.html#focusOutEvent">focusOutEvent</a>(), <a href="qwidget.html#focusPolicy-prop">setFocusPolicy</a>(),
<span lang="zh-cn">和 </span><a href="qapplication.html#focusWidget">QApplication::focusWidget</a>()<span lang="zh-cn">。</span></p>
<!-- @@@clearFocus -->
<!-- $$$clearMask[overload1]$$$clearMask -->
<h3 class="fn" id="clearMask"><a name="clearMask"></a><span class="type">void</span> QWidget::<span class="name">clearMask</span>()</h3>
<p><font style="vertical-align: inherit;">删除由</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#setMask"><font style="vertical-align: inherit;">setMask</font></a><font style="vertical-align: inherit;"> ()设置的任何掩码。</font></p>
<p><b>请参考 </b><a href="qwidget.html#setMask">setMask</a>().</p>
<!-- @@@clearMask -->
<!-- $$$close[overload1]$$$close -->
<h3 class="fn" id="close"><a name="close"></a><code>[slot] </code><span class="type">bool</span> QWidget::<span class="name">close</span>()</h3>
<p><font style="vertical-align: inherit;">关闭此组件。返回</font><code>true</code><font style="vertical-align: inherit;">组件是否已关闭；否则返回</font><code>false</code><font style="vertical-align: inherit;">。</font></p>
<p><font style="vertical-align: inherit;">首先它向组件发送一个</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtgui/qcloseevent.html"><font style="vertical-align: inherit;">QCloseEvent</font></a><font style="vertical-align: inherit;">。如果组件<a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtcore/qevent.html#accept">接受</a>关闭事件，它就会被</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#hide"><font style="vertical-align: inherit;">隐藏</font></a><font style="vertical-align: inherit;">。如果它<a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtcore/qevent.html#ignore">忽略</a>该事件，则什么也不会发生。<a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtwidgets/qwidget.html#closeEvent">QWidget::closeEvent</a> ()的默认实现接受关闭事件。</font></p>
<p><font style="vertical-align: inherit;">如果组件具有</font><a href="file:///E:/_Personal/Qt5.12-Document-Trans-in-Chinese/qtcore/qt.html#WidgetAttribute-enum"><font style="vertical-align: inherit;">Qt::WA_DeleteOnClose</font></a><font style="vertical-align: inherit;">标志，则组件也会被删除。无论组件是否可见，都会向组件传递关闭事件。</font></p>
<p><font style="vertical-align: inherit;"><span lang="zh-cn">当最后可见的主窗口具有<a href="../qtcore/qt.html#WidgetAttribute-enum">Qt::WA_QuitOnClose</a>属性集并且关闭，<a href="../qtgui/qguiapplication.html#lastWindowClosed">QApplication::lastWindowClosed</a>（）信号将被发射。默认情况下，为所有组件设置此属性，但瞬态窗口除外，例如闪屏、工具窗口和弹出菜单。</span></font></p>
<!-- @@@close -->
<!-- $$$closeEvent[overload1]$$$closeEventQCloseEvent* -->
<h3 class="fn" id="closeEvent"><a name="closeEvent"></a><code>[virtual protected] </code><span class="type">void</span> QWidget::<span class="name">closeEvent</span>(<span class="type"><a href="../qtgui/qcloseevent.html">QCloseEvent</a></span> *<i>event</i>)</h3>
<p><font style="vertical-align: inherit;">当 Qt 从窗口系统接收到对顶级组件的窗口关闭请求时，将使用给定的<i>event</i>调用此事件处理程序。</font></p>
<p>By default, the event is accepted and the widget is closed. You can reimplement this function to change the way the widget responds to window close requests. For example, you can prevent the window from closing by calling <a href="../qtcore/qevent.html#ignore">ignore()</a> on all events.</p>
<p>Main window applications typically use reimplementations of this function to check whether the user's work has been saved and ask for permission before closing. For example, the <a href="qtwidgets-mainwindows-application-example.html">Application Example</a> uses a helper function to determine whether or not to close the window:</p>
<pre class="cpp">

  <span class="type">void</span> MainWindow<span class="operator">::</span>closeEvent(<span class="type"><a href="../qtgui/qcloseevent.html">QCloseEvent</a></span> <span class="operator">*</span>event)
  {
      <span class="keyword">if</span> (maybeSave()) {
          writeSettings();
          event<span class="operator">-</span><span class="operator">&gt;</span>accept();
      } <span class="keyword">else</span> {
          event<span class="operator">-</span><span class="operator">&gt;</span>ignore();
      }
  }

</pre>
<p><b>请参考 </b><a href="qwidget.html#event">event</a>(), <a href="qwidget.html#hide">hide</a>(), <a href="qwidget.html#close">close</a>(), <a href="../qtgui/qcloseevent.html">QCloseEvent</a>, and <a href="qtwidgets-mainwindows-application-example.html">Application Example</a>.</p>
<!-- @@@closeEvent -->
<!-- $$$contentsMargins[overload1]$$$contentsMargins -->
<h3 class="fn" id="contentsMargins"><a name="contentsMargins"></a><span class="type"><a href="../qtcore/qmargins.html">QMargins</a></span> QWidget::<span class="name">contentsMargins</span>() const</h3>
<p>The contentsMargins function returns the widget's contents margins.</p>
<p>This function was introduced in  Qt 4.6.</p>
<p><b>请参考 </b><a href="qwidget.html#getContentsMargins">getContentsMargins</a>(), <a href="qwidget.html#setContentsMargins">setContentsMargins</a>(), and <a href="qwidget.html#contentsRect">contentsRect</a>().</p>
<!-- @@@contentsMargins -->
<!-- $$$contentsRect[overload1]$$$contentsRect -->
<h3 class="fn" id="contentsRect"><a name="contentsRect"></a><span class="type"><a href="../qtcore/qrect.html">QRect</a></span> QWidget::<span class="name">contentsRect</span>() const</h3>
<p>Returns the area inside the widget's margins.</p>
<p><b>请参考 </b><a href="qwidget.html#setContentsMargins">setContentsMargins</a>() and <a href="qwidget.html#getContentsMargins">getContentsMargins</a>().</p>
<!-- @@@contentsRect -->
<!-- $$$contextMenuEvent[overload1]$$$contextMenuEventQContextMenuEvent* -->
<h3 class="fn" id="contextMenuEvent"><a name="contextMenuEvent"></a><code>[virtual protected] </code><span class="type">void</span> QWidget::<span class="name">contextMenuEvent</span>(<span class="type"><a href="../qtgui/qcontextmenuevent.html">QContextMenuEvent</a></span> *<i>event</i>)</h3>
<p>This event handler, for event <i>event</i>, can be reimplemented in a subclass to receive widget context menu events.</p>
<p>The handler is called when the widget's <a href="qwidget.html#contextMenuPolicy-prop">contextMenuPolicy</a> is <a href="../qtcore/qt.html#ContextMenuPolicy-enum">Qt::DefaultContextMenu</a>.</p>
<p>The default implementation ignores the context event. See the <a href="../qtgui/qcontextmenuevent.html">QContextMenuEvent</a> documentation for more details.</p>
<p><b>请参考 </b><a href="qwidget.html#event">event</a>(), <a href="../qtgui/qcontextmenuevent.html">QContextMenuEvent</a>, and <a href="qwidget.html#customContextMenuRequested">customContextMenuRequested</a>().</p>
<!-- @@@contextMenuEvent -->
<!-- $$$create[overload1]$$$createWIdboolbool -->
<h3 class="fn" id="create"><a name="create"></a><code>[protected] </code><span class="type">void</span> QWidget::<span class="name">create</span>(<span class="type">WId</span> <i>window</i> = 0, <span class="type">bool</span> <i>initializeWindow</i> = true, <span class="type">bool</span> <i>destroyOldWindow</i> = true)</h3>
<p>Creates a new widget window.</p>
<p>The parameter <i>window</i> is ignored in Qt 5. Please use <a href="../qtgui/qwindow.html#fromWinId">QWindow::fromWinId</a>() to create a <a href="../qtgui/qwindow.html">QWindow</a> wrapping a foreign window and pass it to <a href="qwidget.html#createWindowContainer">QWidget::createWindowContainer</a>() instead.</p>
<p>Initializes the window (sets the geometry etc.) if <i>initializeWindow</i> is true. If <i>initializeWindow</i> is false, no initialization is performed. This parameter only makes sense if <i>window</i> is a valid window.</p>
<p>Destroys the old window if <i>destroyOldWindow</i> is true. If <i>destroyOldWindow</i> is false, you are responsible for destroying the window yourself (using platform native code).</p>
<p>The <a href="qwidget.html">QWidget</a> constructor calls create(0,true,true) to create a window for this widget.</p>
<p><b>请参考 </b><a href="qwidget.html#createWindowContainer">createWindowContainer</a>() and <a href="../qtgui/qwindow.html#fromWinId">QWindow::fromWinId</a>().</p>
<!-- @@@create -->
<!-- $$$createWindowContainer[overload1]$$$createWindowContainerQWindow*QWidget*Qt::WindowFlags -->
<h3 class="fn" id="createWindowContainer"><a name="createWindowContainer"></a><code>[static] </code><span class="type"><a href="qwidget.html#QWidget">QWidget</a></span> *QWidget::<span class="name">createWindowContainer</span>(<span class="type"><a href="../qtgui/qwindow.html">QWindow</a></span> *<i>window</i>, <span class="type"><a href="qwidget.html#QWidget">QWidget</a></span> *<i>parent</i> = nullptr, <span class="type"><a href="../qtcore/qt.html#WindowType-enum">Qt::WindowFlags</a></span> <i>flags</i> = ...)</h3>
<p>Creates a <a href="qwidget.html">QWidget</a> that makes it possible to embed <i>window</i> into a <a href="qwidget.html">QWidget</a>-based application.</p>
<p>The window container is created as a child of <i>parent</i> and with window flags <i>flags</i>.</p>
<p>Once the window has been embedded into the container, the container will control the window's geometry and visibility. Explicit calls to <a href="../qtgui/qwindow.html#setGeometry-1">QWindow::setGeometry</a>(), <a href="../qtgui/qwindow.html#show">QWindow::show</a>() or <a href="../qtgui/qwindow.html#hide">QWindow::hide</a>() on an embedded window is not recommended.</p>
<p>The container takes over ownership of <i>window</i>. The window can be removed from the window container with a call to <a href="../qtgui/qwindow.html#setParent">QWindow::setParent</a>().</p>
<p>The window container is attached as a native child window to the toplevel window it is a child of. When a window container is used as a child of a <a href="qabstractscrollarea.html">QAbstractScrollArea</a> or <a href="qmdiarea.html">QMdiArea</a>, it will create a <a href="qwidget.html#native-widgets-vs-alien-widgets">native window</a> for every widget in its parent chain to allow for proper stacking and clipping in this use case. Creating a native window for the window container also allows for proper stacking and clipping. This must be done before showing the window container. Applications with many native child windows may suffer from performance issues.</p>
<p>The window container has a number of known limitations:</p>
<ul>
<li>Stacking order; The embedded window will stack on top of the widget hierarchy as an opaque box. The stacking order of multiple overlapping window container instances is undefined.</li>
<li>Rendering Integration; The window container does not interoperate with <a href="qgraphicsproxywidget.html">QGraphicsProxyWidget</a>, <a href="qwidget.html#render">QWidget::render</a>() or similar functionality.</li>
<li>Focus Handling; It is possible to let the window container instance have any focus policy and it will delegate focus to the window via a call to <a href="../qtgui/qwindow.html#requestActivate">QWindow::requestActivate</a>(). However, returning to the normal focus chain from the <a href="../qtgui/qwindow.html">QWindow</a> instance will be up to the <a href="../qtgui/qwindow.html">QWindow</a> instance implementation itself. For instance, when entering a Qt Quick based window with tab focus, it is quite likely that further tab presses will only cycle inside the QML application. Also, whether <a href="../qtgui/qwindow.html#requestActivate">QWindow::requestActivate</a>() actually gives the window focus, is platform dependent.</li>
<li>Using many window container instances in a <a href="qwidget.html">QWidget</a>-based application can greatly hurt the overall performance of the application.</li>
</ul>
<!-- @@@createWindowContainer -->
<!-- $$$customContextMenuRequested[overload1]$$$customContextMenuRequestedconstQPoint& -->
<h3 class="fn" id="customContextMenuRequested"><a name="customContextMenuRequested"></a><code>[signal] </code><span class="type">void</span> QWidget::<span class="name">customContextMenuRequested</span>(const <span class="type"><a href="../qtcore/qpoint.html">QPoint</a></span> &amp;<i>pos</i>)</h3>
<p>This signal is emitted when the widget's <a href="qwidget.html#contextMenuPolicy-prop">contextMenuPolicy</a> is <a href="../qtcore/qt.html#ContextMenuPolicy-enum">Qt::CustomContextMenu</a>, and the user has requested a context menu on the widget. The position <i>pos</i> is the position of the context menu event that the widget receives. Normally this is in widget coordinates. The exception to this rule is <a href="qabstractscrollarea.html">QAbstractScrollArea</a> and its subclasses that map the context menu event to coordinates of the <a href="qabstractscrollarea.html#viewport">viewport()</a>.</p>
<p><b>请参考 </b><a href="qwidget.html#mapToGlobal">mapToGlobal</a>(), <a href="qmenu.html">QMenu</a>, and <a href="qwidget.html#contextMenuPolicy-prop">contextMenuPolicy</a>.</p>
<!-- @@@customContextMenuRequested -->
<!-- $$$destroy[overload1]$$$destroyboolbool -->
<h3 class="fn" id="destroy"><a name="destroy"></a><code>[protected] </code><span class="type">void</span> QWidget::<span class="name">destroy</span>(<span class="type">bool</span> <i>destroyWindow</i> = true, <span class="type">bool</span> <i>destroySubWindows</i> = true)</h3>
<p>Frees up window system resources. Destroys the widget window if <i>destroyWindow</i> is true.</p>
<p>destroy() calls itself recursively for all the child widgets, passing <i>destroySubWindows</i> for the <i>destroyWindow</i> parameter. To have more control over destruction of subwidgets, destroy subwidgets selectively first.</p>
<p>This function is usually called from the <a href="qwidget.html">QWidget</a> destructor.</p>
<!-- @@@destroy -->
<!-- $$$dragEnterEvent[overload1]$$$dragEnterEventQDragEnterEvent* -->
<h3 class="fn" id="dragEnterEvent"><a name="dragEnterEvent"></a><code>[virtual protected] </code><span class="type">void</span> QWidget::<span class="name">dragEnterEvent</span>(<span class="type"><a href="../qtgui/qdragenterevent.html">QDragEnterEvent</a></span> *<i>event</i>)</h3>
<p>This event handler is called when a drag is in progress and the mouse enters this widget. The event is passed in the <i>event</i> parameter.</p>
<p>If the event is ignored, the widget won't receive any <a href="qwidget.html#dragMoveEvent">drag move events</a>.</p>
<p>See the <a href="../qtgui/dnd.html">Drag-and-drop documentation</a> for an overview of how to provide drag-and-drop in your application.</p>
<p><b>请参考 </b><a href="../qtgui/qdrag.html">QDrag</a> and <a href="../qtgui/qdragenterevent.html">QDragEnterEvent</a>.</p>
<!-- @@@dragEnterEvent -->
<!-- $$$dragLeaveEvent[overload1]$$$dragLeaveEventQDragLeaveEvent* -->
<h3 class="fn" id="dragLeaveEvent"><a name="dragLeaveEvent"></a><code>[virtual protected] </code><span class="type">void</span> QWidget::<span class="name">dragLeaveEvent</span>(<span class="type"><a href="../qtgui/qdragleaveevent.html">QDragLeaveEvent</a></span> *<i>event</i>)</h3>
<p>This event handler is called when a drag is in progress and the mouse leaves this widget. The event is passed in the <i>event</i> parameter.</p>
<p>See the <a href="../qtgui/dnd.html">Drag-and-drop documentation</a> for an overview of how to provide drag-and-drop in your application.</p>
<p><b>请参考 </b><a href="../qtgui/qdrag.html">QDrag</a> and <a href="../qtgui/qdragleaveevent.html">QDragLeaveEvent</a>.</p>
<!-- @@@dragLeaveEvent -->
<!-- $$$dragMoveEvent[overload1]$$$dragMoveEventQDragMoveEvent* -->
<h3 class="fn" id="dragMoveEvent"><a name="dragMoveEvent"></a><code>[virtual protected] </code><span class="type">void</span> QWidget::<span class="name">dragMoveEvent</span>(<span class="type"><a href="../qtgui/qdragmoveevent.html">QDragMoveEvent</a></span> *<i>event</i>)</h3>
<p>This event handler is called if a drag is in progress, and when any of the following conditions occur: the cursor enters this widget, the cursor moves within this widget, or a modifier key is pressed on the keyboard while this widget has the focus. The event is passed in the <i>event</i> parameter.</p>
<p>See the <a href="../qtgui/dnd.html">Drag-and-drop documentation</a> for an overview of how to provide drag-and-drop in your application.</p>
<p><b>请参考 </b><a href="../qtgui/qdrag.html">QDrag</a> and <a href="../qtgui/qdragmoveevent.html">QDragMoveEvent</a>.</p>
<!-- @@@dragMoveEvent -->
<!-- $$$dropEvent[overload1]$$$dropEventQDropEvent* -->
<h3 class="fn" id="dropEvent"><a name="dropEvent"></a><code>[virtual protected] </code><span class="type">void</span> QWidget::<span class="name">dropEvent</span>(<span class="type"><a href="../qtgui/qdropevent.html">QDropEvent</a></span> *<i>event</i>)</h3>
<p>This event handler is called when the drag is dropped on this widget. The event is passed in the <i>event</i> parameter.</p>
<p>See the <a href="../qtgui/dnd.html">Drag-and-drop documentation</a> for an overview of how to provide drag-and-drop in your application.</p>
<p><b>请参考 </b><a href="../qtgui/qdrag.html">QDrag</a> and <a href="../qtgui/qdropevent.html">QDropEvent</a>.</p>
<!-- @@@dropEvent -->
<!-- $$$effectiveWinId[overload1]$$$effectiveWinId -->
<h3 class="fn" id="effectiveWinId"><a name="effectiveWinId"></a><span class="type">WId</span> QWidget::<span class="name">effectiveWinId</span>() const</h3>
<p>Returns the effective window system identifier of the widget, i.e&#x2e; the native parent's window system identifier.</p>
<p>If the widget is native, this function returns the native widget ID. Otherwise, the window ID of the first native parent widget, i.e&#x2e;, the top-level widget that contains this widget, is returned.</p>
<p><b>Note: </b>We recommend that you do not store this value as it is likely to change at run-time.</p><p>This function was introduced in  Qt 4.4.</p>
<p><b>请参考 </b><a href="qwidget.html#nativeParentWidget">nativeParentWidget</a>().</p>
<!-- @@@effectiveWinId -->
<!-- $$$ensurePolished[overload1]$$$ensurePolished -->
<h3 class="fn" id="ensurePolished"><a name="ensurePolished"></a><span class="type">void</span> QWidget::<span class="name">ensurePolished</span>() const</h3>
<p>Ensures that the widget and its children have been polished by <a href="qstyle.html">QStyle</a> (i.e&#x2e;, have a proper font and palette).</p>
<p><a href="qwidget.html">QWidget</a> calls this function after it has been fully constructed but before it is shown the very first time. You can call this function if you want to ensure that the widget is polished before doing an operation, e.g&#x2e;, the correct font size might be needed in the widget's <a href="qwidget.html#sizeHint-prop">sizeHint</a>() reimplementation. Note that this function <i>is</i> called from the default implementation of <a href="qwidget.html#sizeHint-prop">sizeHint</a>().</p>
<p>Polishing is useful for final initialization that must happen after all constructors (from base classes as well as from subclasses) have been called.</p>
<p>If you need to change some settings when a widget is polished, reimplement <a href="qwidget.html#event">event</a>() and handle the <a href="../qtcore/qevent.html#Type-enum">QEvent::Polish</a> event type.</p>
<p><b>Note:</b> The function is declared const so that it can be called from other const functions (e.g&#x2e;, <a href="qwidget.html#sizeHint-prop">sizeHint</a>()).</p>
<p><b>请参考 </b><a href="qwidget.html#event">event</a>().</p>
<!-- @@@ensurePolished -->
<!-- $$$enterEvent[overload1]$$$enterEventQEvent* -->
<h3 class="fn" id="enterEvent"><a name="enterEvent"></a><code>[virtual protected] </code><span class="type">void</span> QWidget::<span class="name">enterEvent</span>(<span class="type"><a href="../qtcore/qevent.html">QEvent</a></span> *<i>event</i>)</h3>
<p>This event handler can be reimplemented in a subclass to receive widget enter events which are passed in the <i>event</i> parameter.</p>
<p>An event is sent to the widget when the mouse cursor enters the widget.</p>
<p><b>请参考 </b><a href="qwidget.html#leaveEvent">leaveEvent</a>(), <a href="qwidget.html#mouseMoveEvent">mouseMoveEvent</a>(), and <a href="qwidget.html#event">event</a>().</p>
<!-- @@@enterEvent -->
<!-- $$$event[overload1]$$$eventQEvent* -->
<h3 class="fn" id="event"><code>[override virtual protected] </code><span class="type">bool</span> QWidget::<span class="name">event</span>(<span class="type"><a href="../qtcore/qevent.html">QEvent</a></span> *<i>event</i>)</h3>
<p>Reimplemented from <a href="../qtcore/qobject.html#event">QObject::event</a>().</p>
<p>This is the main event handler; it handles event <i>event</i>. You can reimplement this function in a subclass, but we recommend using one of the specialized event handlers instead.</p>
<p>Key press and release events are treated differently from other events. event() checks for Tab and Shift+Tab and tries to move the focus appropriately. If there is no widget to move the focus to (or the key press is not Tab or Shift+Tab), event() calls <a href="qwidget.html#keyPressEvent">keyPressEvent</a>().</p>
<p>Mouse and tablet event handling is also slightly special: only when the widget is <a href="qwidget.html#enabled-prop">enabled</a>, event() will call the specialized handlers such as <a href="qwidget.html#mousePressEvent">mousePressEvent</a>(); otherwise it will discard the event.</p>
<p>This function returns <code>true</code> if the event was recognized, otherwise it returns <code>false</code>. If the recognized event was accepted (see <a href="../qtcore/qevent.html#accepted-prop">QEvent::accepted</a>), any further processing such as event propagation to the parent widget stops.</p>
<p><b>请参考 </b><a href="qwidget.html#closeEvent">closeEvent</a>(), <a href="qwidget.html#focusInEvent">focusInEvent</a>(), <a href="qwidget.html#focusOutEvent">focusOutEvent</a>(), <a href="qwidget.html#enterEvent">enterEvent</a>(), <a href="qwidget.html#keyPressEvent">keyPressEvent</a>(), <a href="qwidget.html#keyReleaseEvent">keyReleaseEvent</a>(), <a href="qwidget.html#leaveEvent">leaveEvent</a>(), <a href="qwidget.html#mouseDoubleClickEvent">mouseDoubleClickEvent</a>(), <a href="qwidget.html#mouseMoveEvent">mouseMoveEvent</a>(), <a href="qwidget.html#mousePressEvent">mousePressEvent</a>(), <a href="qwidget.html#mouseReleaseEvent">mouseReleaseEvent</a>(), <a href="qwidget.html#moveEvent">moveEvent</a>(), <a href="qwidget.html#paintEvent">paintEvent</a>(), <a href="qwidget.html#resizeEvent">resizeEvent</a>(), <a href="../qtcore/qobject.html#event">QObject::event</a>(), and <a href="../qtcore/qobject.html#timerEvent">QObject::timerEvent</a>().</p>
<!-- @@@event -->
<!-- $$$find[overload1]$$$findWId -->
<h3 class="fn" id="find"><a name="find"></a><code>[static] </code><span class="type"><a href="qwidget.html#QWidget">QWidget</a></span> *QWidget::<span class="name">find</span>(<span class="type">WId</span> <i>id</i>)</h3>
<p>Returns a pointer to the widget with window identifer/handle <i>id</i>.</p>
<p>The window identifier type depends on the underlying window system, see <code>qwindowdefs.h</code> for the actual definition. If there is no widget with this identifier, 0 is returned.</p>
<!-- @@@find -->
<!-- $$$focusInEvent[overload1]$$$focusInEventQFocusEvent* -->
<h3 class="fn" id="focusInEvent"><a name="focusInEvent"></a><code>[virtual protected] </code><span class="type">void</span> QWidget::<span class="name">focusInEvent</span>(<span class="type"><a href="../qtgui/qfocusevent.html">QFocusEvent</a></span> *<i>event</i>)</h3>
<p>This event handler can be reimplemented in a subclass to receive keyboard focus events (focus received) for the widget. The event is passed in the <i>event</i> parameter</p>
<p>A widget normally must <a href="qwidget.html#focusPolicy-prop">setFocusPolicy</a>() to something other than <a href="../qtcore/qt.html#FocusPolicy-enum">Qt::NoFocus</a> in order to receive focus events. (Note that the application programmer can call <a href="qwidget.html#setFocus-1">setFocus</a>() on any widget, even those that do not normally accept focus.)</p>
<p>The default implementation updates the widget (except for windows that do not specify a <a href="qwidget.html#focusPolicy-prop">focusPolicy</a>()).</p>
<p><b>请参考 </b><a href="qwidget.html#focusOutEvent">focusOutEvent</a>(), <a href="qwidget.html#focusPolicy-prop">setFocusPolicy</a>(), <a href="qwidget.html#keyPressEvent">keyPressEvent</a>(), <a href="qwidget.html#keyReleaseEvent">keyReleaseEvent</a>(), <a href="qwidget.html#event">event</a>(), and <a href="../qtgui/qfocusevent.html">QFocusEvent</a>.</p>
<!-- @@@focusInEvent -->
<!-- $$$focusNextChild[overload1]$$$focusNextChild -->
<h3 class="fn" id="focusNextChild"><a name="focusNextChild"></a><code>[protected] </code><span class="type">bool</span> QWidget::<span class="name">focusNextChild</span>()</h3>
<p>Finds a new widget to give the keyboard focus to, as appropriate for <b>Tab</b>, and returns <code>true</code> if it can find a new widget, or false if it can't.</p>
<p><b>请参考 </b><a href="qwidget.html#focusPreviousChild">focusPreviousChild</a>().</p>
<!-- @@@focusNextChild -->
<!-- $$$focusNextPrevChild[overload1]$$$focusNextPrevChildbool -->
<h3 class="fn" id="focusNextPrevChild"><a name="focusNextPrevChild"></a><code>[virtual protected] </code><span class="type">bool</span> QWidget::<span class="name">focusNextPrevChild</span>(<span class="type">bool</span> <i>next</i>)</h3>
<p>Finds a new widget to give the keyboard focus to, as appropriate for Tab and Shift+Tab, and returns <code>true</code> if it can find a new widget, or false if it can't.</p>
<p>If <i>next</i> is true, this function searches forward, if <i>next</i> is false, it searches backward.</p>
<p>Sometimes, you will want to reimplement this function. For example, a web browser might reimplement it to move its &quot;current active link&quot; forward or backward, and call focusNextPrevChild() only when it reaches the last or first link on the &quot;page&quot;.</p>
<p>Child widgets call focusNextPrevChild() on their parent widgets, but only the window that contains the child widgets decides where to redirect focus. By reimplementing this function for an object, you thus gain control of focus traversal for all child widgets.</p>
<p><b>请参考 </b><a href="qwidget.html#focusNextChild">focusNextChild</a>() and <a href="qwidget.html#focusPreviousChild">focusPreviousChild</a>().</p>
<!-- @@@focusNextPrevChild -->
<!-- $$$focusOutEvent[overload1]$$$focusOutEventQFocusEvent* -->
<h3 class="fn" id="focusOutEvent"><a name="focusOutEvent"></a><code>[virtual protected] </code><span class="type">void</span> QWidget::<span class="name">focusOutEvent</span>(<span class="type"><a href="../qtgui/qfocusevent.html">QFocusEvent</a></span> *<i>event</i>)</h3>
<p>This event handler can be reimplemented in a subclass to receive keyboard focus events (focus lost) for the widget. The events is passed in the <i>event</i> parameter.</p>
<p>A widget normally must <a href="qwidget.html#focusPolicy-prop">setFocusPolicy</a>() to something other than <a href="../qtcore/qt.html#FocusPolicy-enum">Qt::NoFocus</a> in order to receive focus events. (Note that the application programmer can call <a href="qwidget.html#setFocus-1">setFocus</a>() on any widget, even those that do not normally accept focus.)</p>
<p>The default implementation updates the widget (except for windows that do not specify a <a href="qwidget.html#focusPolicy-prop">focusPolicy</a>()).</p>
<p><b>请参考 </b><a href="qwidget.html#focusInEvent">focusInEvent</a>(), <a href="qwidget.html#focusPolicy-prop">setFocusPolicy</a>(), <a href="qwidget.html#keyPressEvent">keyPressEvent</a>(), <a href="qwidget.html#keyReleaseEvent">keyReleaseEvent</a>(), <a href="qwidget.html#event">event</a>(), and <a href="../qtgui/qfocusevent.html">QFocusEvent</a>.</p>
<!-- @@@focusOutEvent -->
<!-- $$$focusPreviousChild[overload1]$$$focusPreviousChild -->
<h3 class="fn" id="focusPreviousChild"><a name="focusPreviousChild"></a><code>[protected] </code><span class="type">bool</span> QWidget::<span class="name">focusPreviousChild</span>()</h3>
<p>Finds a new widget to give the keyboard focus to, as appropriate for <b>Shift+Tab</b>, and returns <code>true</code> if it can find a new widget, or false if it can't.</p>
<p><b>请参考 </b><a href="qwidget.html#focusNextChild">focusNextChild</a>().</p>
<!-- @@@focusPreviousChild -->
<!-- $$$focusProxy[overload1]$$$focusProxy -->
<h3 class="fn" id="focusProxy"><a name="focusProxy"></a><span class="type"><a href="qwidget.html#QWidget">QWidget</a></span> *QWidget::<span class="name">focusProxy</span>() const</h3>
<p>Returns the focus proxy, or 0 if there is no focus proxy.</p>
<p><b>请参考 </b><a href="qwidget.html#setFocusProxy">setFocusProxy</a>().</p>
<!-- @@@focusProxy -->
<!-- $$$focusWidget[overload1]$$$focusWidget -->
<h3 class="fn" id="focusWidget"><a name="focusWidget"></a><span class="type"><a href="qwidget.html#QWidget">QWidget</a></span> *QWidget::<span class="name">focusWidget</span>() const</h3>
<p>Returns the last child of this widget that <a href="qwidget.html#setFocus">setFocus</a> had been called on. For top level widgets this is the widget that will get focus in case this window gets activated</p>
<p>This is not the same as <a href="qapplication.html#focusWidget">QApplication::focusWidget</a>(), which returns the focus widget in the currently active window.</p>
<!-- @@@focusWidget -->
<!-- $$$fontInfo[overload1]$$$fontInfo -->
<h3 class="fn" id="fontInfo"><a name="fontInfo"></a><span class="type"><a href="../qtgui/qfontinfo.html">QFontInfo</a></span> QWidget::<span class="name">fontInfo</span>() const</h3>
<p>Returns the font info for the widget's current font. Equivalent to <code>QFontInfo(widget-&gt;font())</code>.</p>
<p><b>请参考 </b><a href="qwidget.html#font-prop">font</a>(), <a href="qwidget.html#fontMetrics">fontMetrics</a>(), and <a href="qwidget.html#font-prop">setFont</a>().</p>
<!-- @@@fontInfo -->
<!-- $$$fontMetrics[overload1]$$$fontMetrics -->
<h3 class="fn" id="fontMetrics"><a name="fontMetrics"></a><span class="type"><a href="../qtgui/qfontmetrics.html">QFontMetrics</a></span> QWidget::<span class="name">fontMetrics</span>() const</h3>
<p>Returns the font metrics for the widget's current font. Equivalent to <code>QFontMetrics(widget-&gt;font())</code>.</p>
<p><b>请参考 </b><a href="qwidget.html#font-prop">font</a>(), <a href="qwidget.html#fontInfo">fontInfo</a>(), and <a href="qwidget.html#font-prop">setFont</a>().</p>
<!-- @@@fontMetrics -->
<!-- $$$foregroundRole[overload1]$$$foregroundRole -->
<h3 class="fn" id="foregroundRole"><a name="foregroundRole"></a><span class="type"><a href="../qtgui/qpalette.html#ColorRole-enum">QPalette::ColorRole</a></span> QWidget::<span class="name">foregroundRole</span>() const</h3>
<p>Returns the foreground role.</p>
<p>The foreground role defines the color from the widget's <a href="qwidget.html#palette-prop">palette</a> that is used to draw the foreground.</p>
<p>If no explicit foreground role is set, the function returns a role that contrasts with the background role.</p>
<p><b>请参考 </b><a href="qwidget.html#setForegroundRole">setForegroundRole</a>() and <a href="qwidget.html#backgroundRole">backgroundRole</a>().</p>
<!-- @@@foregroundRole -->
<!-- $$$getContentsMargins[overload1]$$$getContentsMarginsint*int*int*int* -->
<h3 class="fn" id="getContentsMargins"><a name="getContentsMargins"></a><span class="type">void</span> QWidget::<span class="name">getContentsMargins</span>(<span class="type">int</span> *<i>left</i>, <span class="type">int</span> *<i>top</i>, <span class="type">int</span> *<i>right</i>, <span class="type">int</span> *<i>bottom</i>) const</h3>
<p>Returns the widget's contents margins for <i>left</i>, <i>top</i>, <i>right</i>, and <i>bottom</i>.</p>
<p><b>请参考 </b><a href="qwidget.html#setContentsMargins">setContentsMargins</a>() and <a href="qwidget.html#contentsRect">contentsRect</a>().</p>
<!-- @@@getContentsMargins -->
<!-- $$$grab[overload1]$$$grabconstQRect& -->
<h3 class="fn" id="grab"><a name="grab"></a><span class="type"><a href="../qtgui/qpixmap.html">QPixmap</a></span> QWidget::<span class="name">grab</span>(const <span class="type"><a href="../qtcore/qrect.html">QRect</a></span> &amp;<i>rectangle</i> = QRect(QPoint(0, 0), QSize(-1, -1)))</h3>
<p>Renders the widget into a pixmap restricted by the given <i>rectangle</i>. If the widget has any children, then they are also painted in the appropriate positions.</p>
<p>If a rectangle with an invalid size is specified (the default), the entire widget is painted.</p>
<p>This function was introduced in  Qt 5.0.</p>
<p><b>Note: </b>This function can be invoked via the meta-object system and from QML. See <a href="../qtcore/qobject.html#Q_INVOKABLE">Q_INVOKABLE</a>.</p>
<p><b>请参考 </b><a href="qwidget.html#render">render</a>() and <a href="../qtgui/qpixmap.html">QPixmap</a>.</p>
<!-- @@@grab -->
<!-- $$$grabGesture[overload1]$$$grabGestureQt::GestureTypeQt::GestureFlags -->
<h3 class="fn" id="grabGesture"><a name="grabGesture"></a><span class="type">void</span> QWidget::<span class="name">grabGesture</span>(<span class="type"><a href="../qtcore/qt.html#GestureType-enum">Qt::GestureType</a></span> <i>gesture</i>, <span class="type"><a href="../qtcore/qt.html#GestureFlag-enum">Qt::GestureFlags</a></span> <i>flags</i> = ...)</h3>
<p>Subscribes the widget to a given <i>gesture</i> with specific <i>flags</i>.</p>
<p>This function was introduced in  Qt 4.6.</p>
<p><b>请参考 </b><a href="qwidget.html#ungrabGesture">ungrabGesture</a>() and <a href="qgestureevent.html">QGestureEvent</a>.</p>
<!-- @@@grabGesture -->
<!-- $$$grabKeyboard[overload1]$$$grabKeyboard -->
<h3 class="fn" id="grabKeyboard"><a name="grabKeyboard"></a><span class="type">void</span> QWidget::<span class="name">grabKeyboard</span>()</h3>
<p>Grabs the keyboard input.</p>
<p>This widget receives all keyboard events until <a href="qwidget.html#releaseKeyboard">releaseKeyboard</a>() is called; other widgets get no keyboard events at all. Mouse events are not affected. Use <a href="qwidget.html#grabMouse">grabMouse</a>() if you want to grab that.</p>
<p>The focus widget is not affected, except that it doesn't receive any keyboard events. <a href="qwidget.html#setFocus-1">setFocus</a>() moves the focus as usual, but the new focus widget receives keyboard events only after <a href="qwidget.html#releaseKeyboard">releaseKeyboard</a>() is called.</p>
<p>If a different widget is currently grabbing keyboard input, that widget's grab is released first.</p>
<p><b>请参考 </b><a href="qwidget.html#releaseKeyboard">releaseKeyboard</a>(), <a href="qwidget.html#grabMouse">grabMouse</a>(), <a href="qwidget.html#releaseMouse">releaseMouse</a>(), and <a href="qwidget.html#focusWidget">focusWidget</a>().</p>
<!-- @@@grabKeyboard -->
<!-- $$$grabMouse[overload1]$$$grabMouse -->
<h3 class="fn" id="grabMouse"><a name="grabMouse"></a><span class="type">void</span> QWidget::<span class="name">grabMouse</span>()</h3>
<p>Grabs the mouse input.</p>
<p>This widget receives all mouse events until <a href="qwidget.html#releaseMouse">releaseMouse</a>() is called; other widgets get no mouse events at all. Keyboard events are not affected. Use <a href="qwidget.html#grabKeyboard">grabKeyboard</a>() if you want to grab that.</p>
<p><b>Warning:</b> Bugs in mouse-grabbing applications very often lock the terminal. Use this function with extreme caution, and consider using the <code>-nograb</code> command line option while debugging.</p>
<p>It is almost never necessary to grab the mouse when using Qt, as Qt grabs and releases it sensibly. In particular, Qt grabs the mouse when a mouse button is pressed and keeps it until the last button is released.</p>
<p><b>Note: </b>Only visible widgets can grab mouse input. If <a href="qwidget.html#visible-prop">isVisible</a>() returns <code>false</code> for a widget, that widget cannot call grabMouse().</p><p><b>Note: </b>On Windows, grabMouse() only works when the mouse is inside a window owned by the process. On <a href="../qtdoc/internationalization.html#macos">macOS</a>, grabMouse() only works when the mouse is inside the frame of that widget.</p><p><b>请参考 </b><a href="qwidget.html#releaseMouse">releaseMouse</a>(), <a href="qwidget.html#grabKeyboard">grabKeyboard</a>(), and <a href="qwidget.html#releaseKeyboard">releaseKeyboard</a>().</p>
<!-- @@@grabMouse -->
<!-- $$$grabMouse$$$grabMouseconstQCursor& -->
<h3 class="fn" id="grabMouse-1"><a name="grabMouse-1"></a><span class="type">void</span> QWidget::<span class="name">grabMouse</span>(const <span class="type"><a href="../qtgui/qcursor.html">QCursor</a></span> &amp;<i>cursor</i>)</h3>
<p>This function overloads <a href="qwidget.html#grabMouse">grabMouse</a>().</p>
<p>Grabs the mouse input and changes the cursor shape.</p>
<p>The cursor will assume shape <i>cursor</i> (for as long as the mouse focus is grabbed) and this widget will be the only one to receive mouse events until <a href="qwidget.html#releaseMouse">releaseMouse</a>() is called().</p>
<p><b>Warning:</b> Grabbing the mouse might lock the terminal.</p>
<p><b>Note: </b>See the note in <a href="qwidget.html#grabMouse">QWidget::grabMouse</a>().</p><p><b>请参考 </b><a href="qwidget.html#releaseMouse">releaseMouse</a>(), <a href="qwidget.html#grabKeyboard">grabKeyboard</a>(), <a href="qwidget.html#releaseKeyboard">releaseKeyboard</a>(), and <a href="qwidget.html#cursor-prop">setCursor</a>().</p>
<!-- @@@grabMouse -->
<!-- $$$grabShortcut[overload1]$$$grabShortcutconstQKeySequence&Qt::ShortcutContext -->
<h3 class="fn" id="grabShortcut"><a name="grabShortcut"></a><span class="type">int</span> QWidget::<span class="name">grabShortcut</span>(const <span class="type"><a href="../qtgui/qkeysequence.html">QKeySequence</a></span> &amp;<i>key</i>, <span class="type"><a href="../qtcore/qt.html#ShortcutContext-enum">Qt::ShortcutContext</a></span> <i>context</i> = Qt::WindowShortcut)</h3>
<p>Adds a shortcut to Qt's shortcut system that watches for the given <i>key</i> sequence in the given <i>context</i>. If the <i>context</i> is <a href="../qtcore/qt.html#ShortcutContext-enum">Qt::ApplicationShortcut</a>, the shortcut applies to the application as a whole. Otherwise, it is either local to this widget, <a href="../qtcore/qt.html#ShortcutContext-enum">Qt::WidgetShortcut</a>, or to the window itself, <a href="../qtcore/qt.html#ShortcutContext-enum">Qt::WindowShortcut</a>.</p>
<p>If the same <i>key</i> sequence has been grabbed by several widgets, when the <i>key</i> sequence occurs a <a href="../qtcore/qevent.html#Type-enum">QEvent::Shortcut</a> event is sent to all the widgets to which it applies in a non-deterministic order, but with the ``ambiguous'' flag set to true.</p>
<p><b>Warning:</b> You should not normally need to use this function; instead create <a href="qaction.html">QAction</a>s with the shortcut key sequences you require (if you also want equivalent menu options and toolbar buttons), or create <a href="qshortcut.html">QShortcut</a>s if you just need key sequences. Both <a href="qaction.html">QAction</a> and <a href="qshortcut.html">QShortcut</a> handle all the event filtering for you, and provide signals which are triggered when the user triggers the key sequence, so are much easier to use than this low-level function.</p>
<p><b>请参考 </b><a href="qwidget.html#releaseShortcut">releaseShortcut</a>() and <a href="qwidget.html#setShortcutEnabled">setShortcutEnabled</a>().</p>
<!-- @@@grabShortcut -->
<!-- $$$graphicsEffect[overload1]$$$graphicsEffect -->
<h3 class="fn" id="graphicsEffect"><a name="graphicsEffect"></a><span class="type"><a href="qgraphicseffect.html">QGraphicsEffect</a></span> *QWidget::<span class="name">graphicsEffect</span>() const</h3>
<p>The graphicsEffect function returns a pointer to the widget's graphics effect.</p>
<p>If the widget has no graphics effect, 0 is returned.</p>
<p>This function was introduced in  Qt 4.6.</p>
<p><b>请参考 </b><a href="qwidget.html#setGraphicsEffect">setGraphicsEffect</a>().</p>
<!-- @@@graphicsEffect -->
<!-- $$$graphicsProxyWidget[overload1]$$$graphicsProxyWidget -->
<h3 class="fn" id="graphicsProxyWidget"><a name="graphicsProxyWidget"></a><span class="type"><a href="qgraphicsproxywidget.html">QGraphicsProxyWidget</a></span> *QWidget::<span class="name">graphicsProxyWidget</span>() const</h3>
<p>Returns the proxy widget for the corresponding embedded widget in a graphics view; otherwise returns <code>nullptr</code>.</p>
<p>This function was introduced in  Qt 4.5.</p>
<p><b>请参考 </b><a href="qgraphicsproxywidget.html#createProxyForChildWidget">QGraphicsProxyWidget::createProxyForChildWidget</a>() and <a href="qgraphicsscene.html#addWidget">QGraphicsScene::addWidget</a>().</p>
<!-- @@@graphicsProxyWidget -->
<!-- $$$hasEditFocus[overload1]$$$hasEditFocus -->
<h3 class="fn" id="hasEditFocus"><a name="hasEditFocus"></a><span class="type">bool</span> QWidget::<span class="name">hasEditFocus</span>() const</h3>
<p>Returns <code>true</code> if this widget currently has edit focus; otherwise false.</p>
<p>This feature is only available in Qt for Embedded Linux.</p>
<p><b>请参考 </b><a href="qwidget.html#setEditFocus">setEditFocus</a>() and <a href="qapplication-obsolete.html#keypadNavigationEnabled">QApplication::keypadNavigationEnabled</a>().</p>
<!-- @@@hasEditFocus -->
<!-- $$$hasHeightForWidth[overload1]$$$hasHeightForWidth -->
<h3 class="fn" id="hasHeightForWidth"><a name="hasHeightForWidth"></a><code>[virtual] </code><span class="type">bool</span> QWidget::<span class="name">hasHeightForWidth</span>() const</h3>
<p>Returns <code>true</code> if the widget's preferred height depends on its width; otherwise returns <code>false</code>.</p>
<p>This function was introduced in  Qt 5.0.</p>
<!-- @@@hasHeightForWidth -->
<!-- $$$heightForWidth[overload1]$$$heightForWidthint -->
<h3 class="fn" id="heightForWidth"><a name="heightForWidth"></a><code>[virtual] </code><span class="type">int</span> QWidget::<span class="name">heightForWidth</span>(<span class="type">int</span> <i>w</i>) const</h3>
<p>Returns the preferred height for this widget, given the width <i>w</i>.</p>
<p>If this widget has a layout, the default implementation returns the layout's preferred height. if there is no layout, the default implementation returns -1 indicating that the preferred height does not depend on the width.</p>
<!-- @@@heightForWidth -->
<!-- $$$hide[overload1]$$$hide -->
<h3 class="fn" id="hide"><a name="hide"></a><code>[slot] </code><span class="type">void</span> QWidget::<span class="name">hide</span>()</h3>
<p>Hides the widget. This function is equivalent to <a href="qwidget.html#visible-prop">setVisible</a>(false).</p>
<p><b>Note: </b>If you are working with <a href="qdialog.html">QDialog</a> or its subclasses and you invoke the <a href="qwidget.html#show">show</a>() function after this function, the dialog will be displayed in its original position.</p><p><b>请参考 </b><a href="qwidget.html#hideEvent">hideEvent</a>(), <a href="qwidget.html#isHidden">isHidden</a>(), <a href="qwidget.html#show">show</a>(), <a href="qwidget.html#visible-prop">setVisible</a>(), <a href="qwidget.html#visible-prop">isVisible</a>(), and <a href="qwidget.html#close">close</a>().</p>
<!-- @@@hide -->
<!-- $$$hideEvent[overload1]$$$hideEventQHideEvent* -->
<h3 class="fn" id="hideEvent"><a name="hideEvent"></a><code>[virtual protected] </code><span class="type">void</span> QWidget::<span class="name">hideEvent</span>(<span class="type"><a href="../qtgui/qhideevent.html">QHideEvent</a></span> *<i>event</i>)</h3>
<p>This event handler can be reimplemented in a subclass to receive widget hide events. The event is passed in the <i>event</i> parameter.</p>
<p>Hide events are sent to widgets immediately after they have been hidden.</p>
<p>Note: A widget receives spontaneous show and hide events when its mapping status is changed by the window system, e.g&#x2e; a spontaneous hide event when the user minimizes the window, and a spontaneous show event when the window is restored again. After receiving a spontaneous hide event, a widget is still considered visible in the sense of <a href="qwidget.html#visible-prop">isVisible</a>().</p>
<p><b>请参考 </b><a href="qwidget.html#visible-prop">visible</a>, <a href="qwidget.html#event">event</a>(), and <a href="../qtgui/qhideevent.html">QHideEvent</a>.</p>
<!-- @@@hideEvent -->
<!-- $$$initPainter[overload1]$$$initPainterQPainter* -->
<h3 class="fn" id="initPainter"><a name="initPainter"></a><code>[override virtual protected] </code><span class="type">void</span> QWidget::<span class="name">initPainter</span>(<span class="type"><a href="../qtgui/qpainter.html">QPainter</a></span> *<i>painter</i>) const</h3>
<p>Initializes the <i>painter</i> pen, background and font to the same as the given widget's. This function is called automatically when the painter is opened on a <a href="qwidget.html">QWidget</a>.</p>
<!-- @@@initPainter -->
<!-- $$$inputMethodEvent[overload1]$$$inputMethodEventQInputMethodEvent* -->
<h3 class="fn" id="inputMethodEvent"><a name="inputMethodEvent"></a><code>[virtual protected] </code><span class="type">void</span> QWidget::<span class="name">inputMethodEvent</span>(<span class="type"><a href="../qtgui/qinputmethodevent.html">QInputMethodEvent</a></span> *<i>event</i>)</h3>
<p>This event handler, for event <i>event</i>, can be reimplemented in a subclass to receive Input Method composition events. This handler is called when the state of the input method changes.</p>
<p>Note that when creating custom text editing widgets, the <a href="../qtcore/qt.html#WidgetAttribute-enum">Qt::WA_InputMethodEnabled</a> window attribute must be set explicitly (using the <a href="qwidget.html#setAttribute">setAttribute</a>() function) in order to receive input method events.</p>
<p>The default implementation calls event-&gt;ignore(), which rejects the Input Method event. See the <a href="../qtgui/qinputmethodevent.html">QInputMethodEvent</a> documentation for more details.</p>
<p><b>请参考 </b><a href="qwidget.html#event">event</a>() and <a href="../qtgui/qinputmethodevent.html">QInputMethodEvent</a>.</p>
<!-- @@@inputMethodEvent -->
<!-- $$$inputMethodQuery[overload1]$$$inputMethodQueryQt::InputMethodQuery -->
<h3 class="fn" id="inputMethodQuery"><a name="inputMethodQuery"></a><code>[virtual] </code><span class="type"><a href="../qtcore/qvariant.html">QVariant</a></span> QWidget::<span class="name">inputMethodQuery</span>(<span class="type"><a href="../qtcore/qt.html#InputMethodQuery-enum">Qt::InputMethodQuery</a></span> <i>query</i>) const</h3>
<p>This method is only relevant for input widgets. It is used by the input method to query a set of properties of the widget to be able to support complex input method operations as support for surrounding text and reconversions.</p>
<p><i>query</i> specifies which property is queried.</p>
<p><b>请参考 </b><a href="qwidget.html#inputMethodEvent">inputMethodEvent</a>(), <a href="../qtgui/qinputmethodevent.html">QInputMethodEvent</a>, <a href="../qtgui/qinputmethodqueryevent.html">QInputMethodQueryEvent</a>, and <a href="qwidget.html#inputMethodHints-prop">inputMethodHints</a>.</p>
<!-- @@@inputMethodQuery -->
<!-- $$$insertAction[overload1]$$$insertActionQAction*QAction* -->
<h3 class="fn" id="insertAction"><a name="insertAction"></a><span class="type">void</span> QWidget::<span class="name">insertAction</span>(<span class="type"><a href="qaction.html">QAction</a></span> *<i>before</i>, <span class="type"><a href="qaction.html">QAction</a></span> *<i>action</i>)</h3>
<p>Inserts the action <i>action</i> to this widget's list of actions, before the action <i>before</i>. It appends the action if <i>before</i> is 0 or <i>before</i> is not a valid action for this widget.</p>
<p>A <a href="qwidget.html">QWidget</a> should only have one of each action.</p>
<p><b>请参考 </b><a href="qwidget.html#removeAction">removeAction</a>(), <a href="qwidget.html#addAction">addAction</a>(), <a href="qmenu.html">QMenu</a>, <a href="qwidget.html#contextMenuPolicy-prop">contextMenuPolicy</a>, and <a href="qwidget.html#actions">actions</a>().</p>
<!-- @@@insertAction -->
<!-- $$$insertActions[overload1]$$$insertActionsQAction*QList<QAction*> -->
<h3 class="fn" id="insertActions"><a name="insertActions"></a><span class="type">void</span> QWidget::<span class="name">insertActions</span>(<span class="type"><a href="qaction.html">QAction</a></span> *<i>before</i>, <span class="type"><a href="../qtcore/qlist.html">QList</a></span>&lt;<span class="type"><a href="qaction.html">QAction</a></span> *&gt; <i>actions</i>)</h3>
<p>Inserts the actions <i>actions</i> to this widget's list of actions, before the action <i>before</i>. It appends the action if <i>before</i> is 0 or <i>before</i> is not a valid action for this widget.</p>
<p>A <a href="qwidget.html">QWidget</a> can have at most one of each action.</p>
<p><b>请参考 </b><a href="qwidget.html#removeAction">removeAction</a>(), <a href="qmenu.html">QMenu</a>, <a href="qwidget.html#insertAction">insertAction</a>(), and <a href="qwidget.html#contextMenuPolicy-prop">contextMenuPolicy</a>.</p>
<!-- @@@insertActions -->
<!-- $$$isAncestorOf[overload1]$$$isAncestorOfconstQWidget* -->
<h3 class="fn" id="isAncestorOf"><a name="isAncestorOf"></a><span class="type">bool</span> QWidget::<span class="name">isAncestorOf</span>(const <span class="type"><a href="qwidget.html#QWidget">QWidget</a></span> *<i>child</i>) const</h3>
<p>Returns <code>true</code> if this widget is a parent, (or grandparent and so on to any level), of the given <i>child</i>, and both widgets are within the same window; otherwise returns <code>false</code>.</p>
<!-- @@@isAncestorOf -->
<!-- $$$isEnabledTo[overload1]$$$isEnabledToconstQWidget* -->
<h3 class="fn" id="isEnabledTo"><a name="isEnabledTo"></a><span class="type">bool</span> QWidget::<span class="name">isEnabledTo</span>(const <span class="type"><a href="qwidget.html#QWidget">QWidget</a></span> *<i>ancestor</i>) const</h3>
<p>Returns <code>true</code> if this widget would become enabled if <i>ancestor</i> is enabled; otherwise returns <code>false</code>.</p>
<p>This is the case if neither the widget itself nor every parent up to but excluding <i>ancestor</i> has been explicitly disabled.</p>
<p>isEnabledTo(0) returns false if this widget or any if its ancestors was explicitly disabled.</p>
<p>The word ancestor here means a parent widget within the same window.</p>
<p>Therefore isEnabledTo(0) stops at this widget's window, unlike <a href="qwidget.html#enabled-prop">isEnabled</a>() which also takes parent windows into considerations.</p>
<p><b>请参考 </b><a href="qwidget.html#enabled-prop">setEnabled</a>() and <a href="qwidget.html#enabled-prop">enabled</a>.</p>
<!-- @@@isEnabledTo -->
<!-- $$$isHidden[overload1]$$$isHidden -->
<h3 class="fn" id="isHidden"><a name="isHidden"></a><span class="type">bool</span> QWidget::<span class="name">isHidden</span>() const</h3>
<p>Returns <code>true</code> if the widget is hidden, otherwise returns <code>false</code>.</p>
<p>A hidden widget will only become visible when <a href="qwidget.html#show">show</a>() is called on it. It will not be automatically shown when the parent is shown.</p>
<p>To check visibility, use !<a href="qwidget.html#visible-prop">isVisible</a>() instead (notice the exclamation mark).</p>
<p>isHidden() implies !<a href="qwidget.html#visible-prop">isVisible</a>(), but a widget can be not visible and not hidden at the same time. This is the case for widgets that are children of widgets that are not visible.</p>
<p>Widgets are hidden if:</p>
<ul>
<li>they were created as independent windows,</li>
<li>they were created as children of visible widgets,</li>
<li><a href="qwidget.html#hide">hide</a>() or <a href="qwidget.html#visible-prop">setVisible</a>(false) was called.</li>
</ul>
<!-- @@@isHidden -->
<!-- $$$isVisibleTo[overload1]$$$isVisibleToconstQWidget* -->
<h3 class="fn" id="isVisibleTo"><a name="isVisibleTo"></a><span class="type">bool</span> QWidget::<span class="name">isVisibleTo</span>(const <span class="type"><a href="qwidget.html#QWidget">QWidget</a></span> *<i>ancestor</i>) const</h3>
<p>Returns <code>true</code> if this widget would become visible if <i>ancestor</i> is shown; otherwise returns <code>false</code>.</p>
<p>The true case occurs if neither the widget itself nor any parent up to but excluding <i>ancestor</i> has been explicitly hidden.</p>
<p>This function will still return true if the widget is obscured by other windows on the screen, but could be physically visible if it or they were to be moved.</p>
<p>isVisibleTo(0) is identical to <a href="qwidget.html#visible-prop">isVisible</a>().</p>
<p><b>请参考 </b><a href="qwidget.html#show">show</a>(), <a href="qwidget.html#hide">hide</a>(), and <a href="qwidget.html#visible-prop">isVisible</a>().</p>
<!-- @@@isVisibleTo -->
<!-- $$$isWindow[overload1]$$$isWindow -->
<h3 class="fn" id="isWindow"><a name="isWindow"></a><span class="type">bool</span> QWidget::<span class="name">isWindow</span>() const</h3>
<p>Returns <code>true</code> if the widget is an independent window, otherwise returns <code>false</code>.</p>
<p>A window is a widget that isn't visually the child of any other widget and that usually has a frame and a <a href="qwidget.html#windowTitle-prop">window title</a>.</p>
<p>A window can have a <a href="qwidget.html#parentWidget">parent widget</a>. It will then be grouped with its parent and deleted when the parent is deleted, minimized when the parent is minimized etc. If supported by the window manager, it will also have a common taskbar entry with its parent.</p>
<p><a href="qdialog.html">QDialog</a> and <a href="qmainwindow.html">QMainWindow</a> widgets are by default windows, even if a parent widget is specified in the constructor. This behavior is specified by the <a href="../qtcore/qt.html#WindowType-enum">Qt::Window</a> flag.</p>
<p><b>请参考 </b><a href="qwidget.html#window">window</a>(), <a href="qwidget.html#modal-prop">isModal</a>(), and <a href="qwidget.html#parentWidget">parentWidget</a>().</p>
<!-- @@@isWindow -->
<!-- $$$keyPressEvent[overload1]$$$keyPressEventQKeyEvent* -->
<h3 class="fn" id="keyPressEvent"><a name="keyPressEvent"></a><code>[virtual protected] </code><span class="type">void</span> QWidget::<span class="name">keyPressEvent</span>(<span class="type"><a href="../qtgui/qkeyevent.html">QKeyEvent</a></span> *<i>event</i>)</h3>
<p>This event handler, for event <i>event</i>, can be reimplemented in a subclass to receive key press events for the widget.</p>
<p>A widget must call <a href="qwidget.html#focusPolicy-prop">setFocusPolicy</a>() to accept focus initially and have focus in order to receive a key press event.</p>
<p>If you reimplement this handler, it is very important that you call the base class implementation if you do not act upon the key.</p>
<p>The default implementation closes popup widgets if the user presses the key sequence for <a href="../qtgui/qkeysequence.html#StandardKey-enum">QKeySequence::Cancel</a> (typically the Escape key). Otherwise the event is ignored, so that the widget's parent can interpret it.</p>
<p>Note that <a href="../qtgui/qkeyevent.html">QKeyEvent</a> starts with isAccepted() == true, so you do not need to call <a href="../qtcore/qevent.html#accept">QKeyEvent::accept</a>() - just do not call the base class implementation if you act upon the key.</p>
<p><b>请参考 </b><a href="qwidget.html#keyReleaseEvent">keyReleaseEvent</a>(), <a href="qwidget.html#focusPolicy-prop">setFocusPolicy</a>(), <a href="qwidget.html#focusInEvent">focusInEvent</a>(), <a href="qwidget.html#focusOutEvent">focusOutEvent</a>(), <a href="qwidget.html#event">event</a>(), <a href="../qtgui/qkeyevent.html">QKeyEvent</a>, and <a href="qtwidgets-widgets-tetrix-example.html">Tetrix Example</a>.</p>
<!-- @@@keyPressEvent -->
<!-- $$$keyReleaseEvent[overload1]$$$keyReleaseEventQKeyEvent* -->
<h3 class="fn" id="keyReleaseEvent"><a name="keyReleaseEvent"></a><code>[virtual protected] </code><span class="type">void</span> QWidget::<span class="name">keyReleaseEvent</span>(<span class="type"><a href="../qtgui/qkeyevent.html">QKeyEvent</a></span> *<i>event</i>)</h3>
<p>This event handler, for event <i>event</i>, can be reimplemented in a subclass to receive key release events for the widget.</p>
<p>A widget must <a href="qwidget.html#focusPolicy-prop">accept focus</a> initially and <a href="qwidget.html#focus-prop">have focus</a> in order to receive a key release event.</p>
<p>If you reimplement this handler, it is very important that you call the base class implementation if you do not act upon the key.</p>
<p>The default implementation ignores the event, so that the widget's parent can interpret it.</p>
<p>Note that <a href="../qtgui/qkeyevent.html">QKeyEvent</a> starts with isAccepted() == true, so you do not need to call <a href="../qtcore/qevent.html#accept">QKeyEvent::accept</a>() - just do not call the base class implementation if you act upon the key.</p>
<p><b>请参考 </b><a href="qwidget.html#keyPressEvent">keyPressEvent</a>(), <a href="../qtcore/qevent.html#ignore">QEvent::ignore</a>(), <a href="qwidget.html#focusPolicy-prop">setFocusPolicy</a>(), <a href="qwidget.html#focusInEvent">focusInEvent</a>(), <a href="qwidget.html#focusOutEvent">focusOutEvent</a>(), <a href="qwidget.html#event">event</a>(), and <a href="../qtgui/qkeyevent.html">QKeyEvent</a>.</p>
<!-- @@@keyReleaseEvent -->
<!-- $$$keyboardGrabber[overload1]$$$keyboardGrabber -->
<h3 class="fn" id="keyboardGrabber"><a name="keyboardGrabber"></a><code>[static] </code><span class="type"><a href="qwidget.html#QWidget">QWidget</a></span> *QWidget::<span class="name">keyboardGrabber</span>()</h3>
<p>Returns the widget that is currently grabbing the keyboard input.</p>
<p>If no widget in this application is currently grabbing the keyboard, 0 is returned.</p>
<p><b>请参考 </b><a href="qwidget.html#grabMouse">grabMouse</a>() and <a href="qwidget.html#mouseGrabber">mouseGrabber</a>().</p>
<!-- @@@keyboardGrabber -->
<!-- $$$layout[overload1]$$$layout -->
<h3 class="fn" id="layout"><a name="layout"></a><span class="type"><a href="qlayout.html">QLayout</a></span> *QWidget::<span class="name">layout</span>() const</h3>
<p>Returns the layout manager that is installed on this widget, or 0 if no layout manager is installed.</p>
<p>The layout manager sets the geometry of the widget's children that have been added to the layout.</p>
<p><b>请参考 </b><a href="qwidget.html#setLayout">setLayout</a>(), <a href="qwidget.html#sizePolicy-prop">sizePolicy</a>(), and <a href="layout.html">Layout Management</a>.</p>
<!-- @@@layout -->
<!-- $$$leaveEvent[overload1]$$$leaveEventQEvent* -->
<h3 class="fn" id="leaveEvent"><a name="leaveEvent"></a><code>[virtual protected] </code><span class="type">void</span> QWidget::<span class="name">leaveEvent</span>(<span class="type"><a href="../qtcore/qevent.html">QEvent</a></span> *<i>event</i>)</h3>
<p>This event handler can be reimplemented in a subclass to receive widget leave events which are passed in the <i>event</i> parameter.</p>
<p>A leave event is sent to the widget when the mouse cursor leaves the widget.</p>
<p><b>请参考 </b><a href="qwidget.html#enterEvent">enterEvent</a>(), <a href="qwidget.html#mouseMoveEvent">mouseMoveEvent</a>(), and <a href="qwidget.html#event">event</a>().</p>
<!-- @@@leaveEvent -->
<!-- $$$lower[overload1]$$$lower -->
<h3 class="fn" id="lower"><a name="lower"></a><code>[slot] </code><span class="type">void</span> QWidget::<span class="name">lower</span>()</h3>
<p>Lowers the widget to the bottom of the parent widget's stack.</p>
<p>After this call the widget will be visually behind (and therefore obscured by) any overlapping sibling widgets.</p>
<p><b>请参考 </b><a href="qwidget.html#raise">raise</a>() and <a href="qwidget.html#stackUnder">stackUnder</a>().</p>
<!-- @@@lower -->
<!-- $$$mapFrom[overload1]$$$mapFromconstQWidget*constQPoint& -->
<h3 class="fn" id="mapFrom"><a name="mapFrom"></a><span class="type"><a href="../qtcore/qpoint.html">QPoint</a></span> QWidget::<span class="name">mapFrom</span>(const <span class="type"><a href="qwidget.html#QWidget">QWidget</a></span> *<i>parent</i>, const <span class="type"><a href="../qtcore/qpoint.html">QPoint</a></span> &amp;<i>pos</i>) const</h3>
<p>Translates the widget coordinate <i>pos</i> from the coordinate system of <i>parent</i> to this widget's coordinate system. The <i>parent</i> must not be 0 and must be a parent of the calling widget.</p>
<p><b>请参考 </b><a href="qwidget.html#mapTo">mapTo</a>(), <a href="qwidget.html#mapFromParent">mapFromParent</a>(), <a href="qwidget.html#mapFromGlobal">mapFromGlobal</a>(), and <a href="qwidget.html#underMouse">underMouse</a>().</p>
<!-- @@@mapFrom -->
<!-- $$$mapFromGlobal[overload1]$$$mapFromGlobalconstQPoint& -->
<h3 class="fn" id="mapFromGlobal"><a name="mapFromGlobal"></a><span class="type"><a href="../qtcore/qpoint.html">QPoint</a></span> QWidget::<span class="name">mapFromGlobal</span>(const <span class="type"><a href="../qtcore/qpoint.html">QPoint</a></span> &amp;<i>pos</i>) const</h3>
<p>Translates the global screen coordinate <i>pos</i> to widget coordinates.</p>
<p><b>请参考 </b><a href="qwidget.html#mapToGlobal">mapToGlobal</a>(), <a href="qwidget.html#mapFrom">mapFrom</a>(), and <a href="qwidget.html#mapFromParent">mapFromParent</a>().</p>
<!-- @@@mapFromGlobal -->
<!-- $$$mapFromParent[overload1]$$$mapFromParentconstQPoint& -->
<h3 class="fn" id="mapFromParent"><a name="mapFromParent"></a><span class="type"><a href="../qtcore/qpoint.html">QPoint</a></span> QWidget::<span class="name">mapFromParent</span>(const <span class="type"><a href="../qtcore/qpoint.html">QPoint</a></span> &amp;<i>pos</i>) const</h3>
<p>Translates the parent widget coordinate <i>pos</i> to widget coordinates.</p>
<p>Same as <a href="qwidget.html#mapFromGlobal">mapFromGlobal</a>() if the widget has no parent.</p>
<p><b>请参考 </b><a href="qwidget.html#mapToParent">mapToParent</a>(), <a href="qwidget.html#mapFrom">mapFrom</a>(), <a href="qwidget.html#mapFromGlobal">mapFromGlobal</a>(), and <a href="qwidget.html#underMouse">underMouse</a>().</p>
<!-- @@@mapFromParent -->
<!-- $$$mapTo[overload1]$$$mapToconstQWidget*constQPoint& -->
<h3 class="fn" id="mapTo"><a name="mapTo"></a><span class="type"><a href="../qtcore/qpoint.html">QPoint</a></span> QWidget::<span class="name">mapTo</span>(const <span class="type"><a href="qwidget.html#QWidget">QWidget</a></span> *<i>parent</i>, const <span class="type"><a href="../qtcore/qpoint.html">QPoint</a></span> &amp;<i>pos</i>) const</h3>
<p>Translates the widget coordinate <i>pos</i> to the coordinate system of <i>parent</i>. The <i>parent</i> must not be 0 and must be a parent of the calling widget.</p>
<p><b>请参考 </b><a href="qwidget.html#mapFrom">mapFrom</a>(), <a href="qwidget.html#mapToParent">mapToParent</a>(), <a href="qwidget.html#mapToGlobal">mapToGlobal</a>(), and <a href="qwidget.html#underMouse">underMouse</a>().</p>
<!-- @@@mapTo -->
<!-- $$$mapToGlobal[overload1]$$$mapToGlobalconstQPoint& -->
<h3 class="fn" id="mapToGlobal"><a name="mapToGlobal"></a><span class="type"><a href="../qtcore/qpoint.html">QPoint</a></span> QWidget::<span class="name">mapToGlobal</span>(const <span class="type"><a href="../qtcore/qpoint.html">QPoint</a></span> &amp;<i>pos</i>) const</h3>
<p>Translates the widget coordinate <i>pos</i> to global screen coordinates. For example, <code>mapToGlobal(QPoint(0,0))</code> would give the global coordinates of the top-left pixel of the widget.</p>
<p><b>请参考 </b><a href="qwidget.html#mapFromGlobal">mapFromGlobal</a>(), <a href="qwidget.html#mapTo">mapTo</a>(), and <a href="qwidget.html#mapToParent">mapToParent</a>().</p>
<!-- @@@mapToGlobal -->
<!-- $$$mapToParent[overload1]$$$mapToParentconstQPoint& -->
<h3 class="fn" id="mapToParent"><a name="mapToParent"></a><span class="type"><a href="../qtcore/qpoint.html">QPoint</a></span> QWidget::<span class="name">mapToParent</span>(const <span class="type"><a href="../qtcore/qpoint.html">QPoint</a></span> &amp;<i>pos</i>) const</h3>
<p>Translates the widget coordinate <i>pos</i> to a coordinate in the parent widget.</p>
<p>Same as <a href="qwidget.html#mapToGlobal">mapToGlobal</a>() if the widget has no parent.</p>
<p><b>请参考 </b><a href="qwidget.html#mapFromParent">mapFromParent</a>(), <a href="qwidget.html#mapTo">mapTo</a>(), <a href="qwidget.html#mapToGlobal">mapToGlobal</a>(), and <a href="qwidget.html#underMouse">underMouse</a>().</p>
<!-- @@@mapToParent -->
<!-- $$$mask[overload1]$$$mask -->
<h3 class="fn" id="mask"><a name="mask"></a><span class="type"><a href="../qtgui/qregion.html">QRegion</a></span> QWidget::<span class="name">mask</span>() const</h3>
<p>Returns the mask currently set on a widget. If no mask is set the return value will be an empty region.</p>
<p><b>请参考 </b><a href="qwidget.html#setMask">setMask</a>(), <a href="qwidget.html#clearMask">clearMask</a>(), <a href="../qtgui/qregion.html#isEmpty">QRegion::isEmpty</a>(), and <a href="qtwidgets-widgets-shapedclock-example.html">Shaped Clock Example</a>.</p>
<!-- @@@mask -->
<!-- $$$metric[overload1]$$$metricQPaintDevice::PaintDeviceMetric -->
<h3 class="fn" id="metric"><a name="metric"></a><code>[override virtual protected] </code><span class="type">int</span> QWidget::<span class="name">metric</span>(<span class="type"><a href="../qtgui/qpaintdevice.html#PaintDeviceMetric-enum">QPaintDevice::PaintDeviceMetric</a></span> <i>m</i>) const</h3>
<p>Reimplemented from <a href="../qtgui/qpaintdevice.html#metric">QPaintDevice::metric</a>().</p>
<p>Internal implementation of the virtual <a href="../qtgui/qpaintdevice.html#metric">QPaintDevice::metric</a>() function.</p>
<p><i>m</i> is the metric to get.</p>
<!-- @@@metric -->
<!-- $$$mouseDoubleClickEvent[overload1]$$$mouseDoubleClickEventQMouseEvent* -->
<h3 class="fn" id="mouseDoubleClickEvent"><a name="mouseDoubleClickEvent"></a><code>[virtual protected] </code><span class="type">void</span> QWidget::<span class="name">mouseDoubleClickEvent</span>(<span class="type"><a href="../qtgui/qmouseevent.html">QMouseEvent</a></span> *<i>event</i>)</h3>
<p>This event handler, for event <i>event</i>, can be reimplemented in a subclass to receive mouse double click events for the widget.</p>
<p>The default implementation calls <a href="qwidget.html#mousePressEvent">mousePressEvent</a>().</p>
<p><b>Note: </b>The widget will also receive mouse press and mouse release events in addition to the double click event. It is up to the developer to ensure that the application interprets these events correctly.</p><p><b>请参考 </b><a href="qwidget.html#mousePressEvent">mousePressEvent</a>(), <a href="qwidget.html#mouseReleaseEvent">mouseReleaseEvent</a>(), <a href="qwidget.html#mouseMoveEvent">mouseMoveEvent</a>(), <a href="qwidget.html#event">event</a>(), and <a href="../qtgui/qmouseevent.html">QMouseEvent</a>.</p>
<!-- @@@mouseDoubleClickEvent -->
<!-- $$$mouseGrabber[overload1]$$$mouseGrabber -->
<h3 class="fn" id="mouseGrabber"><a name="mouseGrabber"></a><code>[static] </code><span class="type"><a href="qwidget.html#QWidget">QWidget</a></span> *QWidget::<span class="name">mouseGrabber</span>()</h3>
<p>Returns the widget that is currently grabbing the mouse input.</p>
<p>If no widget in this application is currently grabbing the mouse, 0 is returned.</p>
<p><b>请参考 </b><a href="qwidget.html#grabMouse">grabMouse</a>() and <a href="qwidget.html#keyboardGrabber">keyboardGrabber</a>().</p>
<!-- @@@mouseGrabber -->
<!-- $$$mouseMoveEvent[overload1]$$$mouseMoveEventQMouseEvent* -->
<h3 class="fn" id="mouseMoveEvent"><a name="mouseMoveEvent"></a><code>[virtual protected] </code><span class="type">void</span> QWidget::<span class="name">mouseMoveEvent</span>(<span class="type"><a href="../qtgui/qmouseevent.html">QMouseEvent</a></span> *<i>event</i>)</h3>
<p>This event handler, for event <i>event</i>, can be reimplemented in a subclass to receive mouse move events for the widget.</p>
<p>If mouse tracking is switched off, mouse move events only occur if a mouse button is pressed while the mouse is being moved. If mouse tracking is switched on, mouse move events occur even if no mouse button is pressed.</p>
<p><a href="../qtgui/qmouseevent.html#pos">QMouseEvent::pos</a>() reports the position of the mouse cursor, relative to this widget. For press and release events, the position is usually the same as the position of the last mouse move event, but it might be different if the user's hand shakes. This is a feature of the underlying window system, not Qt.</p>
<p>If you want to show a tooltip immediately, while the mouse is moving (e.g&#x2e;, to get the mouse coordinates with <a href="../qtgui/qmouseevent.html#pos">QMouseEvent::pos</a>() and show them as a tooltip), you must first enable mouse tracking as described above. Then, to ensure that the tooltip is updated immediately, you must call <a href="qtooltip.html#showText">QToolTip::showText</a>() instead of <a href="qwidget.html#toolTip-prop">setToolTip</a>() in your implementation of mouseMoveEvent().</p>
<p><b>请参考 </b><a href="qwidget.html#mouseTracking-prop">setMouseTracking</a>(), <a href="qwidget.html#mousePressEvent">mousePressEvent</a>(), <a href="qwidget.html#mouseReleaseEvent">mouseReleaseEvent</a>(), <a href="qwidget.html#mouseDoubleClickEvent">mouseDoubleClickEvent</a>(), <a href="qwidget.html#event">event</a>(), <a href="../qtgui/qmouseevent.html">QMouseEvent</a>, and <a href="qtwidgets-widgets-scribble-example.html">Scribble Example</a>.</p>
<!-- @@@mouseMoveEvent -->
<!-- $$$mousePressEvent[overload1]$$$mousePressEventQMouseEvent* -->
<h3 class="fn" id="mousePressEvent"><a name="mousePressEvent"></a><code>[virtual protected] </code><span class="type">void</span> QWidget::<span class="name">mousePressEvent</span>(<span class="type"><a href="../qtgui/qmouseevent.html">QMouseEvent</a></span> *<i>event</i>)</h3>
<p>This event handler, for event <i>event</i>, can be reimplemented in a subclass to receive mouse press events for the widget.</p>
<p>If you create new widgets in the mousePressEvent() the <a href="qwidget.html#mouseReleaseEvent">mouseReleaseEvent</a>() may not end up where you expect, depending on the underlying window system (or X11 window manager), the widgets' location and maybe more.</p>
<p>The default implementation implements the closing of popup widgets when you click outside the window. For other widget types it does nothing.</p>
<p><b>请参考 </b><a href="qwidget.html#mouseReleaseEvent">mouseReleaseEvent</a>(), <a href="qwidget.html#mouseDoubleClickEvent">mouseDoubleClickEvent</a>(), <a href="qwidget.html#mouseMoveEvent">mouseMoveEvent</a>(), <a href="qwidget.html#event">event</a>(), <a href="../qtgui/qmouseevent.html">QMouseEvent</a>, and <a href="qtwidgets-widgets-scribble-example.html">Scribble Example</a>.</p>
<!-- @@@mousePressEvent -->
<!-- $$$mouseReleaseEvent[overload1]$$$mouseReleaseEventQMouseEvent* -->
<h3 class="fn" id="mouseReleaseEvent"><a name="mouseReleaseEvent"></a><code>[virtual protected] </code><span class="type">void</span> QWidget::<span class="name">mouseReleaseEvent</span>(<span class="type"><a href="../qtgui/qmouseevent.html">QMouseEvent</a></span> *<i>event</i>)</h3>
<p>This event handler, for event <i>event</i>, can be reimplemented in a subclass to receive mouse release events for the widget.</p>
<p><b>请参考 </b><a href="qwidget.html#mousePressEvent">mousePressEvent</a>(), <a href="qwidget.html#mouseDoubleClickEvent">mouseDoubleClickEvent</a>(), <a href="qwidget.html#mouseMoveEvent">mouseMoveEvent</a>(), <a href="qwidget.html#event">event</a>(), <a href="../qtgui/qmouseevent.html">QMouseEvent</a>, and <a href="qtwidgets-widgets-scribble-example.html">Scribble Example</a>.</p>
<!-- @@@mouseReleaseEvent -->
<!-- $$$move -->
<h3 class="fn" id="move-1"><a name="move-1"></a><span class="type">void</span> QWidget::<span class="name">move</span>(<span class="type">int</span> <i>x</i>, <span class="type">int</span> <i>y</i>)</h3>
<p>This is an overloaded function.</p>
<p>This corresponds to move(<a href="../qtcore/qpoint.html">QPoint</a>(<i>x</i>, <i>y</i>)).</p>
<p><b>Note:</b> Setter function for property <a href="qwidget.html#pos-prop">pos</a>. </p><!-- @@@move -->
<!-- $$$moveEvent[overload1]$$$moveEventQMoveEvent* -->
<h3 class="fn" id="moveEvent"><a name="moveEvent"></a><code>[virtual protected] </code><span class="type">void</span> QWidget::<span class="name">moveEvent</span>(<span class="type"><a href="../qtgui/qmoveevent.html">QMoveEvent</a></span> *<i>event</i>)</h3>
<p>This event handler can be reimplemented in a subclass to receive widget move events which are passed in the <i>event</i> parameter. When the widget receives this event, it is already at the new position.</p>
<p>The old position is accessible through <a href="../qtgui/qmoveevent.html#oldPos">QMoveEvent::oldPos</a>().</p>
<p><b>请参考 </b><a href="qwidget.html#resizeEvent">resizeEvent</a>(), <a href="qwidget.html#event">event</a>(), <a href="qwidget.html#pos-prop">move</a>(), and <a href="../qtgui/qmoveevent.html">QMoveEvent</a>.</p>
<!-- @@@moveEvent -->
<!-- $$$nativeEvent[overload1]$$$nativeEventconstQByteArray&void*long* -->
<h3 class="fn" id="nativeEvent"><a name="nativeEvent"></a><code>[virtual protected] </code><span class="type">bool</span> QWidget::<span class="name">nativeEvent</span>(const <span class="type"><a href="../qtcore/qbytearray.html">QByteArray</a></span> &amp;<i>eventType</i>, <span class="type">void</span> *<i>message</i>, <span class="type">long</span> *<i>result</i>)</h3>
<p>This special event handler can be reimplemented in a subclass to receive native platform events identified by <i>eventType</i> which are passed in the <i>message</i> parameter.</p>
<p>In your reimplementation of this function, if you want to stop the event being handled by Qt, return true and set <i>result</i>. The <i>result</i> parameter has meaning only on Windows. If you return false, this native event is passed back to Qt, which translates the event into a Qt event and sends it to the widget.</p>
<p><b>Note: </b>Events are only delivered to this event handler if the widget has a native window handle.</p><p><b>Note: </b>This function superseedes the event filter functions x11Event(), winEvent() and macEvent() of Qt 4.</p><div class="table"><table class="generic">
 <thead><tr class="qt-style"><th >Platform</th><th >Event Type Identifier</th><th >Message Type</th><th >Result Type</th></tr></thead>
<tr valign="top" class="odd"><td >Windows</td><td >&quot;windows_generic_MSG&quot;</td><td >MSG *</td><td >LRESULT</td></tr>
<tr valign="top" class="even"><td ><a href="../qtdoc/internationalization.html#macos">macOS</a></td><td >&quot;NSEvent&quot;</td><td >NSEvent *</td><td ></td></tr>
<tr valign="top" class="odd"><td >XCB</td><td >&quot;xcb_generic_event_t&quot;</td><td >xcb_generic_event_t *</td><td ></td></tr>
</table></div>
<p><b>请参考 </b><a href="../qtcore/qabstractnativeeventfilter.html">QAbstractNativeEventFilter</a>.</p>
<!-- @@@nativeEvent -->
<!-- $$$nativeParentWidget[overload1]$$$nativeParentWidget -->
<h3 class="fn" id="nativeParentWidget"><a name="nativeParentWidget"></a><span class="type"><a href="qwidget.html#QWidget">QWidget</a></span> *QWidget::<span class="name">nativeParentWidget</span>() const</h3>
<p>Returns the native parent for this widget, i.e&#x2e; the next ancestor widget that has a system identifier, or 0 if it does not have any native parent.</p>
<p>This function was introduced in  Qt 4.4.</p>
<p><b>请参考 </b><a href="qwidget.html#effectiveWinId">effectiveWinId</a>().</p>
<!-- @@@nativeParentWidget -->
<!-- $$$nextInFocusChain[overload1]$$$nextInFocusChain -->
<h3 class="fn" id="nextInFocusChain"><a name="nextInFocusChain"></a><span class="type"><a href="qwidget.html#QWidget">QWidget</a></span> *QWidget::<span class="name">nextInFocusChain</span>() const</h3>
<p>Returns the next widget in this widget's focus chain.</p>
<p><b>请参考 </b><a href="qwidget.html#previousInFocusChain">previousInFocusChain</a>().</p>
<!-- @@@nextInFocusChain -->
<!-- $$$overrideWindowFlags[overload1]$$$overrideWindowFlagsQt::WindowFlags -->
<h3 class="fn" id="overrideWindowFlags"><a name="overrideWindowFlags"></a><span class="type">void</span> QWidget::<span class="name">overrideWindowFlags</span>(<span class="type"><a href="../qtcore/qt.html#WindowType-enum">Qt::WindowFlags</a></span> <i>flags</i>)</h3>
<p>Sets the window flags for the widget to <i>flags</i>, <i>without</i> telling the window system.</p>
<p><b>Warning:</b> Do not call this function unless you really know what you're doing.</p>
<p><b>请参考 </b><a href="qwidget.html#windowFlags-prop">setWindowFlags</a>().</p>
<!-- @@@overrideWindowFlags -->
<!-- $$$paintEngine[overload1]$$$paintEngine -->
<h3 class="fn" id="paintEngine"><a name="paintEngine"></a><code>[override virtual] </code><span class="type"><a href="../qtgui/qpaintengine.html">QPaintEngine</a></span> *QWidget::<span class="name">paintEngine</span>() const</h3>
<p>Reimplemented from <a href="../qtgui/qpaintdevice.html#paintEngine">QPaintDevice::paintEngine</a>().</p>
<p>Returns the widget's paint engine.</p>
<p>Note that this function should not be called explicitly by the user, since it's meant for reimplementation purposes only. The function is called by Qt internally, and the default implementation may not always return a valid pointer.</p>
<!-- @@@paintEngine -->
<!-- $$$paintEvent[overload1]$$$paintEventQPaintEvent* -->
<h3 class="fn" id="paintEvent"><a name="paintEvent"></a><code>[virtual protected] </code><span class="type">void</span> QWidget::<span class="name">paintEvent</span>(<span class="type"><a href="../qtgui/qpaintevent.html">QPaintEvent</a></span> *<i>event</i>)</h3>
<p>This event handler can be reimplemented in a subclass to receive paint events passed in <i>event</i>.</p>
<p>A paint event is a request to repaint all or part of a widget. It can happen for one of the following reasons:</p>
<ul>
<li><a href="qwidget.html#repaint">repaint</a>() or <a href="qwidget.html#update">update</a>() was invoked,</li>
<li>the widget was obscured and has now been uncovered, or</li>
<li>many other reasons.</li>
</ul>
<p>Many widgets can simply repaint their entire surface when asked to, but some slow widgets need to optimize by painting only the requested region: <a href="../qtgui/qpaintevent.html#region">QPaintEvent::region</a>(). This speed optimization does not change the result, as painting is clipped to that region during event processing. <a href="qlistview.html">QListView</a> and <a href="qtableview.html">QTableView</a> do this, for example.</p>
<p>Qt also tries to speed up painting by merging multiple paint events into one. When <a href="qwidget.html#update">update</a>() is called several times or the window system sends several paint events, Qt merges these events into one event with a larger region (see <a href="../qtgui/qregion.html#united-1">QRegion::united</a>()). The <a href="qwidget.html#repaint">repaint</a>() function does not permit this optimization, so we suggest using <a href="qwidget.html#update">update</a>() whenever possible.</p>
<p>When the paint event occurs, the update region has normally been erased, so you are painting on the widget's background.</p>
<p>The background can be set using <a href="qwidget.html#setBackgroundRole">setBackgroundRole</a>() and <a href="qwidget.html#palette-prop">setPalette</a>().</p>
<p>Since Qt 4.0, <a href="qwidget.html">QWidget</a> automatically double-buffers its painting, so there is no need to write double-buffering code in paintEvent() to avoid flicker.</p>
<p><b>Note: </b>Generally, you should refrain from calling <a href="qwidget.html#update">update</a>() or <a href="qwidget.html#repaint">repaint</a>() <b>inside</b> a paintEvent(). For example, calling <a href="qwidget.html#update">update</a>() or <a href="qwidget.html#repaint">repaint</a>() on children inside a paintEvent() results in undefined behavior; the child may or may not get a paint event.</p><p><b>Warning:</b> If you are using a custom paint engine without Qt's backingstore, <a href="../qtcore/qt.html#WidgetAttribute-enum">Qt::WA_PaintOnScreen</a> must be set. Otherwise, <a href="qwidget.html#paintEngine">QWidget::paintEngine</a>() will never be called; the backingstore will be used instead.</p>
<p><b>请参考 </b><a href="qwidget.html#event">event</a>(), <a href="qwidget.html#repaint">repaint</a>(), <a href="qwidget.html#update">update</a>(), <a href="../qtgui/qpainter.html">QPainter</a>, <a href="../qtgui/qpixmap.html">QPixmap</a>, <a href="../qtgui/qpaintevent.html">QPaintEvent</a>, and <a href="qtwidgets-widgets-analogclock-example.html">Analog Clock Example</a>.</p>
<!-- @@@paintEvent -->
<!-- $$$parentWidget[overload1]$$$parentWidget -->
<h3 class="fn" id="parentWidget"><a name="parentWidget"></a><span class="type"><a href="qwidget.html#QWidget">QWidget</a></span> *QWidget::<span class="name">parentWidget</span>() const</h3>
<p>Returns the parent of this widget, or 0 if it does not have any parent widget.</p>
<!-- @@@parentWidget -->
<!-- $$$previousInFocusChain[overload1]$$$previousInFocusChain -->
<h3 class="fn" id="previousInFocusChain"><a name="previousInFocusChain"></a><span class="type"><a href="qwidget.html#QWidget">QWidget</a></span> *QWidget::<span class="name">previousInFocusChain</span>() const</h3>
<p>The previousInFocusChain function returns the previous widget in this widget's focus chain.</p>
<p>This function was introduced in  Qt 4.6.</p>
<p><b>请参考 </b><a href="qwidget.html#nextInFocusChain">nextInFocusChain</a>().</p>
<!-- @@@previousInFocusChain -->
<!-- $$$raise[overload1]$$$raise -->
<h3 class="fn" id="raise"><a name="raise"></a><code>[slot] </code><span class="type">void</span> QWidget::<span class="name">raise</span>()</h3>
<p>Raises this widget to the top of the parent widget's stack.</p>
<p>After this call the widget will be visually in front of any overlapping sibling widgets.</p>
<p><b>Note: </b>When using <a href="qwidget.html#activateWindow">activateWindow</a>(), you can call this function to ensure that the window is stacked on top.</p><p><b>请参考 </b><a href="qwidget.html#lower">lower</a>() and <a href="qwidget.html#stackUnder">stackUnder</a>().</p>
<!-- @@@raise -->
<!-- $$$releaseKeyboard[overload1]$$$releaseKeyboard -->
<h3 class="fn" id="releaseKeyboard"><a name="releaseKeyboard"></a><span class="type">void</span> QWidget::<span class="name">releaseKeyboard</span>()</h3>
<p>Releases the keyboard grab.</p>
<p><b>请参考 </b><a href="qwidget.html#grabKeyboard">grabKeyboard</a>(), <a href="qwidget.html#grabMouse">grabMouse</a>(), and <a href="qwidget.html#releaseMouse">releaseMouse</a>().</p>
<!-- @@@releaseKeyboard -->
<!-- $$$releaseMouse[overload1]$$$releaseMouse -->
<h3 class="fn" id="releaseMouse"><a name="releaseMouse"></a><span class="type">void</span> QWidget::<span class="name">releaseMouse</span>()</h3>
<p>Releases the mouse grab.</p>
<p><b>请参考 </b><a href="qwidget.html#grabMouse">grabMouse</a>(), <a href="qwidget.html#grabKeyboard">grabKeyboard</a>(), and <a href="qwidget.html#releaseKeyboard">releaseKeyboard</a>().</p>
<!-- @@@releaseMouse -->
<!-- $$$releaseShortcut[overload1]$$$releaseShortcutint -->
<h3 class="fn" id="releaseShortcut"><a name="releaseShortcut"></a><span class="type">void</span> QWidget::<span class="name">releaseShortcut</span>(<span class="type">int</span> <i>id</i>)</h3>
<p>Removes the shortcut with the given <i>id</i> from Qt's shortcut system. The widget will no longer receive <a href="../qtcore/qevent.html#Type-enum">QEvent::Shortcut</a> events for the shortcut's key sequence (unless it has other shortcuts with the same key sequence).</p>
<p><b>Warning:</b> You should not normally need to use this function since Qt's shortcut system removes shortcuts automatically when their parent widget is destroyed. It is best to use <a href="qaction.html">QAction</a> or <a href="qshortcut.html">QShortcut</a> to handle shortcuts, since they are easier to use than this low-level function. Note also that this is an expensive operation.</p>
<p><b>请参考 </b><a href="qwidget.html#grabShortcut">grabShortcut</a>() and <a href="qwidget.html#setShortcutEnabled">setShortcutEnabled</a>().</p>
<!-- @@@releaseShortcut -->
<!-- $$$removeAction[overload1]$$$removeActionQAction* -->
<h3 class="fn" id="removeAction"><a name="removeAction"></a><span class="type">void</span> QWidget::<span class="name">removeAction</span>(<span class="type"><a href="qaction.html">QAction</a></span> *<i>action</i>)</h3>
<p>Removes the action <i>action</i> from this widget's list of actions.</p>
<p><b>请参考 </b><a href="qwidget.html#insertAction">insertAction</a>(), <a href="qwidget.html#actions">actions</a>(), and <a href="qwidget.html#insertAction">insertAction</a>().</p>
<!-- @@@removeAction -->
<!-- $$$render[overload1]$$$renderQPaintDevice*constQPoint&constQRegion&QWidget::RenderFlags -->
<h3 class="fn" id="render"><span class="type">void</span> QWidget::<span class="name">render</span>(<span class="type"><a href="../qtgui/qpaintdevice.html#QPaintDevice">QPaintDevice</a></span> *<i>target</i>, const <span class="type"><a href="../qtcore/qpoint.html">QPoint</a></span> &amp;<i>targetOffset</i> = QPoint(), const <span class="type"><a href="../qtgui/qregion.html">QRegion</a></span> &amp;<i>sourceRegion</i> = QRegion(), <span class="type"><a href="qwidget.html#RenderFlag-enum">QWidget::RenderFlags</a></span> <i>renderFlags</i> = ...)</h3>
<p>Renders the <i>sourceRegion</i> of this widget into the <i>target</i> using <i>renderFlags</i> to determine how to render. Rendering starts at <i>targetOffset</i> in the <i>target</i>. For example:</p>
<pre class="cpp">

  <span class="type"><a href="../qtgui/qpixmap.html">QPixmap</a></span> pixmap(widget<span class="operator">-</span><span class="operator">&gt;</span>size());
  widget<span class="operator">-</span><span class="operator">&gt;</span>render(<span class="operator">&amp;</span>pixmap);

</pre>
<p>If <i>sourceRegion</i> is a null region, this function will use <a href="qwidget.html#rect-prop">QWidget::rect</a>() as the region, i.e&#x2e; the entire widget.</p>
<p>Ensure that you call <a href="../qtgui/qpainter.html#end">QPainter::end</a>() for the <i>target</i> device's active painter (if any) before rendering. For example:</p>
<pre class="cpp">

  <span class="type"><a href="../qtgui/qpainter.html">QPainter</a></span> painter(<span class="keyword">this</span>);
  <span class="operator">.</span><span class="operator">.</span><span class="operator">.</span>
  painter<span class="operator">.</span>end();
  myWidget<span class="operator">-</span><span class="operator">&gt;</span>render(<span class="keyword">this</span>);

</pre>
<p><b>Note: </b>To obtain the contents of a <a href="qopenglwidget.html">QOpenGLWidget</a>, use <a href="qopenglwidget.html#grabFramebuffer">QOpenGLWidget::grabFramebuffer</a>() instead.</p><p><b>Note: </b>To obtain the contents of a QGLWidget (deprecated), use QGLWidget::grabFrameBuffer() or QGLWidget::renderPixmap() instead.</p><p>This function was introduced in  Qt 4.3.</p>
<!-- @@@render -->
<!-- $$$render$$$renderQPainter*constQPoint&constQRegion&QWidget::RenderFlags -->
<h3 class="fn" id="render-1"><a name="render-1"></a><span class="type">void</span> QWidget::<span class="name">render</span>(<span class="type"><a href="../qtgui/qpainter.html">QPainter</a></span> *<i>painter</i>, const <span class="type"><a href="../qtcore/qpoint.html">QPoint</a></span> &amp;<i>targetOffset</i> = QPoint(), const <span class="type"><a href="../qtgui/qregion.html">QRegion</a></span> &amp;<i>sourceRegion</i> = QRegion(), <span class="type"><a href="qwidget.html#RenderFlag-enum">QWidget::RenderFlags</a></span> <i>renderFlags</i> = ...)</h3>
<p>This is an overloaded function.</p>
<p>Renders the widget into the <i>painter</i>'s <a href="../qtgui/qpainter.html#device">QPainter::device</a>().</p>
<p>Transformations and settings applied to the <i>painter</i> will be used when rendering.</p>
<p><b>Note: </b>The <i>painter</i> must be active. On <a href="../qtdoc/internationalization.html#macos">macOS</a> the widget will be rendered into a <a href="../qtgui/qpixmap.html">QPixmap</a> and then drawn by the <i>painter</i>.</p><p><b>请参考 </b><a href="../qtgui/qpainter.html#device">QPainter::device</a>().</p>
<!-- @@@render -->
<!-- $$$repaint[overload1]$$$repaint -->
<h3 class="fn" id="repaint"><a name="repaint"></a><code>[slot] </code><span class="type">void</span> QWidget::<span class="name">repaint</span>()</h3>
<p>Repaints the widget directly by calling <a href="qwidget.html#paintEvent">paintEvent</a>() immediately, unless updates are disabled or the widget is hidden.</p>
<p>We suggest only using repaint() if you need an immediate repaint, for example during animation. In almost all circumstances <a href="qwidget.html#update">update</a>() is better, as it permits Qt to optimize for speed and minimize flicker.</p>
<p><b>Warning:</b> If you call repaint() in a function which may itself be called from <a href="qwidget.html#paintEvent">paintEvent</a>(), you may get infinite recursion. The <a href="qwidget.html#update">update</a>() function never causes recursion.</p>
<p><b>请参考 </b><a href="qwidget.html#update">update</a>(), <a href="qwidget.html#paintEvent">paintEvent</a>(), and <a href="qwidget.html#updatesEnabled-prop">setUpdatesEnabled</a>().</p>
<!-- @@@repaint -->
<!-- $$$repaint$$$repaintintintintint -->
<h3 class="fn" id="repaint-1"><a name="repaint-1"></a><span class="type">void</span> QWidget::<span class="name">repaint</span>(<span class="type">int</span> <i>x</i>, <span class="type">int</span> <i>y</i>, <span class="type">int</span> <i>w</i>, <span class="type">int</span> <i>h</i>)</h3>
<p>This is an overloaded function.</p>
<p>This version repaints a rectangle (<i>x</i>, <i>y</i>, <i>w</i>, <i>h</i>) inside the widget.</p>
<p>If <i>w</i> is negative, it is replaced with <code>width() - x</code>, and if <i>h</i> is negative, it is replaced width <code>height() - y</code>.</p>
<!-- @@@repaint -->
<!-- $$$repaint$$$repaintconstQRect& -->
<h3 class="fn" id="repaint-2"><a name="repaint-2"></a><span class="type">void</span> QWidget::<span class="name">repaint</span>(const <span class="type"><a href="../qtcore/qrect.html">QRect</a></span> &amp;<i>rect</i>)</h3>
<p>This is an overloaded function.</p>
<p>This version repaints a rectangle <i>rect</i> inside the widget.</p>
<!-- @@@repaint -->
<!-- $$$repaint$$$repaintconstQRegion& -->
<h3 class="fn" id="repaint-3"><a name="repaint-3"></a><span class="type">void</span> QWidget::<span class="name">repaint</span>(const <span class="type"><a href="../qtgui/qregion.html">QRegion</a></span> &amp;<i>rgn</i>)</h3>
<p>This is an overloaded function.</p>
<p>This version repaints a region <i>rgn</i> inside the widget.</p>
<!-- @@@repaint -->
<!-- $$$resize -->
<h3 class="fn" id="resize-1"><a name="resize-1"></a><span class="type">void</span> QWidget::<span class="name">resize</span>(<span class="type">int</span> <i>w</i>, <span class="type">int</span> <i>h</i>)</h3>
<p>This is an overloaded function.</p>
<p>This corresponds to resize(<a href="../qtcore/qsize.html">QSize</a>(<i>w</i>, <i>h</i>)).</p>
<p><b>Note:</b> Setter function for property <a href="qwidget.html#size-prop">size</a>. </p><!-- @@@resize -->
<!-- $$$resizeEvent[overload1]$$$resizeEventQResizeEvent* -->
<h3 class="fn" id="resizeEvent"><a name="resizeEvent"></a><code>[virtual protected] </code><span class="type">void</span> QWidget::<span class="name">resizeEvent</span>(<span class="type"><a href="../qtgui/qresizeevent.html">QResizeEvent</a></span> *<i>event</i>)</h3>
<p>This event handler can be reimplemented in a subclass to receive widget resize events which are passed in the <i>event</i> parameter. When resizeEvent() is called, the widget already has its new geometry. The old size is accessible through <a href="../qtgui/qresizeevent.html#oldSize">QResizeEvent::oldSize</a>().</p>
<p>The widget will be erased and receive a paint event immediately after processing the resize event. No drawing need be (or should be) done inside this handler.</p>
<p><b>请参考 </b><a href="qwidget.html#moveEvent">moveEvent</a>(), <a href="qwidget.html#event">event</a>(), <a href="qwidget.html#size-prop">resize</a>(), <a href="../qtgui/qresizeevent.html">QResizeEvent</a>, <a href="qwidget.html#paintEvent">paintEvent</a>(), and <a href="qtwidgets-widgets-scribble-example.html">Scribble Example</a>.</p>
<!-- @@@resizeEvent -->
<!-- $$$restoreGeometry[overload1]$$$restoreGeometryconstQByteArray& -->
<h3 class="fn" id="restoreGeometry"><a name="restoreGeometry"></a><span class="type">bool</span> QWidget::<span class="name">restoreGeometry</span>(const <span class="type"><a href="../qtcore/qbytearray.html">QByteArray</a></span> &amp;<i>geometry</i>)</h3>
<p>Restores the geometry and state of top-level widgets stored in the byte array <i>geometry</i>. Returns <code>true</code> on success; otherwise returns <code>false</code>.</p>
<p>If the restored geometry is off-screen, it will be modified to be inside the available screen geometry.</p>
<p>To restore geometry saved using <a href="../qtcore/qsettings.html">QSettings</a>, you can use code like this:</p>
<pre class="cpp">

  <span class="type"><a href="../qtcore/qsettings.html">QSettings</a></span> settings(<span class="string">&quot;MyCompany&quot;</span><span class="operator">,</span> <span class="string">&quot;MyApp&quot;</span>);
  myWidget<span class="operator">-</span><span class="operator">&gt;</span>restoreGeometry(settings<span class="operator">.</span>value(<span class="string">&quot;myWidget/geometry&quot;</span>)<span class="operator">.</span>toByteArray());

</pre>
<p>See the <a href="application-windows.html#window-geometry">Window Geometry</a> documentation for an overview of geometry issues with windows.</p>
<p>Use <a href="qmainwindow.html#restoreState">QMainWindow::restoreState</a>() to restore the geometry and the state of toolbars and dock widgets.</p>
<p>This function was introduced in  Qt 4.2.</p>
<p><b>请参考 </b><a href="qwidget.html#saveGeometry">saveGeometry</a>(), <a href="../qtcore/qsettings.html">QSettings</a>, <a href="qmainwindow.html#saveState">QMainWindow::saveState</a>(), and <a href="qmainwindow.html#restoreState">QMainWindow::restoreState</a>().</p>
<!-- @@@restoreGeometry -->
<!-- $$$saveGeometry[overload1]$$$saveGeometry -->
<h3 class="fn" id="saveGeometry"><a name="saveGeometry"></a><span class="type"><a href="../qtcore/qbytearray.html">QByteArray</a></span> QWidget::<span class="name">saveGeometry</span>() const</h3>
<p>Saves the current geometry and state for top-level widgets.</p>
<p>To save the geometry when the window closes, you can implement a close event like this:</p>
<pre class="cpp">

  <span class="type">void</span> MyWidget<span class="operator">::</span>closeEvent(<span class="type"><a href="../qtgui/qcloseevent.html">QCloseEvent</a></span> <span class="operator">*</span>event)
  {
      <span class="type"><a href="../qtcore/qsettings.html">QSettings</a></span> settings(<span class="string">&quot;MyCompany&quot;</span><span class="operator">,</span> <span class="string">&quot;MyApp&quot;</span>);
      settings<span class="operator">.</span>setValue(<span class="string">&quot;geometry&quot;</span><span class="operator">,</span> saveGeometry());
      <span class="type"><a href="qwidget.html#QWidget">QWidget</a></span><span class="operator">::</span>closeEvent(event);
  }

</pre>
<p>See the <a href="application-windows.html#window-geometry">Window Geometry</a> documentation for an overview of geometry issues with windows.</p>
<p>Use <a href="qmainwindow.html#saveState">QMainWindow::saveState</a>() to save the geometry and the state of toolbars and dock widgets.</p>
<p>This function was introduced in  Qt 4.2.</p>
<p><b>请参考 </b><a href="qwidget.html#restoreGeometry">restoreGeometry</a>(), <a href="qmainwindow.html#saveState">QMainWindow::saveState</a>(), and <a href="qmainwindow.html#restoreState">QMainWindow::restoreState</a>().</p>
<!-- @@@saveGeometry -->
<!-- $$$scroll[overload1]$$$scrollintint -->
<h3 class="fn" id="scroll"><a name="scroll"></a><span class="type">void</span> QWidget::<span class="name">scroll</span>(<span class="type">int</span> <i>dx</i>, <span class="type">int</span> <i>dy</i>)</h3>
<p>Scrolls the widget including its children <i>dx</i> pixels to the right and <i>dy</i> downward. Both <i>dx</i> and <i>dy</i> may be negative.</p>
<p>After scrolling, the widgets will receive paint events for the areas that need to be repainted. For widgets that Qt knows to be opaque, this is only the newly exposed parts. For example, if an opaque widget is scrolled 8 pixels to the left, only an 8-pixel wide stripe at the right edge needs updating.</p>
<p>Since widgets propagate the contents of their parents by default, you need to set the <a href="qwidget.html#autoFillBackground-prop">autoFillBackground</a> property, or use <a href="qwidget.html#setAttribute">setAttribute</a>() to set the <a href="../qtcore/qt.html#WidgetAttribute-enum">Qt::WA_OpaquePaintEvent</a> attribute, to make a widget opaque.</p>
<p>For widgets that use contents propagation, a scroll will cause an update of the entire scroll area.</p>
<p><b>请参考 </b><a href="qwidget.html#transparency-and-double-buffering">Transparency and Double Buffering</a>.</p>
<!-- @@@scroll -->
<!-- $$$scroll$$$scrollintintconstQRect& -->
<h3 class="fn" id="scroll-1"><a name="scroll-1"></a><span class="type">void</span> QWidget::<span class="name">scroll</span>(<span class="type">int</span> <i>dx</i>, <span class="type">int</span> <i>dy</i>, const <span class="type"><a href="../qtcore/qrect.html">QRect</a></span> &amp;<i>r</i>)</h3>
<p>This is an overloaded function.</p>
<p>This version only scrolls <i>r</i> and does not move the children of the widget.</p>
<p>If <i>r</i> is empty or invalid, the result is undefined.</p>
<p><b>请参考 </b><a href="qscrollarea.html">QScrollArea</a>.</p>
<!-- @@@scroll -->
<!-- $$$setAttribute[overload1]$$$setAttributeQt::WidgetAttributebool -->
<h3 class="fn" id="setAttribute"><a name="setAttribute"></a><span class="type">void</span> QWidget::<span class="name">setAttribute</span>(<span class="type"><a href="../qtcore/qt.html#WidgetAttribute-enum">Qt::WidgetAttribute</a></span> <i>attribute</i>, <span class="type">bool</span> <i>on</i> = true)</h3>
<p>Sets the attribute <i>attribute</i> on this widget if <i>on</i> is true; otherwise clears the attribute.</p>
<p><b>请参考 </b><a href="qwidget.html#testAttribute">testAttribute</a>().</p>
<!-- @@@setAttribute -->
<!-- $$$setBackgroundRole[overload1]$$$setBackgroundRoleQPalette::ColorRole -->
<h3 class="fn" id="setBackgroundRole"><a name="setBackgroundRole"></a><span class="type">void</span> QWidget::<span class="name">setBackgroundRole</span>(<span class="type"><a href="../qtgui/qpalette.html#ColorRole-enum">QPalette::ColorRole</a></span> <i>role</i>)</h3>
<p>Sets the background role of the widget to <i>role</i>.</p>
<p>The background role defines the brush from the widget's <a href="qwidget.html#palette-prop">palette</a> that is used to render the background.</p>
<p>If <i>role</i> is <a href="../qtgui/qpalette.html#ColorRole-enum">QPalette::NoRole</a>, then the widget inherits its parent's background role.</p>
<p>Note that styles are free to choose any color from the palette. You can modify the palette or set a style sheet if you don't achieve the result you want with setBackgroundRole().</p>
<p><b>请参考 </b><a href="qwidget.html#backgroundRole">backgroundRole</a>() and <a href="qwidget.html#foregroundRole">foregroundRole</a>().</p>
<!-- @@@setBackgroundRole -->
<!-- $$$setBaseSize -->
<h3 class="fn" id="setBaseSize-1"><a name="setBaseSize-1"></a><span class="type">void</span> QWidget::<span class="name">setBaseSize</span>(<span class="type">int</span> <i>basew</i>, <span class="type">int</span> <i>baseh</i>)</h3>
<p>This is an overloaded function.</p>
<p>This corresponds to <a href="qwidget.html#baseSize-prop">setBaseSize</a>(<a href="../qtcore/qsize.html">QSize</a>(<i>basew</i>, <i>baseh</i>)). Sets the widgets base size to width <i>basew</i> and height <i>baseh</i>.</p>
<p><b>Note:</b> Setter function for property <a href="qwidget.html#baseSize-prop">baseSize</a>. </p><!-- @@@setBaseSize -->
<!-- $$$setContentsMargins[overload1]$$$setContentsMarginsintintintint -->
<h3 class="fn" id="setContentsMargins"><a name="setContentsMargins"></a><span class="type">void</span> QWidget::<span class="name">setContentsMargins</span>(<span class="type">int</span> <i>left</i>, <span class="type">int</span> <i>top</i>, <span class="type">int</span> <i>right</i>, <span class="type">int</span> <i>bottom</i>)</h3>
<p>Sets the margins around the contents of the widget to have the sizes <i>left</i>, <i>top</i>, <i>right</i>, and <i>bottom</i>. The margins are used by the layout system, and may be used by subclasses to specify the area to draw in (e.g&#x2e; excluding the frame).</p>
<p>Changing the margins will trigger a <a href="qwidget.html#resizeEvent">resizeEvent</a>().</p>
<p><b>请参考 </b><a href="qwidget.html#contentsMargins">contentsMargins</a>(), <a href="qwidget.html#contentsRect">contentsRect</a>(), and <a href="qwidget.html#getContentsMargins">getContentsMargins</a>().</p>
<!-- @@@setContentsMargins -->
<!-- $$$setContentsMargins$$$setContentsMarginsconstQMargins& -->
<h3 class="fn" id="setContentsMargins-1"><a name="setContentsMargins-1"></a><span class="type">void</span> QWidget::<span class="name">setContentsMargins</span>(const <span class="type"><a href="../qtcore/qmargins.html">QMargins</a></span> &amp;<i>margins</i>)</h3>
<p>This is an overloaded function.</p>
<p>The <a href="qwidget.html#setContentsMargins">setContentsMargins</a> function sets the margins around the widget's contents.</p>
<p>Sets the margins around the contents of the widget to have the sizes determined by <i>margins</i>. The margins are used by the layout system, and may be used by subclasses to specify the area to draw in (e.g&#x2e; excluding the frame).</p>
<p>Changing the margins will trigger a <a href="qwidget.html#resizeEvent">resizeEvent</a>().</p>
<p>This function was introduced in  Qt 4.6.</p>
<p><b>请参考 </b><a href="qwidget.html#contentsRect">contentsRect</a>() and <a href="qwidget.html#getContentsMargins">getContentsMargins</a>().</p>
<!-- @@@setContentsMargins -->
<!-- $$$setDisabled[overload1]$$$setDisabledbool -->
<h3 class="fn" id="setDisabled"><a name="setDisabled"></a><code>[slot] </code><span class="type">void</span> QWidget::<span class="name">setDisabled</span>(<span class="type">bool</span> <i>disable</i>)</h3>
<p>Disables widget input events if <i>disable</i> is true; otherwise enables input events.</p>
<p>See the <a href="qwidget.html#enabled-prop">enabled</a> documentation for more information.</p>
<p><b>请参考 </b><a href="qwidget.html#isEnabledTo">isEnabledTo</a>(), <a href="../qtgui/qkeyevent.html">QKeyEvent</a>, <a href="../qtgui/qmouseevent.html">QMouseEvent</a>, and <a href="qwidget.html#changeEvent">changeEvent</a>().</p>
<!-- @@@setDisabled -->
<!-- $$$setEditFocus[overload1]$$$setEditFocusbool -->
<h3 class="fn" id="setEditFocus"><a name="setEditFocus"></a><span class="type">void</span> QWidget::<span class="name">setEditFocus</span>(<span class="type">bool</span> <i>enable</i>)</h3>
<p>If <i>enable</i> is true, make this widget have edit focus, in which case <a href="../qtcore/qt.html#Key-enum">Qt::Key_Up</a> and <a href="../qtcore/qt.html#Key-enum">Qt::Key_Down</a> will be delivered to the widget normally; otherwise, <a href="../qtcore/qt.html#Key-enum">Qt::Key_Up</a> and <a href="../qtcore/qt.html#Key-enum">Qt::Key_Down</a> are used to change focus.</p>
<p>This feature is only available in Qt for Embedded Linux.</p>
<p><b>请参考 </b><a href="qwidget.html#hasEditFocus">hasEditFocus</a>() and <a href="qapplication-obsolete.html#keypadNavigationEnabled">QApplication::keypadNavigationEnabled</a>().</p>
<!-- @@@setEditFocus -->
<!-- $$$setFixedHeight[overload1]$$$setFixedHeightint -->
<h3 class="fn" id="setFixedHeight"><a name="setFixedHeight"></a><span class="type">void</span> QWidget::<span class="name">setFixedHeight</span>(<span class="type">int</span> <i>h</i>)</h3>
<p>Sets both the minimum and maximum heights of the widget to <i>h</i> without changing the widths. Provided for convenience.</p>
<p><b>请参考 </b><a href="qwidget.html#sizeHint-prop">sizeHint</a>(), <a href="qwidget.html#minimumSize-prop">minimumSize</a>(), <a href="qwidget.html#maximumSize-prop">maximumSize</a>(), and <a href="qwidget.html#setFixedSize">setFixedSize</a>().</p>
<!-- @@@setFixedHeight -->
<!-- $$$setFixedSize[overload1]$$$setFixedSizeconstQSize& -->
<h3 class="fn" id="setFixedSize"><a name="setFixedSize"></a><span class="type">void</span> QWidget::<span class="name">setFixedSize</span>(const <span class="type"><a href="../qtcore/qsize.html">QSize</a></span> &amp;<i>s</i>)</h3>
<p>Sets both the minimum and maximum sizes of the widget to <i>s</i>, thereby preventing it from ever growing or shrinking.</p>
<p>This will override the default size constraints set by <a href="qlayout.html">QLayout</a>.</p>
<p>To remove constraints, set the size to <a href="qwidget.html#QWIDGETSIZE_MAX">QWIDGETSIZE_MAX</a>.</p>
<p>Alternatively, if you want the widget to have a fixed size based on its contents, you can call <a href="qlayout.html#sizeConstraint-prop">QLayout::setSizeConstraint</a>(<a href="qlayout.html#SizeConstraint-enum">QLayout::SetFixedSize</a>);</p>
<p><b>请参考 </b><a href="qwidget.html#maximumSize-prop">maximumSize</a> and <a href="qwidget.html#minimumSize-prop">minimumSize</a>.</p>
<!-- @@@setFixedSize -->
<!-- $$$setFixedSize$$$setFixedSizeintint -->
<h3 class="fn" id="setFixedSize-1"><a name="setFixedSize-1"></a><span class="type">void</span> QWidget::<span class="name">setFixedSize</span>(<span class="type">int</span> <i>w</i>, <span class="type">int</span> <i>h</i>)</h3>
<p>This is an overloaded function.</p>
<p>Sets the width of the widget to <i>w</i> and the height to <i>h</i>.</p>
<!-- @@@setFixedSize -->
<!-- $$$setFixedWidth[overload1]$$$setFixedWidthint -->
<h3 class="fn" id="setFixedWidth"><a name="setFixedWidth"></a><span class="type">void</span> QWidget::<span class="name">setFixedWidth</span>(<span class="type">int</span> <i>w</i>)</h3>
<p>Sets both the minimum and maximum width of the widget to <i>w</i> without changing the heights. Provided for convenience.</p>
<p><b>请参考 </b><a href="qwidget.html#sizeHint-prop">sizeHint</a>(), <a href="qwidget.html#minimumSize-prop">minimumSize</a>(), <a href="qwidget.html#maximumSize-prop">maximumSize</a>(), and <a href="qwidget.html#setFixedSize">setFixedSize</a>().</p>
<!-- @@@setFixedWidth -->
<!-- $$$setFocus[overload1]$$$setFocusQt::FocusReason -->
<h3 class="fn" id="setFocus"><a name="setFocus"></a><span class="type">void</span> QWidget::<span class="name">setFocus</span>(<span class="type"><a href="../qtcore/qt.html#FocusReason-enum">Qt::FocusReason</a></span> <i>reason</i>)</h3>
<p>Gives the keyboard input focus to this widget (or its focus proxy) if this widget or one of its parents is the <a href="qwidget.html#isActiveWindow-prop">active window</a>. The <i>reason</i> argument will be passed into any focus event sent from this function, it is used to give an explanation of what caused the widget to get focus. If the window is not active, the widget will be given the focus when the window becomes active.</p>
<p>First, a focus about to change event is sent to the focus widget (if any) to tell it that it is about to lose the focus. Then focus is changed, a focus out event is sent to the previous focus item and a focus in event is sent to the new item to tell it that it just received the focus. (Nothing happens if the focus in and focus out widgets are the same.)</p>
<p><b>Note: </b>On embedded platforms, <a href="qwidget.html#setFocus-1">setFocus</a>() will not cause an input panel to be opened by the input method. If you want this to happen, you have to send a <a href="../qtcore/qevent.html#Type-enum">QEvent::RequestSoftwareInputPanel</a> event to the widget yourself.</p><p><a href="qwidget.html#setFocus-1">setFocus</a>() gives focus to a widget regardless of its focus policy, but does not clear any keyboard grab (see <a href="qwidget.html#grabKeyboard">grabKeyboard</a>()).</p>
<p>Be aware that if the widget is hidden, it will not accept focus until it is shown.</p>
<p><b>Warning:</b> If you call <a href="qwidget.html#setFocus-1">setFocus</a>() in a function which may itself be called from <a href="qwidget.html#focusOutEvent">focusOutEvent</a>() or <a href="qwidget.html#focusInEvent">focusInEvent</a>(), you may get an infinite recursion.</p>
<p><b>请参考 </b><a href="qwidget.html#focus-prop">hasFocus</a>(), <a href="qwidget.html#clearFocus">clearFocus</a>(), <a href="qwidget.html#focusInEvent">focusInEvent</a>(), <a href="qwidget.html#focusOutEvent">focusOutEvent</a>(), <a href="qwidget.html#focusPolicy-prop">setFocusPolicy</a>(), <a href="qwidget.html#focusWidget">focusWidget</a>(), <a href="qapplication.html#focusWidget">QApplication::focusWidget</a>(), <a href="qwidget.html#grabKeyboard">grabKeyboard</a>(), <a href="qwidget.html#grabMouse">grabMouse</a>(), <a href="focus.html">Keyboard Focus in Widgets</a>, and <a href="../qtcore/qevent.html#Type-enum">QEvent::RequestSoftwareInputPanel</a>.</p>
<!-- @@@setFocus -->
<!-- $$$setFocus$$$setFocus -->
<h3 class="fn" id="setFocus-1"><a name="setFocus-1"></a><code>[slot] </code><span class="type">void</span> QWidget::<span class="name">setFocus</span>()</h3>
<p>This is an overloaded function.</p>
<p>Gives the keyboard input focus to this widget (or its focus proxy) if this widget or one of its parents is the <a href="qwidget.html#isActiveWindow-prop">active window</a>.</p>
<!-- @@@setFocus -->
<!-- $$$setFocusProxy[overload1]$$$setFocusProxyQWidget* -->
<h3 class="fn" id="setFocusProxy"><a name="setFocusProxy"></a><span class="type">void</span> QWidget::<span class="name">setFocusProxy</span>(<span class="type"><a href="qwidget.html#QWidget">QWidget</a></span> *<i>w</i>)</h3>
<p>Sets the widget's focus proxy to widget <i>w</i>. If <i>w</i> is 0, the function resets this widget to have no focus proxy.</p>
<p>Some widgets can &quot;have focus&quot;, but create a child widget, such as <a href="qlineedit.html">QLineEdit</a>, to actually handle the focus. In this case, the widget can set the line edit to be its focus proxy.</p>
<p>setFocusProxy() sets the widget which will actually get focus when &quot;this widget&quot; gets it. If there is a focus proxy, <a href="qwidget.html#setFocus-1">setFocus</a>() and <a href="qwidget.html#focus-prop">hasFocus</a>() operate on the focus proxy.</p>
<p><b>请参考 </b><a href="qwidget.html#focusProxy">focusProxy</a>().</p>
<!-- @@@setFocusProxy -->
<!-- $$$setForegroundRole[overload1]$$$setForegroundRoleQPalette::ColorRole -->
<h3 class="fn" id="setForegroundRole"><a name="setForegroundRole"></a><span class="type">void</span> QWidget::<span class="name">setForegroundRole</span>(<span class="type"><a href="../qtgui/qpalette.html#ColorRole-enum">QPalette::ColorRole</a></span> <i>role</i>)</h3>
<p>Sets the foreground role of the widget to <i>role</i>.</p>
<p>The foreground role defines the color from the widget's <a href="qwidget.html#palette-prop">palette</a> that is used to draw the foreground.</p>
<p>If <i>role</i> is <a href="../qtgui/qpalette.html#ColorRole-enum">QPalette::NoRole</a>, the widget uses a foreground role that contrasts with the background role.</p>
<p>Note that styles are free to choose any color from the palette. You can modify the palette or set a style sheet if you don't achieve the result you want with setForegroundRole().</p>
<p><b>请参考 </b><a href="qwidget.html#foregroundRole">foregroundRole</a>() and <a href="qwidget.html#backgroundRole">backgroundRole</a>().</p>
<!-- @@@setForegroundRole -->
<!-- $$$setGeometry -->
<h3 class="fn" id="setGeometry-1"><a name="setGeometry-1"></a><span class="type">void</span> QWidget::<span class="name">setGeometry</span>(<span class="type">int</span> <i>x</i>, <span class="type">int</span> <i>y</i>, <span class="type">int</span> <i>w</i>, <span class="type">int</span> <i>h</i>)</h3>
<p>This is an overloaded function.</p>
<p>This corresponds to <a href="qwidget.html#geometry-prop">setGeometry</a>(<a href="../qtcore/qrect.html">QRect</a>(<i>x</i>, <i>y</i>, <i>w</i>, <i>h</i>)).</p>
<p><b>Note:</b> Setter function for property <a href="qwidget.html#geometry-prop">geometry</a>. </p><!-- @@@setGeometry -->
<!-- $$$setGraphicsEffect[overload1]$$$setGraphicsEffectQGraphicsEffect* -->
<h3 class="fn" id="setGraphicsEffect"><a name="setGraphicsEffect"></a><span class="type">void</span> QWidget::<span class="name">setGraphicsEffect</span>(<span class="type"><a href="qgraphicseffect.html">QGraphicsEffect</a></span> *<i>effect</i>)</h3>
<p>The setGraphicsEffect function is for setting the widget's graphics effect.</p>
<p>Sets <i>effect</i> as the widget's effect. If there already is an effect installed on this widget, <a href="qwidget.html">QWidget</a> will delete the existing effect before installing the new <i>effect</i>.</p>
<p>If <i>effect</i> is the installed effect on a different widget, setGraphicsEffect() will remove the effect from the widget and install it on this widget.</p>
<p><a href="qwidget.html">QWidget</a> takes ownership of <i>effect</i>.</p>
<p><b>Note: </b>This function will apply the effect on itself and all its children.</p><p><b>Note: </b>Graphics effects are not supported for OpenGL-based widgets, such as QGLWidget, <a href="qopenglwidget.html">QOpenGLWidget</a> and <a href="../qtquick/qquickwidget.html">QQuickWidget</a>.</p><p>This function was introduced in  Qt 4.6.</p>
<p><b>请参考 </b><a href="qwidget.html#graphicsEffect">graphicsEffect</a>().</p>
<!-- @@@setGraphicsEffect -->
<!-- $$$setHidden[overload1]$$$setHiddenbool -->
<h3 class="fn" id="setHidden"><a name="setHidden"></a><code>[slot] </code><span class="type">void</span> QWidget::<span class="name">setHidden</span>(<span class="type">bool</span> <i>hidden</i>)</h3>
<p>Convenience function, equivalent to <a href="qwidget.html#visible-prop">setVisible</a>(!<i>hidden</i>).</p>
<p><b>请参考 </b><a href="qwidget.html#isHidden">isHidden</a>().</p>
<!-- @@@setHidden -->
<!-- $$$setLayout[overload1]$$$setLayoutQLayout* -->
<h3 class="fn" id="setLayout"><a name="setLayout"></a><span class="type">void</span> QWidget::<span class="name">setLayout</span>(<span class="type"><a href="qlayout.html">QLayout</a></span> *<i>layout</i>)</h3>
<p>Sets the layout manager for this widget to <i>layout</i>.</p>
<p>If there already is a layout manager installed on this widget, <a href="qwidget.html">QWidget</a> won't let you install another. You must first delete the existing layout manager (returned by <a href="qwidget.html#layout">layout</a>()) before you can call setLayout() with the new layout.</p>
<p>If <i>layout</i> is the layout manager on a different widget, setLayout() will reparent the layout and make it the layout manager for this widget.</p>
<p>Example:</p>
<pre class="cpp">

      <span class="type"><a href="qvboxlayout.html">QVBoxLayout</a></span> <span class="operator">*</span>layout <span class="operator">=</span> <span class="keyword">new</span> <span class="type"><a href="qvboxlayout.html">QVBoxLayout</a></span>;
      layout<span class="operator">-</span><span class="operator">&gt;</span>addWidget(formWidget);
      setLayout(layout);

</pre>
<p>An alternative to calling this function is to pass this widget to the layout's constructor.</p>
<p>The <a href="qwidget.html">QWidget</a> will take ownership of <i>layout</i>.</p>
<p><b>请参考 </b><a href="qwidget.html#layout">layout</a>() and <a href="layout.html">Layout Management</a>.</p>
<!-- @@@setLayout -->
<!-- $$$setMask[overload1]$$$setMaskconstQBitmap& -->
<h3 class="fn" id="setMask"><a name="setMask"></a><span class="type">void</span> QWidget::<span class="name">setMask</span>(const <span class="type"><a href="../qtgui/qbitmap.html">QBitmap</a></span> &amp;<i>bitmap</i>)</h3>
<p>Causes only the pixels of the widget for which <i>bitmap</i> has a corresponding 1 bit to be visible. If the region includes pixels outside the <a href="qwidget.html#rect-prop">rect</a>() of the widget, window system controls in that area may or may not be visible, depending on the platform.</p>
<p>Note that this effect can be slow if the region is particularly complex.</p>
<p>The following code shows how an image with an alpha channel can be used to generate a mask for a widget:</p>
<pre class="cpp">

      <span class="type"><a href="qlabel.html">QLabel</a></span> topLevelLabel;
      <span class="type"><a href="../qtgui/qpixmap.html">QPixmap</a></span> pixmap(<span class="string">&quot;:/images/tux.png&quot;</span>);
      topLevelLabel<span class="operator">.</span>setPixmap(pixmap);
      topLevelLabel<span class="operator">.</span>setMask(pixmap<span class="operator">.</span>mask());

</pre>
<p>The label shown by this code is masked using the image it contains, giving the appearance that an irregularly-shaped image is being drawn directly onto the screen.</p>
<p>Masked widgets receive mouse events only on their visible portions.</p>
<p><b>请参考 </b><a href="qwidget.html#mask">mask</a>(), <a href="qwidget.html#clearMask">clearMask</a>(), <a href="qwidget.html#windowOpacity-prop">windowOpacity</a>(), and <a href="qtwidgets-widgets-shapedclock-example.html">Shaped Clock Example</a>.</p>
<!-- @@@setMask -->
<!-- $$$setMask$$$setMaskconstQRegion& -->
<h3 class="fn" id="setMask-1"><a name="setMask-1"></a><span class="type">void</span> QWidget::<span class="name">setMask</span>(const <span class="type"><a href="../qtgui/qregion.html">QRegion</a></span> &amp;<i>region</i>)</h3>
<p>This is an overloaded function.</p>
<p>Causes only the parts of the widget which overlap <i>region</i> to be visible. If the region includes pixels outside the <a href="qwidget.html#rect-prop">rect</a>() of the widget, window system controls in that area may or may not be visible, depending on the platform.</p>
<p>Note that this effect can be slow if the region is particularly complex.</p>
<p><b>请参考 </b><a href="qwidget.html#windowOpacity-prop">windowOpacity</a>.</p>
<!-- @@@setMask -->
<!-- $$$setMaximumSize -->
<h3 class="fn" id="setMaximumSize-1"><a name="setMaximumSize-1"></a><span class="type">void</span> QWidget::<span class="name">setMaximumSize</span>(<span class="type">int</span> <i>maxw</i>, <span class="type">int</span> <i>maxh</i>)</h3>
<p>This is an overloaded function.</p>
<p>This function corresponds to <a href="qwidget.html#maximumSize-prop">setMaximumSize</a>(<a href="../qtcore/qsize.html">QSize</a>(<i>maxw</i>, <i>maxh</i>)). Sets the maximum width to <i>maxw</i> and the maximum height to <i>maxh</i>.</p>
<p><b>Note:</b> Setter function for property <a href="qwidget.html#maximumSize-prop">maximumSize</a>. </p><!-- @@@setMaximumSize -->
<!-- $$$setMinimumSize -->
<h3 class="fn" id="setMinimumSize-1"><a name="setMinimumSize-1"></a><span class="type">void</span> QWidget::<span class="name">setMinimumSize</span>(<span class="type">int</span> <i>minw</i>, <span class="type">int</span> <i>minh</i>)</h3>
<p>This is an overloaded function.</p>
<p>This function corresponds to <a href="qwidget.html#minimumSize-prop">setMinimumSize</a>(<a href="../qtcore/qsize.html">QSize</a>(minw, minh)). Sets the minimum width to <i>minw</i> and the minimum height to <i>minh</i>.</p>
<p><b>Note:</b> Setter function for property <a href="qwidget.html#minimumSize-prop">minimumSize</a>. </p><!-- @@@setMinimumSize -->
<!-- $$$setParent[overload1]$$$setParentQWidget* -->
<h3 class="fn" id="setParent"><a name="setParent"></a><span class="type">void</span> QWidget::<span class="name">setParent</span>(<span class="type"><a href="qwidget.html#QWidget">QWidget</a></span> *<i>parent</i>)</h3>
<p>Sets the parent of the widget to <i>parent</i>, and resets the window flags. The widget is moved to position (0, 0) in its new parent.</p>
<p>If the new parent widget is in a different window, the reparented widget and its children are appended to the end of the <a href="qwidget.html#focusPolicy-prop">tab chain</a> of the new parent widget, in the same internal order as before. If one of the moved widgets had keyboard focus, setParent() calls <a href="qwidget.html#clearFocus">clearFocus</a>() for that widget.</p>
<p>If the new parent widget is in the same window as the old parent, setting the parent doesn't change the tab order or keyboard focus.</p>
<p>If the &quot;new&quot; parent widget is the old parent widget, this function does nothing.</p>
<p><b>Note: </b>The widget becomes invisible as part of changing its parent, even if it was previously visible. You must call <a href="qwidget.html#show">show</a>() to make the widget visible again.</p><p><b>Warning:</b> It is very unlikely that you will ever need this function. If you have a widget that changes its content dynamically, it is far easier to use <a href="qstackedwidget.html">QStackedWidget</a>.</p>
<p><b>请参考 </b><a href="qwidget.html#windowFlags-prop">setWindowFlags</a>().</p>
<!-- @@@setParent -->
<!-- $$$setParent$$$setParentQWidget*Qt::WindowFlags -->
<h3 class="fn" id="setParent-1"><a name="setParent-1"></a><span class="type">void</span> QWidget::<span class="name">setParent</span>(<span class="type"><a href="qwidget.html#QWidget">QWidget</a></span> *<i>parent</i>, <span class="type"><a href="../qtcore/qt.html#WindowType-enum">Qt::WindowFlags</a></span> <i>f</i>)</h3>
<p>This is an overloaded function.</p>
<p>This function also takes widget flags, <i>f</i> as an argument.</p>
<!-- @@@setParent -->
<!-- $$$setShortcutAutoRepeat[overload1]$$$setShortcutAutoRepeatintbool -->
<h3 class="fn" id="setShortcutAutoRepeat"><a name="setShortcutAutoRepeat"></a><span class="type">void</span> QWidget::<span class="name">setShortcutAutoRepeat</span>(<span class="type">int</span> <i>id</i>, <span class="type">bool</span> <i>enable</i> = true)</h3>
<p>If <i>enable</i> is true, auto repeat of the shortcut with the given <i>id</i> is enabled; otherwise it is disabled.</p>
<p>This function was introduced in  Qt 4.2.</p>
<p><b>请参考 </b><a href="qwidget.html#grabShortcut">grabShortcut</a>() and <a href="qwidget.html#releaseShortcut">releaseShortcut</a>().</p>
<!-- @@@setShortcutAutoRepeat -->
<!-- $$$setShortcutEnabled[overload1]$$$setShortcutEnabledintbool -->
<h3 class="fn" id="setShortcutEnabled"><a name="setShortcutEnabled"></a><span class="type">void</span> QWidget::<span class="name">setShortcutEnabled</span>(<span class="type">int</span> <i>id</i>, <span class="type">bool</span> <i>enable</i> = true)</h3>
<p>If <i>enable</i> is true, the shortcut with the given <i>id</i> is enabled; otherwise the shortcut is disabled.</p>
<p><b>Warning:</b> You should not normally need to use this function since Qt's shortcut system enables/disables shortcuts automatically as widgets become hidden/visible and gain or lose focus. It is best to use <a href="qaction.html">QAction</a> or <a href="qshortcut.html">QShortcut</a> to handle shortcuts, since they are easier to use than this low-level function.</p>
<p><b>请参考 </b><a href="qwidget.html#grabShortcut">grabShortcut</a>() and <a href="qwidget.html#releaseShortcut">releaseShortcut</a>().</p>
<!-- @@@setShortcutEnabled -->
<!-- $$$setSizeIncrement -->
<h3 class="fn" id="setSizeIncrement-1"><a name="setSizeIncrement-1"></a><span class="type">void</span> QWidget::<span class="name">setSizeIncrement</span>(<span class="type">int</span> <i>w</i>, <span class="type">int</span> <i>h</i>)</h3>
<p>This is an overloaded function.</p>
<p>Sets the x (width) size increment to <i>w</i> and the y (height) size increment to <i>h</i>.</p>
<p><b>Note:</b> Setter function for property <a href="qwidget.html#sizeIncrement-prop">sizeIncrement</a>. </p><!-- @@@setSizeIncrement -->
<!-- $$$setSizePolicy -->
<h3 class="fn" id="setSizePolicy-1"><a name="setSizePolicy-1"></a><span class="type">void</span> QWidget::<span class="name">setSizePolicy</span>(<span class="type"><a href="qsizepolicy.html#Policy-enum">QSizePolicy::Policy</a></span> <i>horizontal</i>, <span class="type"><a href="qsizepolicy.html#Policy-enum">QSizePolicy::Policy</a></span> <i>vertical</i>)</h3>
<p>This is an overloaded function.</p>
<p>Sets the size policy of the widget to <i>horizontal</i> and <i>vertical</i>, with standard stretch and no height-for-width.</p>
<p><b>Note:</b> Setter function for property <a href="qwidget.html#sizePolicy-prop">sizePolicy</a>. </p><p><b>请参考 </b><a href="qsizepolicy.html#QSizePolicy">QSizePolicy::QSizePolicy</a>().</p>
<!-- @@@setSizePolicy -->
<!-- $$$setStyle[overload1]$$$setStyleQStyle* -->
<h3 class="fn" id="setStyle"><a name="setStyle"></a><span class="type">void</span> QWidget::<span class="name">setStyle</span>(<span class="type"><a href="qstyle.html">QStyle</a></span> *<i>style</i>)</h3>
<p>Sets the widget's GUI style to <i>style</i>. The ownership of the style object is not transferred.</p>
<p>If no style is set, the widget uses the application's style, <a href="qapplication.html#style">QApplication::style</a>() instead.</p>
<p>Setting a widget's style has no effect on existing or future child widgets.</p>
<p><b>Warning:</b> This function is particularly useful for demonstration purposes, where you want to show Qt's styling capabilities. Real applications should avoid it and use one consistent GUI style instead.</p>
<p><b>Warning:</b> Qt style sheets are currently not supported for custom <a href="qstyle.html">QStyle</a> subclasses. We plan to address this in some future release.</p>
<p><b>请参考 </b><a href="qwidget.html#style">style</a>(), <a href="qstyle.html">QStyle</a>, <a href="qapplication.html#style">QApplication::style</a>(), and <a href="qapplication.html#setStyle">QApplication::setStyle</a>().</p>
<!-- @@@setStyle -->
<!-- $$$setTabOrder[overload1]$$$setTabOrderQWidget*QWidget* -->
<h3 class="fn" id="setTabOrder"><a name="setTabOrder"></a><code>[static] </code><span class="type">void</span> QWidget::<span class="name">setTabOrder</span>(<span class="type"><a href="qwidget.html#QWidget">QWidget</a></span> *<i>first</i>, <span class="type"><a href="qwidget.html#QWidget">QWidget</a></span> *<i>second</i>)</h3>
<p>Puts the <i>second</i> widget after the <i>first</i> widget in the focus order.</p>
<p>It effectively removes the <i>second</i> widget from its focus chain and inserts it after the <i>first</i> widget.</p>
<p>Note that since the tab order of the <i>second</i> widget is changed, you should order a chain like this:</p>
<pre class="cpp">

  setTabOrder(a<span class="operator">,</span> b); <span class="comment">// a to b</span>
  setTabOrder(b<span class="operator">,</span> c); <span class="comment">// a to b to c</span>
  setTabOrder(c<span class="operator">,</span> d); <span class="comment">// a to b to c to d</span>

</pre>
<p><i>not</i> like this:</p>
<pre class="cpp">

  <span class="comment">// WRONG</span>
  setTabOrder(c<span class="operator">,</span> d); <span class="comment">// c to d</span>
  setTabOrder(a<span class="operator">,</span> b); <span class="comment">// a to b AND c to d</span>
  setTabOrder(b<span class="operator">,</span> c); <span class="comment">// a to b to c, but not c to d</span>

</pre>
<p>If <i>first</i> or <i>second</i> has a focus proxy, setTabOrder() correctly substitutes the proxy.</p>
<p><b>Note: </b>Since Qt 5.10: A widget that has a child as focus proxy is understood as a compound widget. When setting a tab order between one or two compound widgets, the local tab order inside each will be preserved. This means that if both widgets are compound widgets, the resulting tab order will be from the last child inside <i>first</i>, to the first child inside <i>second</i>.</p><p><b>请参考 </b><a href="qwidget.html#focusPolicy-prop">setFocusPolicy</a>(), <a href="qwidget.html#setFocusProxy">setFocusProxy</a>(), and <a href="focus.html">Keyboard Focus in Widgets</a>.</p>
<!-- @@@setTabOrder -->
<!-- $$$setWindowFlag[overload1]$$$setWindowFlagQt::WindowTypebool -->
<h3 class="fn" id="setWindowFlag"><a name="setWindowFlag"></a><span class="type">void</span> QWidget::<span class="name">setWindowFlag</span>(<span class="type"><a href="../qtcore/qt.html#WindowType-enum">Qt::WindowType</a></span> <i>flag</i>, <span class="type">bool</span> <i>on</i> = true)</h3>
<p>Sets the window flag <i>flag</i> on this widget if <i>on</i> is true; otherwise clears the flag.</p>
<p>This function was introduced in  Qt 5.9.</p>
<p><b>请参考 </b><a href="qwidget.html#windowFlags-prop">setWindowFlags</a>(), <a href="qwidget.html#windowFlags-prop">windowFlags</a>(), and <a href="qwidget.html#windowType">windowType</a>().</p>
<!-- @@@setWindowFlag -->
<!-- $$$setWindowRole[overload1]$$$setWindowRoleconstQString& -->
<h3 class="fn" id="setWindowRole"><a name="setWindowRole"></a><span class="type">void</span> QWidget::<span class="name">setWindowRole</span>(const <span class="type"><a href="../qtcore/qstring.html">QString</a></span> &amp;<i>role</i>)</h3>
<p>Sets the window's role to <i>role</i>. This only makes sense for windows on X11.</p>
<p><b>请参考 </b><a href="qwidget.html#windowRole">windowRole</a>().</p>
<!-- @@@setWindowRole -->
<!-- $$$setWindowState[overload1]$$$setWindowStateQt::WindowStates -->
<h3 class="fn" id="setWindowState"><a name="setWindowState"></a><span class="type">void</span> QWidget::<span class="name">setWindowState</span>(<span class="type"><a href="../qtcore/qt.html#WindowState-enum">Qt::WindowStates</a></span> <i>windowState</i>)</h3>
<p>Sets the window state to <i>windowState</i>. The window state is a OR'ed combination of <a href="../qtcore/qt.html#WindowState-enum">Qt::WindowState</a>: <a href="../qtcore/qt.html#WindowState-enum">Qt::WindowMinimized</a>, <a href="../qtcore/qt.html#WindowState-enum">Qt::WindowMaximized</a>, <a href="../qtcore/qt.html#WindowState-enum">Qt::WindowFullScreen</a>, and <a href="../qtcore/qt.html#WindowState-enum">Qt::WindowActive</a>.</p>
<p>If the window is not visible (i.e&#x2e; <a href="qwidget.html#visible-prop">isVisible</a>() returns <code>false</code>), the window state will take effect when <a href="qwidget.html#show">show</a>() is called. For visible windows, the change is immediate. For example, to toggle between full-screen and normal mode, use the following code:</p>
<pre class="cpp">

  w<span class="operator">-</span><span class="operator">&gt;</span>setWindowState(w<span class="operator">-</span><span class="operator">&gt;</span>windowState() <span class="operator">^</span> <span class="type">Qt</span><span class="operator">::</span>WindowFullScreen);

</pre>
<p>In order to restore and activate a minimized window (while preserving its maximized and/or full-screen state), use the following:</p>
<pre class="cpp">

  w<span class="operator">-</span><span class="operator">&gt;</span>setWindowState((w<span class="operator">-</span><span class="operator">&gt;</span>windowState() <span class="operator">&amp;</span> <span class="operator">~</span><span class="type">Qt</span><span class="operator">::</span>WindowMinimized) <span class="operator">|</span> <span class="type">Qt</span><span class="operator">::</span>WindowActive);

</pre>
<p>Calling this function will hide the widget. You must call <a href="qwidget.html#show">show</a>() to make the widget visible again.</p>
<p><b>Note: </b>On some window systems <a href="../qtcore/qt.html#WindowState-enum">Qt::WindowActive</a> is not immediate, and may be ignored in certain cases.</p><p>When the window state changes, the widget receives a <a href="qwidget.html#changeEvent">changeEvent</a>() of type <a href="../qtcore/qevent.html#Type-enum">QEvent::WindowStateChange</a>.</p>
<p><b>请参考 </b><a href="../qtcore/qt.html#WindowState-enum">Qt::WindowState</a> and <a href="qwidget.html#windowState">windowState</a>().</p>
<!-- @@@setWindowState -->
<!-- $$$setupUi[overload1]$$$setupUiQWidget* -->
<h3 class="fn" id="setupUi"><a name="setupUi"></a><span class="type">void</span> QWidget::<span class="name">setupUi</span>(<span class="type"><a href="qwidget.html#QWidget">QWidget</a></span> *<i>widget</i>)</h3>
<p>Sets up the user interface for the specified <i>widget</i>.</p>
<p><b>Note: </b>This function is available with widgets that derive from user interface descriptions created using <a href="../qtdoc/uic.html">uic</a>.</p><p><b>请参考 </b><a href="../qtdesigner/designer-using-a-ui-file.html">Using a Designer UI File in Your Application</a>.</p>
<!-- @@@setupUi -->
<!-- $$$show[overload1]$$$show -->
<h3 class="fn" id="show"><a name="show"></a><code>[slot] </code><span class="type">void</span> QWidget::<span class="name">show</span>()</h3>
<p>Shows the widget and its child widgets.</p>
<p>This is equivalent to calling <a href="qwidget.html#showFullScreen">showFullScreen</a>(), <a href="qwidget.html#showMaximized">showMaximized</a>(), or <a href="qwidget.html#visible-prop">setVisible</a>(true), depending on the platform's default behavior for the window flags.</p>
<p><b>请参考 </b><a href="qwidget.html#raise">raise</a>(), <a href="qwidget.html#showEvent">showEvent</a>(), <a href="qwidget.html#hide">hide</a>(), <a href="qwidget.html#visible-prop">setVisible</a>(), <a href="qwidget.html#showMinimized">showMinimized</a>(), <a href="qwidget.html#showMaximized">showMaximized</a>(), <a href="qwidget.html#showNormal">showNormal</a>(), <a href="qwidget.html#visible-prop">isVisible</a>(), and <a href="qwidget.html#windowFlags-prop">windowFlags</a>().</p>
<!-- @@@show -->
<!-- $$$showEvent[overload1]$$$showEventQShowEvent* -->
<h3 class="fn" id="showEvent"><a name="showEvent"></a><code>[virtual protected] </code><span class="type">void</span> QWidget::<span class="name">showEvent</span>(<span class="type"><a href="../qtgui/qshowevent.html">QShowEvent</a></span> *<i>event</i>)</h3>
<p>This event handler can be reimplemented in a subclass to receive widget show events which are passed in the <i>event</i> parameter.</p>
<p>Non-spontaneous show events are sent to widgets immediately before they are shown. The spontaneous show events of windows are delivered afterwards.</p>
<p>Note: A widget receives spontaneous show and hide events when its mapping status is changed by the window system, e.g&#x2e; a spontaneous hide event when the user minimizes the window, and a spontaneous show event when the window is restored again. After receiving a spontaneous hide event, a widget is still considered visible in the sense of <a href="qwidget.html#visible-prop">isVisible</a>().</p>
<p><b>请参考 </b><a href="qwidget.html#visible-prop">visible</a>, <a href="qwidget.html#event">event</a>(), and <a href="../qtgui/qshowevent.html">QShowEvent</a>.</p>
<!-- @@@showEvent -->
<!-- $$$showFullScreen[overload1]$$$showFullScreen -->
<h3 class="fn" id="showFullScreen"><a name="showFullScreen"></a><code>[slot] </code><span class="type">void</span> QWidget::<span class="name">showFullScreen</span>()</h3>
<p>Shows the widget in full-screen mode.</p>
<p>Calling this function only affects <a href="qwidget.html#isWindow">windows</a>.</p>
<p>To return from full-screen mode, call <a href="qwidget.html#showNormal">showNormal</a>().</p>
<p>Full-screen mode works fine under Windows, but has certain problems under X. These problems are due to limitations of the ICCCM protocol that specifies the communication between X11 clients and the window manager. ICCCM simply does not understand the concept of non-decorated full-screen windows. Therefore, the best we can do is to request a borderless window and place and resize it to fill the entire screen. Depending on the window manager, this may or may not work. The borderless window is requested using MOTIF hints, which are at least partially supported by virtually all modern window managers.</p>
<p>An alternative would be to bypass the window manager entirely and create a window with the <a href="../qtcore/qt.html#WindowType-enum">Qt::X11BypassWindowManagerHint</a> flag. This has other severe problems though, like totally broken keyboard focus and very strange effects on desktop changes or when the user raises other windows.</p>
<p>X11 window managers that follow modern post-ICCCM specifications support full-screen mode properly.</p>
<p><b>请参考 </b><a href="qwidget.html#showNormal">showNormal</a>(), <a href="qwidget.html#showMaximized">showMaximized</a>(), <a href="qwidget.html#show">show</a>(), <a href="qwidget.html#hide">hide</a>(), and <a href="qwidget.html#visible-prop">isVisible</a>().</p>
<!-- @@@showFullScreen -->
<!-- $$$showMaximized[overload1]$$$showMaximized -->
<h3 class="fn" id="showMaximized"><a name="showMaximized"></a><code>[slot] </code><span class="type">void</span> QWidget::<span class="name">showMaximized</span>()</h3>
<p>Shows the widget maximized.</p>
<p>Calling this function only affects <a href="qwidget.html#isWindow">windows</a>.</p>
<p>On X11, this function may not work properly with certain window managers. See the <a href="application-windows.html#window-geometry">Window Geometry</a> documentation for an explanation.</p>
<p><b>请参考 </b><a href="qwidget.html#setWindowState">setWindowState</a>(), <a href="qwidget.html#showNormal">showNormal</a>(), <a href="qwidget.html#showMinimized">showMinimized</a>(), <a href="qwidget.html#show">show</a>(), <a href="qwidget.html#hide">hide</a>(), and <a href="qwidget.html#visible-prop">isVisible</a>().</p>
<!-- @@@showMaximized -->
<!-- $$$showMinimized[overload1]$$$showMinimized -->
<h3 class="fn" id="showMinimized"><a name="showMinimized"></a><code>[slot] </code><span class="type">void</span> QWidget::<span class="name">showMinimized</span>()</h3>
<p>Shows the widget minimized, as an icon.</p>
<p>Calling this function only affects <a href="qwidget.html#isWindow">windows</a>.</p>
<p><b>请参考 </b><a href="qwidget.html#showNormal">showNormal</a>(), <a href="qwidget.html#showMaximized">showMaximized</a>(), <a href="qwidget.html#show">show</a>(), <a href="qwidget.html#hide">hide</a>(), <a href="qwidget.html#visible-prop">isVisible</a>(), and <a href="qwidget.html#minimized-prop">isMinimized</a>().</p>
<!-- @@@showMinimized -->
<!-- $$$showNormal[overload1]$$$showNormal -->
<h3 class="fn" id="showNormal"><a name="showNormal"></a><code>[slot] </code><span class="type">void</span> QWidget::<span class="name">showNormal</span>()</h3>
<p>Restores the widget after it has been maximized or minimized.</p>
<p>Calling this function only affects <a href="qwidget.html#isWindow">windows</a>.</p>
<p><b>请参考 </b><a href="qwidget.html#setWindowState">setWindowState</a>(), <a href="qwidget.html#showMinimized">showMinimized</a>(), <a href="qwidget.html#showMaximized">showMaximized</a>(), <a href="qwidget.html#show">show</a>(), <a href="qwidget.html#hide">hide</a>(), and <a href="qwidget.html#visible-prop">isVisible</a>().</p>
<!-- @@@showNormal -->
<!-- $$$stackUnder[overload1]$$$stackUnderQWidget* -->
<h3 class="fn" id="stackUnder"><a name="stackUnder"></a><span class="type">void</span> QWidget::<span class="name">stackUnder</span>(<span class="type"><a href="qwidget.html#QWidget">QWidget</a></span> *<i>w</i>)</h3>
<p>Places the widget under <i>w</i> in the parent widget's stack.</p>
<p>To make this work, the widget itself and <i>w</i> must be siblings.</p>
<p><b>请参考 </b><a href="qwidget.html#raise">raise</a>() and <a href="qwidget.html#lower">lower</a>().</p>
<!-- @@@stackUnder -->
<!-- $$$style[overload1]$$$style -->
<h3 class="fn" id="style"><a name="style"></a><span class="type"><a href="qstyle.html">QStyle</a></span> *QWidget::<span class="name">style</span>() const</h3>
<p><b>请参考 </b><a href="qwidget.html#setStyle">QWidget::setStyle</a>(), <a href="qapplication.html#setStyle">QApplication::setStyle</a>(), and <a href="qapplication.html#style">QApplication::style</a>().</p>
<!-- @@@style -->
<!-- $$$tabletEvent[overload1]$$$tabletEventQTabletEvent* -->
<h3 class="fn" id="tabletEvent"><a name="tabletEvent"></a><code>[virtual protected] </code><span class="type">void</span> QWidget::<span class="name">tabletEvent</span>(<span class="type"><a href="../qtgui/qtabletevent.html">QTabletEvent</a></span> *<i>event</i>)</h3>
<p>This event handler, for event <i>event</i>, can be reimplemented in a subclass to receive tablet events for the widget.</p>
<p>If you reimplement this handler, it is very important that you <a href="../qtcore/qevent.html">ignore()</a> the event if you do not handle it, so that the widget's parent can interpret it.</p>
<p>The default implementation ignores the event.</p>
<p>If tablet tracking is switched off, tablet move events only occur if the stylus is in contact with the tablet, or at least one stylus button is pressed, while the stylus is being moved. If tablet tracking is switched on, tablet move events occur even while the stylus is hovering in proximity of the tablet, with no buttons pressed.</p>
<p><b>请参考 </b><a href="../qtcore/qevent.html#ignore">QEvent::ignore</a>(), <a href="../qtcore/qevent.html#accept">QEvent::accept</a>(), <a href="qwidget.html#event">event</a>(), <a href="qwidget.html#tabletTracking-prop">setTabletTracking</a>(), and <a href="../qtgui/qtabletevent.html">QTabletEvent</a>.</p>
<!-- @@@tabletEvent -->
<!-- $$$testAttribute[overload1]$$$testAttributeQt::WidgetAttribute -->
<h3 class="fn" id="testAttribute"><a name="testAttribute"></a><span class="type">bool</span> QWidget::<span class="name">testAttribute</span>(<span class="type"><a href="../qtcore/qt.html#WidgetAttribute-enum">Qt::WidgetAttribute</a></span> <i>attribute</i>) const</h3>
<p>Returns <code>true</code> if attribute <i>attribute</i> is set on this widget; otherwise returns <code>false</code>.</p>
<p><b>请参考 </b><a href="qwidget.html#setAttribute">setAttribute</a>().</p>
<!-- @@@testAttribute -->
<!-- $$$underMouse[overload1]$$$underMouse -->
<h3 class="fn" id="underMouse"><a name="underMouse"></a><span class="type">bool</span> QWidget::<span class="name">underMouse</span>() const</h3>
<p>Returns <code>true</code> if the widget is under the mouse cursor; otherwise returns <code>false</code>.</p>
<p>This value is not updated properly during drag and drop operations.</p>
<p><b>请参考 </b><a href="qwidget.html#enterEvent">enterEvent</a>() and <a href="qwidget.html#leaveEvent">leaveEvent</a>().</p>
<!-- @@@underMouse -->
<!-- $$$ungrabGesture[overload1]$$$ungrabGestureQt::GestureType -->
<h3 class="fn" id="ungrabGesture"><a name="ungrabGesture"></a><span class="type">void</span> QWidget::<span class="name">ungrabGesture</span>(<span class="type"><a href="../qtcore/qt.html#GestureType-enum">Qt::GestureType</a></span> <i>gesture</i>)</h3>
<p>Unsubscribes the widget from a given <i>gesture</i> type</p>
<p>This function was introduced in  Qt 4.6.</p>
<p><b>请参考 </b><a href="qwidget.html#grabGesture">grabGesture</a>() and <a href="qgestureevent.html">QGestureEvent</a>.</p>
<!-- @@@ungrabGesture -->
<!-- $$$update[overload1]$$$update -->
<h3 class="fn" id="update"><a name="update"></a><code>[slot] </code><span class="type">void</span> QWidget::<span class="name">update</span>()</h3>
<p>Updates the widget unless updates are disabled or the widget is hidden.</p>
<p>This function does not cause an immediate repaint; instead it schedules a paint event for processing when Qt returns to the main event loop. This permits Qt to optimize for more speed and less flicker than a call to <a href="qwidget.html#repaint">repaint</a>() does.</p>
<p>Calling update() several times normally results in just one <a href="qwidget.html#paintEvent">paintEvent</a>() call.</p>
<p>Qt normally erases the widget's area before the <a href="qwidget.html#paintEvent">paintEvent</a>() call. If the <a href="../qtcore/qt.html#WidgetAttribute-enum">Qt::WA_OpaquePaintEvent</a> widget attribute is set, the widget is responsible for painting all its pixels with an opaque color.</p>
<p><b>请参考 </b><a href="qwidget.html#repaint">repaint</a>(), <a href="qwidget.html#paintEvent">paintEvent</a>(), <a href="qwidget.html#updatesEnabled-prop">setUpdatesEnabled</a>(), and <a href="qtwidgets-widgets-analogclock-example.html">Analog Clock Example</a>.</p>
<!-- @@@update -->
<!-- $$$update$$$updateintintintint -->
<h3 class="fn" id="update-1"><a name="update-1"></a><span class="type">void</span> QWidget::<span class="name">update</span>(<span class="type">int</span> <i>x</i>, <span class="type">int</span> <i>y</i>, <span class="type">int</span> <i>w</i>, <span class="type">int</span> <i>h</i>)</h3>
<p>This is an overloaded function.</p>
<p>This version updates a rectangle (<i>x</i>, <i>y</i>, <i>w</i>, <i>h</i>) inside the widget.</p>
<!-- @@@update -->
<!-- $$$update$$$updateconstQRect& -->
<h3 class="fn" id="update-2"><a name="update-2"></a><span class="type">void</span> QWidget::<span class="name">update</span>(const <span class="type"><a href="../qtcore/qrect.html">QRect</a></span> &amp;<i>rect</i>)</h3>
<p>This is an overloaded function.</p>
<p>This version updates a rectangle <i>rect</i> inside the widget.</p>
<!-- @@@update -->
<!-- $$$update$$$updateconstQRegion& -->
<h3 class="fn" id="update-3"><a name="update-3"></a><span class="type">void</span> QWidget::<span class="name">update</span>(const <span class="type"><a href="../qtgui/qregion.html">QRegion</a></span> &amp;<i>rgn</i>)</h3>
<p>This is an overloaded function.</p>
<p>This version repaints a region <i>rgn</i> inside the widget.</p>
<!-- @@@update -->
<!-- $$$updateGeometry[overload1]$$$updateGeometry -->
<h3 class="fn" id="updateGeometry"><a name="updateGeometry"></a><span class="type">void</span> QWidget::<span class="name">updateGeometry</span>()</h3>
<p>Notifies the layout system that this widget has changed and may need to change geometry.</p>
<p>Call this function if the <a href="qwidget.html#sizeHint-prop">sizeHint</a>() or <a href="qwidget.html#sizePolicy-prop">sizePolicy</a>() have changed.</p>
<p>For explicitly hidden widgets, updateGeometry() is a no-op. The layout system will be notified as soon as the widget is shown.</p>
<!-- @@@updateGeometry -->
<!-- $$$updateMicroFocus[overload1]$$$updateMicroFocus -->
<h3 class="fn" id="updateMicroFocus"><a name="updateMicroFocus"></a><code>[protected slot] </code><span class="type">void</span> QWidget::<span class="name">updateMicroFocus</span>()</h3>
<p>Updates the widget's micro focus.</p>
<!-- @@@updateMicroFocus -->
<!-- $$$visibleRegion[overload1]$$$visibleRegion -->
<h3 class="fn" id="visibleRegion"><a name="visibleRegion"></a><span class="type"><a href="../qtgui/qregion.html">QRegion</a></span> QWidget::<span class="name">visibleRegion</span>() const</h3>
<p>Returns the unobscured region where paint events can occur.</p>
<p>For visible widgets, this is an approximation of the area not covered by other widgets; otherwise, this is an empty region.</p>
<p>The <a href="qwidget.html#repaint">repaint</a>() function calls this function if necessary, so in general you do not need to call it.</p>
<!-- @@@visibleRegion -->
<!-- $$$wheelEvent[overload1]$$$wheelEventQWheelEvent* -->
<h3 class="fn" id="wheelEvent"><a name="wheelEvent"></a><code>[virtual protected] </code><span class="type">void</span> QWidget::<span class="name">wheelEvent</span>(<span class="type"><a href="../qtgui/qwheelevent.html">QWheelEvent</a></span> *<i>event</i>)</h3>
<p>This event handler, for event <i>event</i>, can be reimplemented in a subclass to receive wheel events for the widget.</p>
<p>If you reimplement this handler, it is very important that you <a href="../qtcore/qevent.html">ignore()</a> the event if you do not handle it, so that the widget's parent can interpret it.</p>
<p>The default implementation ignores the event.</p>
<p><b>请参考 </b><a href="../qtcore/qevent.html#ignore">QEvent::ignore</a>(), <a href="../qtcore/qevent.html#accept">QEvent::accept</a>(), <a href="qwidget.html#event">event</a>(), and <a href="../qtgui/qwheelevent.html">QWheelEvent</a>.</p>
<!-- @@@wheelEvent -->
<!-- $$$winId[overload1]$$$winId -->
<h3 class="fn" id="winId"><a name="winId"></a><span class="type">WId</span> QWidget::<span class="name">winId</span>() const</h3>
<p>Returns the window system identifier of the widget.</p>
<p>Portable in principle, but if you use it you are probably about to do something non-portable. Be careful.</p>
<p>If a widget is non-native (alien) and winId() is invoked on it, that widget will be provided a native handle.</p>
<p>This value may change at run-time. An event with type <a href="../qtcore/qevent.html#Type-enum">QEvent::WinIdChange</a> will be sent to the widget following a change in window system identifier.</p>
<p><b>请参考 </b><a href="qwidget.html#find">find</a>().</p>
<!-- @@@winId -->
<!-- $$$window[overload1]$$$window -->
<h3 class="fn" id="window"><a name="window"></a><span class="type"><a href="qwidget.html#QWidget">QWidget</a></span> *QWidget::<span class="name">window</span>() const</h3>
<p>Returns the window for this widget, i.e&#x2e; the next ancestor widget that has (or could have) a window-system frame.</p>
<p>If the widget is a window, the widget itself is returned.</p>
<p>Typical usage is changing the window title:</p>
<pre class="cpp">

  aWidget<span class="operator">-</span><span class="operator">&gt;</span>window()<span class="operator">-</span><span class="operator">&gt;</span>setWindowTitle(<span class="string">&quot;New Window Title&quot;</span>);

</pre>
<p><b>请参考 </b><a href="qwidget.html#isWindow">isWindow</a>().</p>
<!-- @@@window -->
<!-- $$$windowHandle[overload1]$$$windowHandle -->
<h3 class="fn" id="windowHandle"><a name="windowHandle"></a><span class="type"><a href="../qtgui/qwindow.html">QWindow</a></span> *QWidget::<span class="name">windowHandle</span>() const</h3>
<p>If this is a native widget, return the associated <a href="../qtgui/qwindow.html">QWindow</a>. Otherwise return null.</p>
<p>Native widgets include toplevel widgets, QGLWidget, and child widgets on which <a href="qwidget.html#winId">winId</a>() was called.</p>
<p>This function was introduced in  Qt 5.0.</p>
<p><b>请参考 </b><a href="qwidget.html#winId">winId</a>().</p>
<!-- @@@windowHandle -->
<!-- $$$windowIconChanged -->
<h3 class="fn" id="windowIconChanged"><a name="windowIconChanged"></a><code>[signal] </code><span class="type">void</span> QWidget::<span class="name">windowIconChanged</span>(const <span class="type"><a href="../qtgui/qicon.html">QIcon</a></span> &amp;<i>icon</i>)</h3>
<p>This signal is emitted when the window's icon has changed, with the new <i>icon</i> as an argument.</p>
<p>This function was introduced in  Qt 5.2.</p>
<p><b>Note:</b> Notifier signal for property <a href="qwidget.html#windowIcon-prop">windowIcon</a>. </p><!-- @@@windowIconChanged -->
<!-- $$$windowRole[overload1]$$$windowRole -->
<h3 class="fn" id="windowRole"><a name="windowRole"></a><span class="type"><a href="../qtcore/qstring.html">QString</a></span> QWidget::<span class="name">windowRole</span>() const</h3>
<p>Returns the window's role, or an empty string.</p>
<p><b>请参考 </b><a href="qwidget.html#setWindowRole">setWindowRole</a>(), <a href="qwidget.html#windowIcon-prop">windowIcon</a>, and <a href="qwidget.html#windowTitle-prop">windowTitle</a>.</p>
<!-- @@@windowRole -->
<!-- $$$windowState[overload1]$$$windowState -->
<h3 class="fn" id="windowState"><a name="windowState"></a><span class="type"><a href="../qtcore/qt.html#WindowState-enum">Qt::WindowStates</a></span> QWidget::<span class="name">windowState</span>() const</h3>
<p>Returns the current window state. The window state is a OR'ed combination of <a href="../qtcore/qt.html#WindowState-enum">Qt::WindowState</a>: <a href="../qtcore/qt.html#WindowState-enum">Qt::WindowMinimized</a>, <a href="../qtcore/qt.html#WindowState-enum">Qt::WindowMaximized</a>, <a href="../qtcore/qt.html#WindowState-enum">Qt::WindowFullScreen</a>, and <a href="../qtcore/qt.html#WindowState-enum">Qt::WindowActive</a>.</p>
<p><b>请参考 </b><a href="../qtcore/qt.html#WindowState-enum">Qt::WindowState</a> and <a href="qwidget.html#setWindowState">setWindowState</a>().</p>
<!-- @@@windowState -->
<!-- $$$windowTitleChanged -->
<h3 class="fn" id="windowTitleChanged"><a name="windowTitleChanged"></a><code>[signal] </code><span class="type">void</span> QWidget::<span class="name">windowTitleChanged</span>(const <span class="type"><a href="../qtcore/qstring.html">QString</a></span> &amp;<i>title</i>)</h3>
<p>This signal is emitted when the window's title has changed, with the new <i>title</i> as an argument.</p>
<p>This function was introduced in  Qt 5.2.</p>
<p><b>Note:</b> Notifier signal for property <a href="qwidget.html#windowTitle-prop">windowTitle</a>. </p><!-- @@@windowTitleChanged -->
<!-- $$$windowType[overload1]$$$windowType -->
<h3 class="fn" id="windowType"><a name="windowType"></a><span class="type"><a href="../qtcore/qt.html#WindowType-enum">Qt::WindowType</a></span> QWidget::<span class="name">windowType</span>() const</h3>
<p>Returns the window type of this widget. This is identical to <a href="qwidget.html#windowFlags-prop">windowFlags</a>() &amp; <a href="../qtcore/qt.html#WindowType-enum">Qt::WindowType_Mask</a>.</p>
<p><b>请参考 </b><a href="qwidget.html#windowFlags-prop">windowFlags</a>.</p>
<!-- @@@windowType -->
</div>
<div class="macros">
<h2>Macro Documentation</h2>
<!-- $$$QWIDGETSIZE_MAX[overload1]$$$QWIDGETSIZE_MAX -->
<h3 class="fn" id="QWIDGETSIZE_MAX"><a name="QWIDGETSIZE_MAX"></a><span class="name">QWIDGETSIZE_MAX</span></h3>
<p>Defines the maximum size for a <a href="qwidget.html">QWidget</a> object.</p>
<p>The largest allowed size for a widget is <a href="../qtcore/qsize.html">QSize</a>(QWIDGETSIZE_MAX, QWIDGETSIZE_MAX), i.e&#x2e; <a href="../qtcore/qsize.html">QSize</a> (16777215,16777215).</p>
<p><b>请参考 </b><a href="qwidget.html#maximumSize-prop">QWidget::setMaximumSize</a>().</p>
<!-- @@@QWIDGETSIZE_MAX -->
</div>
        </div>
       </div>
   </div>
   </div>
</div>
<div class="footer">
   <p>
   <acronym title="Copyright">&copy;</acronym> 2019 The Qt Company Ltd.
   Documentation contributions included herein are the copyrights of
   their respective owners.<br/>    The documentation provided herein is licensed under the terms of the    <a href="http://www.gnu.org/licenses/fdl.html">GNU Free Documentation    License version 1.3</a> as published by the Free Software Foundation.<br/>    Qt and respective logos are trademarks of The Qt Company Ltd.     in Finland and/or other countries worldwide. All other trademarks are property
   of their respective owners. </p>
</div>
</body>
</html>
